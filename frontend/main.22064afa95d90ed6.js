"use strict"; (self.webpackChunkfrontend_mentor_projects = self.webpackChunkfrontend_mentor_projects || []).push([[179], { 416: () => { function ne(e) { return "function" == typeof e } function No(e) { const n = e(r => { Error.call(r), r.stack = (new Error).stack }); return n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n } const us = No(e => function (n) { e(this), this.message = n ? `${n.length} errors occurred during unsubscription:\n${n.map((r, o) => `${o + 1}) ${r.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = n }); function Po(e, t) { if (e) { const n = e.indexOf(t); 0 <= n && e.splice(n, 1) } } class ot { constructor(t) { this.initialTeardown = t, this.closed = !1, this._parentage = null, this._finalizers = null } unsubscribe() { let t; if (!this.closed) { this.closed = !0; const { _parentage: n } = this; if (n) if (this._parentage = null, Array.isArray(n)) for (const i of n) i.remove(this); else n.remove(this); const { initialTeardown: r } = this; if (ne(r)) try { r() } catch (i) { t = i instanceof us ? i.errors : [i] } const { _finalizers: o } = this; if (o) { this._finalizers = null; for (const i of o) try { gh(i) } catch (s) { t = t ?? [], s instanceof us ? t = [...t, ...s.errors] : t.push(s) } } if (t) throw new us(t) } } add(t) { var n; if (t && t !== this) if (this.closed) gh(t); else { if (t instanceof ot) { if (t.closed || t._hasParent(this)) return; t._addParent(this) } (this._finalizers = null !== (n = this._finalizers) && void 0 !== n ? n : []).push(t) } } _hasParent(t) { const { _parentage: n } = this; return n === t || Array.isArray(n) && n.includes(t) } _addParent(t) { const { _parentage: n } = this; this._parentage = Array.isArray(n) ? (n.push(t), n) : n ? [n, t] : t } _removeParent(t) { const { _parentage: n } = this; n === t ? this._parentage = null : Array.isArray(n) && Po(n, t) } remove(t) { const { _finalizers: n } = this; n && Po(n, t), t instanceof ot && t._removeParent(this) } } ot.EMPTY = (() => { const e = new ot; return e.closed = !0, e })(); const hh = ot.EMPTY; function ph(e) { return e instanceof ot || e && "closed" in e && ne(e.remove) && ne(e.add) && ne(e.unsubscribe) } function gh(e) { ne(e) ? e() : e.unsubscribe() } const qn = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: !1, useDeprecatedNextContext: !1 }, cs = { setTimeout(e, t, ...n) { const { delegate: r } = cs; return r?.setTimeout ? r.setTimeout(e, t, ...n) : setTimeout(e, t, ...n) }, clearTimeout(e) { const { delegate: t } = cs; return (t?.clearTimeout || clearTimeout)(e) }, delegate: void 0 }; function mh(e) { cs.setTimeout(() => { const { onUnhandledError: t } = qn; if (!t) throw e; t(e) }) } function Vu() { } const aE = ju("C", void 0, void 0); function ju(e, t, n) { return { kind: e, value: t, error: n } } let Wn = null; function ls(e) { if (qn.useDeprecatedSynchronousErrorHandling) { const t = !Wn; if (t && (Wn = { errorThrown: !1, error: null }), e(), t) { const { errorThrown: n, error: r } = Wn; if (Wn = null, n) throw r } } else e() } class Bu extends ot { constructor(t) { super(), this.isStopped = !1, t ? (this.destination = t, ph(t) && t.add(this)) : this.destination = pE } static create(t, n, r) { return new xo(t, n, r) } next(t) { this.isStopped ? $u(function cE(e) { return ju("N", e, void 0) }(t), this) : this._next(t) } error(t) { this.isStopped ? $u(function uE(e) { return ju("E", void 0, e) }(t), this) : (this.isStopped = !0, this._error(t)) } complete() { this.isStopped ? $u(aE, this) : (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe(), this.destination = null) } _next(t) { this.destination.next(t) } _error(t) { try { this.destination.error(t) } finally { this.unsubscribe() } } _complete() { try { this.destination.complete() } finally { this.unsubscribe() } } } const dE = Function.prototype.bind; function Hu(e, t) { return dE.call(e, t) } class fE { constructor(t) { this.partialObserver = t } next(t) { const { partialObserver: n } = this; if (n.next) try { n.next(t) } catch (r) { ds(r) } } error(t) { const { partialObserver: n } = this; if (n.error) try { n.error(t) } catch (r) { ds(r) } else ds(t) } complete() { const { partialObserver: t } = this; if (t.complete) try { t.complete() } catch (n) { ds(n) } } } class xo extends Bu { constructor(t, n, r) { let o; if (super(), ne(t) || !t) o = { next: t ?? void 0, error: n ?? void 0, complete: r ?? void 0 }; else { let i; this && qn.useDeprecatedNextContext ? (i = Object.create(t), i.unsubscribe = () => this.unsubscribe(), o = { next: t.next && Hu(t.next, i), error: t.error && Hu(t.error, i), complete: t.complete && Hu(t.complete, i) }) : o = t } this.destination = new fE(o) } } function ds(e) { qn.useDeprecatedSynchronousErrorHandling ? function lE(e) { qn.useDeprecatedSynchronousErrorHandling && Wn && (Wn.errorThrown = !0, Wn.error = e) }(e) : mh(e) } function $u(e, t) { const { onStoppedNotification: n } = qn; n && cs.setTimeout(() => n(e, t)) } const pE = { closed: !0, next: Vu, error: function hE(e) { throw e }, complete: Vu }, Uu = "function" == typeof Symbol && Symbol.observable || "@@observable"; function En(e) { return e } function vh(e) { return 0 === e.length ? En : 1 === e.length ? e[0] : function (n) { return e.reduce((r, o) => o(r), n) } } let me = (() => { class e { constructor(n) { n && (this._subscribe = n) } lift(n) { const r = new e; return r.source = this, r.operator = n, r } subscribe(n, r, o) { const i = function vE(e) { return e && e instanceof Bu || function mE(e) { return e && ne(e.next) && ne(e.error) && ne(e.complete) }(e) && ph(e) }(n) ? n : new xo(n, r, o); return ls(() => { const { operator: s, source: a } = this; i.add(s ? s.call(i, a) : a ? this._subscribe(i) : this._trySubscribe(i)) }), i } _trySubscribe(n) { try { return this._subscribe(n) } catch (r) { n.error(r) } } forEach(n, r) { return new (r = yh(r))((o, i) => { const s = new xo({ next: a => { try { n(a) } catch (u) { i(u), s.unsubscribe() } }, error: i, complete: o }); this.subscribe(s) }) } _subscribe(n) { var r; return null === (r = this.source) || void 0 === r ? void 0 : r.subscribe(n) } [Uu]() { return this } pipe(...n) { return vh(n)(this) } toPromise(n) { return new (n = yh(n))((r, o) => { let i; this.subscribe(s => i = s, s => o(s), () => r(i)) }) } } return e.create = t => new e(t), e })(); function yh(e) { var t; return null !== (t = e ?? qn.Promise) && void 0 !== t ? t : Promise } const yE = No(e => function () { e(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed" }); let At = (() => { class e extends me { constructor() { super(), this.closed = !1, this.currentObservers = null, this.observers = [], this.isStopped = !1, this.hasError = !1, this.thrownError = null } lift(n) { const r = new _h(this, this); return r.operator = n, r } _throwIfClosed() { if (this.closed) throw new yE } next(n) { ls(() => { if (this._throwIfClosed(), !this.isStopped) { this.currentObservers || (this.currentObservers = Array.from(this.observers)); for (const r of this.currentObservers) r.next(n) } }) } error(n) { ls(() => { if (this._throwIfClosed(), !this.isStopped) { this.hasError = this.isStopped = !0, this.thrownError = n; const { observers: r } = this; for (; r.length;)r.shift().error(n) } }) } complete() { ls(() => { if (this._throwIfClosed(), !this.isStopped) { this.isStopped = !0; const { observers: n } = this; for (; n.length;)n.shift().complete() } }) } unsubscribe() { this.isStopped = this.closed = !0, this.observers = this.currentObservers = null } get observed() { var n; return (null === (n = this.observers) || void 0 === n ? void 0 : n.length) > 0 } _trySubscribe(n) { return this._throwIfClosed(), super._trySubscribe(n) } _subscribe(n) { return this._throwIfClosed(), this._checkFinalizedStatuses(n), this._innerSubscribe(n) } _innerSubscribe(n) { const { hasError: r, isStopped: o, observers: i } = this; return r || o ? hh : (this.currentObservers = null, i.push(n), new ot(() => { this.currentObservers = null, Po(i, n) })) } _checkFinalizedStatuses(n) { const { hasError: r, thrownError: o, isStopped: i } = this; r ? n.error(o) : i && n.complete() } asObservable() { const n = new me; return n.source = this, n } } return e.create = (t, n) => new _h(t, n), e })(); class _h extends At { constructor(t, n) { super(), this.destination = t, this.source = n } next(t) { var n, r; null === (r = null === (n = this.destination) || void 0 === n ? void 0 : n.next) || void 0 === r || r.call(n, t) } error(t) { var n, r; null === (r = null === (n = this.destination) || void 0 === n ? void 0 : n.error) || void 0 === r || r.call(n, t) } complete() { var t, n; null === (n = null === (t = this.destination) || void 0 === t ? void 0 : t.complete) || void 0 === n || n.call(t) } _subscribe(t) { var n, r; return null !== (r = null === (n = this.source) || void 0 === n ? void 0 : n.subscribe(t)) && void 0 !== r ? r : hh } } function Ch(e) { return ne(e?.lift) } function we(e) { return t => { if (Ch(t)) return t.lift(function (n) { try { return e(n, this) } catch (r) { this.error(r) } }); throw new TypeError("Unable to lift unknown Observable type") } } function Ce(e, t, n, r, o) { return new _E(e, t, n, r, o) } class _E extends Bu { constructor(t, n, r, o, i, s) { super(t), this.onFinalize = i, this.shouldUnsubscribe = s, this._next = n ? function (a) { try { n(a) } catch (u) { t.error(u) } } : super._next, this._error = o ? function (a) { try { o(a) } catch (u) { t.error(u) } finally { this.unsubscribe() } } : super._error, this._complete = r ? function () { try { r() } catch (a) { t.error(a) } finally { this.unsubscribe() } } : super._complete } unsubscribe() { var t; if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) { const { closed: n } = this; super.unsubscribe(), !n && (null === (t = this.onFinalize) || void 0 === t || t.call(this)) } } } function Y(e, t) { return we((n, r) => { let o = 0; n.subscribe(Ce(r, i => { r.next(e.call(t, i, o++)) })) }) } function Mn(e) { return this instanceof Mn ? (this.v = e, this) : new Mn(e) } function Eh(e) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var n, t = e[Symbol.asyncIterator]; return t ? t.call(e) : (e = function Wu(e) { var t = "function" == typeof Symbol && Symbol.iterator, n = t && e[t], r = 0; if (n) return n.call(e); if (e && "number" == typeof e.length) return { next: function () { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") }(e), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function () { return this }, n); function r(i) { n[i] = e[i] && function (s) { return new Promise(function (a, u) { !function o(i, s, a, u) { Promise.resolve(u).then(function (c) { i({ value: c, done: a }) }, s) }(a, u, (s = e[i](s)).done, s.value) }) } } } "function" == typeof SuppressedError && SuppressedError; const Mh = e => e && "number" == typeof e.length && "function" != typeof e; function Ih(e) { return ne(e?.then) } function Sh(e) { return ne(e[Uu]) } function Ah(e) { return Symbol.asyncIterator && ne(e?.[Symbol.asyncIterator]) } function Th(e) { return new TypeError(`You provided ${null !== e && "object" == typeof e ? "an invalid object" : `'${e}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`) } const Oh = function HE() { return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator" }(); function Nh(e) { return ne(e?.[Oh]) } function Ph(e) { return function bh(e, t, n) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var o, r = n.apply(e, t || []), i = []; return o = {}, a("next"), a("throw"), a("return", function s(h) { return function (p) { return Promise.resolve(p).then(h, d) } }), o[Symbol.asyncIterator] = function () { return this }, o; function a(h, p) { r[h] && (o[h] = function (g) { return new Promise(function (v, _) { i.push([h, g, v, _]) > 1 || u(h, g) }) }, p && (o[h] = p(o[h]))) } function u(h, p) { try { !function c(h) { h.value instanceof Mn ? Promise.resolve(h.value.v).then(l, d) : f(i[0][2], h) }(r[h](p)) } catch (g) { f(i[0][3], g) } } function l(h) { u("next", h) } function d(h) { u("throw", h) } function f(h, p) { h(p), i.shift(), i.length && u(i[0][0], i[0][1]) } }(this, arguments, function* () { const n = e.getReader(); try { for (; ;) { const { value: r, done: o } = yield Mn(n.read()); if (o) return yield Mn(void 0); yield yield Mn(r) } } finally { n.releaseLock() } }) } function xh(e) { return ne(e?.getReader) } function it(e) { if (e instanceof me) return e; if (null != e) { if (Sh(e)) return function $E(e) { return new me(t => { const n = e[Uu](); if (ne(n.subscribe)) return n.subscribe(t); throw new TypeError("Provided object does not correctly implement Symbol.observable") }) }(e); if (Mh(e)) return function UE(e) { return new me(t => { for (let n = 0; n < e.length && !t.closed; n++)t.next(e[n]); t.complete() }) }(e); if (Ih(e)) return function zE(e) { return new me(t => { e.then(n => { t.closed || (t.next(n), t.complete()) }, n => t.error(n)).then(null, mh) }) }(e); if (Ah(e)) return Rh(e); if (Nh(e)) return function GE(e) { return new me(t => { for (const n of e) if (t.next(n), t.closed) return; t.complete() }) }(e); if (xh(e)) return function qE(e) { return Rh(Ph(e)) }(e) } throw Th(e) } function Rh(e) { return new me(t => { (function WE(e, t) { var n, r, o, i; return function Dh(e, t, n, r) { return new (n || (n = Promise))(function (i, s) { function a(l) { try { c(r.next(l)) } catch (d) { s(d) } } function u(l) { try { c(r.throw(l)) } catch (d) { s(d) } } function c(l) { l.done ? i(l.value) : function o(i) { return i instanceof n ? i : new n(function (s) { s(i) }) }(l.value).then(a, u) } c((r = r.apply(e, t || [])).next()) }) }(this, void 0, void 0, function* () { try { for (n = Eh(e); !(r = yield n.next()).done;)if (t.next(r.value), t.closed) return } catch (s) { o = { error: s } } finally { try { r && !r.done && (i = n.return) && (yield i.call(n)) } finally { if (o) throw o.error } } t.complete() }) })(e, t).catch(n => t.error(n)) }) } function on(e, t, n, r = 0, o = !1) { const i = t.schedule(function () { n(), o ? e.add(this.schedule(null, r)) : this.unsubscribe() }, r); if (e.add(i), !o) return i } function Te(e, t, n = 1 / 0) { return ne(t) ? Te((r, o) => Y((i, s) => t(r, i, o, s))(it(e(r, o))), n) : ("number" == typeof t && (n = t), we((r, o) => function ZE(e, t, n, r, o, i, s, a) { const u = []; let c = 0, l = 0, d = !1; const f = () => { d && !u.length && !c && t.complete() }, h = g => c < r ? p(g) : u.push(g), p = g => { i && t.next(g), c++; let v = !1; it(n(g, l++)).subscribe(Ce(t, _ => { o?.(_), i ? h(_) : t.next(_) }, () => { v = !0 }, void 0, () => { if (v) try { for (c--; u.length && c < r;) { const _ = u.shift(); s ? on(t, s, () => p(_)) : p(_) } f() } catch (_) { t.error(_) } })) }; return e.subscribe(Ce(t, h, () => { d = !0, f() })), () => { a?.() } }(r, o, e, n))) } function mr(e = 1 / 0) { return Te(En, e) } const Ht = new me(e => e.complete()); function Zu(e) { return e[e.length - 1] } function Fh(e) { return ne(Zu(e)) ? e.pop() : void 0 } function Ro(e) { return function QE(e) { return e && ne(e.schedule) }(Zu(e)) ? e.pop() : void 0 } function kh(e, t = 0) { return we((n, r) => { n.subscribe(Ce(r, o => on(r, e, () => r.next(o), t), () => on(r, e, () => r.complete(), t), o => on(r, e, () => r.error(o), t))) }) } function Lh(e, t = 0) { return we((n, r) => { r.add(e.schedule(() => n.subscribe(r), t)) }) } function Vh(e, t) { if (!e) throw new Error("Iterable cannot be null"); return new me(n => { on(n, t, () => { const r = e[Symbol.asyncIterator](); on(n, t, () => { r.next().then(o => { o.done ? n.complete() : n.next(o.value) }) }, 0, !0) }) }) } function be(e, t) { return t ? function rM(e, t) { if (null != e) { if (Sh(e)) return function JE(e, t) { return it(e).pipe(Lh(t), kh(t)) }(e, t); if (Mh(e)) return function eM(e, t) { return new me(n => { let r = 0; return t.schedule(function () { r === e.length ? n.complete() : (n.next(e[r++]), n.closed || this.schedule()) }) }) }(e, t); if (Ih(e)) return function KE(e, t) { return it(e).pipe(Lh(t), kh(t)) }(e, t); if (Ah(e)) return Vh(e, t); if (Nh(e)) return function tM(e, t) { return new me(n => { let r; return on(n, t, () => { r = e[Oh](), on(n, t, () => { let o, i; try { ({ value: o, done: i } = r.next()) } catch (s) { return void n.error(s) } i ? n.complete() : n.next(o) }, 0, !0) }), () => ne(r?.return) && r.return() }) }(e, t); if (xh(e)) return function nM(e, t) { return Vh(Ph(e), t) }(e, t) } throw Th(e) }(e, t) : it(e) } class vt extends At { constructor(t) { super(), this._value = t } get value() { return this.getValue() } _subscribe(t) { const n = super._subscribe(t); return !n.closed && t.next(this._value), n } getValue() { const { hasError: t, thrownError: n, _value: r } = this; if (t) throw n; return this._throwIfClosed(), r } next(t) { super.next(this._value = t) } } function P(...e) { return be(e, Ro(e)) } function jh(e = {}) { const { connector: t = (() => new At), resetOnError: n = !0, resetOnComplete: r = !0, resetOnRefCountZero: o = !0 } = e; return i => { let s, a, u, c = 0, l = !1, d = !1; const f = () => { a?.unsubscribe(), a = void 0 }, h = () => { f(), s = u = void 0, l = d = !1 }, p = () => { const g = s; h(), g?.unsubscribe() }; return we((g, v) => { c++, !d && !l && f(); const _ = u = u ?? t(); v.add(() => { c--, 0 === c && !d && !l && (a = Yu(p, o)) }), _.subscribe(v), !s && c > 0 && (s = new xo({ next: m => _.next(m), error: m => { d = !0, f(), a = Yu(h, n, m), _.error(m) }, complete: () => { l = !0, f(), a = Yu(h, r), _.complete() } }), it(g).subscribe(s)) })(i) } } function Yu(e, t, ...n) { if (!0 === t) return void e(); if (!1 === t) return; const r = new xo({ next: () => { r.unsubscribe(), e() } }); return it(t(...n)).subscribe(r) } function Tt(e, t) { return we((n, r) => { let o = null, i = 0, s = !1; const a = () => s && !o && r.complete(); n.subscribe(Ce(r, u => { o?.unsubscribe(); let c = 0; const l = i++; it(e(u, l)).subscribe(o = Ce(r, d => r.next(t ? t(u, d, l, c++) : d), () => { o = null, a() })) }, () => { s = !0, a() })) }) } function sM(e, t) { return e === t } function K(e) { for (let t in e) if (e[t] === K) return t; throw Error("Could not find renamed property on target object.") } function fs(e, t) { for (const n in t) t.hasOwnProperty(n) && !e.hasOwnProperty(n) && (e[n] = t[n]) } function Ee(e) { if ("string" == typeof e) return e; if (Array.isArray(e)) return "[" + e.map(Ee).join(", ") + "]"; if (null == e) return "" + e; if (e.overriddenName) return `${e.overriddenName}`; if (e.name) return `${e.name}`; const t = e.toString(); if (null == t) return "" + t; const n = t.indexOf("\n"); return -1 === n ? t : t.substring(0, n) } function Qu(e, t) { return null == e || "" === e ? null === t ? "" : t : null == t || "" === t ? e : e + " " + t } const aM = K({ __forward_ref__: K }); function oe(e) { return e.__forward_ref__ = oe, e.toString = function () { return Ee(this()) }, e } function F(e) { return Xu(e) ? e() : e } function Xu(e) { return "function" == typeof e && e.hasOwnProperty(aM) && e.__forward_ref__ === oe } function Ju(e) { return e && !!e.\u0275providers } class C extends Error { constructor(t, n) { super(function hs(e, t) { return `NG0${Math.abs(e)}${t ? ": " + t : ""}` }(t, n)), this.code = t } } function L(e) { return "string" == typeof e ? e : null == e ? "" : String(e) } function Ku(e, t) { throw new C(-201, !1) } function yt(e, t) { null == e && function x(e, t, n, r) { throw new Error(`ASSERTION ERROR: ${e}` + (null == r ? "" : ` [Expected=> ${n} ${r} ${t} <=Actual]`)) }(t, e, null, "!=") } function T(e) { return { token: e.token, providedIn: e.providedIn || null, factory: e.factory, value: void 0 } } function at(e) { return { providers: e.providers || [], imports: e.imports || [] } } function ps(e) { return Hh(e, ms) || Hh(e, $h) } function Hh(e, t) { return e.hasOwnProperty(t) ? e[t] : null } function gs(e) { return e && (e.hasOwnProperty(ec) || e.hasOwnProperty(gM)) ? e[ec] : null } const ms = K({ \u0275prov: K }), ec = K({ \u0275inj: K }), $h = K({ ngInjectableDef: K }), gM = K({ ngInjectorDef: K }); var z = function (e) { return e[e.Default = 0] = "Default", e[e.Host = 1] = "Host", e[e.Self = 2] = "Self", e[e.SkipSelf = 4] = "SkipSelf", e[e.Optional = 8] = "Optional", e }(z || {}); let tc; function Xe(e) { const t = tc; return tc = e, t } function zh(e, t, n) { const r = ps(e); return r && "root" == r.providedIn ? void 0 === r.value ? r.value = r.factory() : r.value : n & z.Optional ? null : void 0 !== t ? t : void Ku(Ee(e)) } const ie = globalThis; class M { constructor(t, n) { this._desc = t, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof n ? this.__NG_ELEMENT_ID__ = n : void 0 !== n && (this.\u0275prov = T({ token: this, providedIn: n.providedIn || "root", factory: n.factory })) } get multi() { return this } toString() { return `InjectionToken ${this._desc}` } } const Fo = {}, sc = "__NG_DI_FLAG__", vs = "ngTempTokenPath", yM = /\n/gm, qh = "__source"; let vr; function In(e) { const t = vr; return vr = e, t } function DM(e, t = z.Default) { if (void 0 === vr) throw new C(-203, !1); return null === vr ? zh(e, void 0, t) : vr.get(e, t & z.Optional ? null : void 0, t) } function A(e, t = z.Default) { return (function Uh() { return tc }() || DM)(F(e), t) } function b(e, t = z.Default) { return A(e, ys(t)) } function ys(e) { return typeof e > "u" || "number" == typeof e ? e : 0 | (e.optional && 8) | (e.host && 1) | (e.self && 2) | (e.skipSelf && 4) } function ac(e) { const t = []; for (let n = 0; n < e.length; n++) { const r = F(e[n]); if (Array.isArray(r)) { if (0 === r.length) throw new C(900, !1); let o, i = z.Default; for (let s = 0; s < r.length; s++) { const a = r[s], u = wM(a); "number" == typeof u ? -1 === u ? o = a.token : i |= u : o = a } t.push(A(o, i)) } else t.push(A(r)) } return t } function ko(e, t) { return e[sc] = t, e.prototype[sc] = t, e } function wM(e) { return e[sc] } function sn(e) { return { toString: e }.toString() } var _s = function (e) { return e[e.OnPush = 0] = "OnPush", e[e.Default = 1] = "Default", e }(_s || {}), Ot = function (e) { return e[e.Emulated = 0] = "Emulated", e[e.None = 2] = "None", e[e.ShadowDom = 3] = "ShadowDom", e }(Ot || {}); const $t = {}, Z = [], Cs = K({ \u0275cmp: K }), uc = K({ \u0275dir: K }), cc = K({ \u0275pipe: K }), Zh = K({ \u0275mod: K }), an = K({ \u0275fac: K }), Lo = K({ __NG_ELEMENT_ID__: K }), Yh = K({ __NG_ENV_ID__: K }); function Qh(e, t, n) { let r = e.length; for (; ;) { const o = e.indexOf(t, n); if (-1 === o) return o; if (0 === o || e.charCodeAt(o - 1) <= 32) { const i = t.length; if (o + i === r || e.charCodeAt(o + i) <= 32) return o } n = o + 1 } } function lc(e, t, n) { let r = 0; for (; r < n.length;) { const o = n[r]; if ("number" == typeof o) { if (0 !== o) break; r++; const i = n[r++], s = n[r++], a = n[r++]; e.setAttribute(t, s, a, i) } else { const i = o, s = n[++r]; Jh(i) ? e.setProperty(t, i, s) : e.setAttribute(t, i, s), r++ } } return r } function Xh(e) { return 3 === e || 4 === e || 6 === e } function Jh(e) { return 64 === e.charCodeAt(0) } function Vo(e, t) { if (null !== t && 0 !== t.length) if (null === e || 0 === e.length) e = t.slice(); else { let n = -1; for (let r = 0; r < t.length; r++) { const o = t[r]; "number" == typeof o ? n = o : 0 === n || Kh(e, n, o, null, -1 === n || 2 === n ? t[++r] : null) } } return e } function Kh(e, t, n, r, o) { let i = 0, s = e.length; if (-1 === t) s = -1; else for (; i < e.length;) { const a = e[i++]; if ("number" == typeof a) { if (a === t) { s = -1; break } if (a > t) { s = i - 1; break } } } for (; i < e.length;) { const a = e[i]; if ("number" == typeof a) break; if (a === n) { if (null === r) return void (null !== o && (e[i + 1] = o)); if (r === e[i + 1]) return void (e[i + 2] = o) } i++, null !== r && i++, null !== o && i++ } -1 !== s && (e.splice(s, 0, t), i = s + 1), e.splice(i++, 0, n), null !== r && e.splice(i++, 0, r), null !== o && e.splice(i++, 0, o) } const ep = "ng-template"; function MM(e, t, n) { let r = 0, o = !0; for (; r < e.length;) { let i = e[r++]; if ("string" == typeof i && o) { const s = e[r++]; if (n && "class" === i && -1 !== Qh(s.toLowerCase(), t, 0)) return !0 } else { if (1 === i) { for (; r < e.length && "string" == typeof (i = e[r++]);)if (i.toLowerCase() === t) return !0; return !1 } "number" == typeof i && (o = !1) } } return !1 } function tp(e) { return 4 === e.type && e.value !== ep } function IM(e, t, n) { return t === (4 !== e.type || n ? e.value : ep) } function SM(e, t, n) { let r = 4; const o = e.attrs || [], i = function OM(e) { for (let t = 0; t < e.length; t++)if (Xh(e[t])) return t; return e.length }(o); let s = !1; for (let a = 0; a < t.length; a++) { const u = t[a]; if ("number" != typeof u) { if (!s) if (4 & r) { if (r = 2 | 1 & r, "" !== u && !IM(e, u, n) || "" === u && 1 === t.length) { if (Nt(r)) return !1; s = !0 } } else { const c = 8 & r ? u : t[++a]; if (8 & r && null !== e.attrs) { if (!MM(e.attrs, c, n)) { if (Nt(r)) return !1; s = !0 } continue } const d = AM(8 & r ? "class" : u, o, tp(e), n); if (-1 === d) { if (Nt(r)) return !1; s = !0; continue } if ("" !== c) { let f; f = d > i ? "" : o[d + 1].toLowerCase(); const h = 8 & r ? f : null; if (h && -1 !== Qh(h, c, 0) || 2 & r && c !== f) { if (Nt(r)) return !1; s = !0 } } } } else { if (!s && !Nt(r) && !Nt(u)) return !1; if (s && Nt(u)) continue; s = !1, r = u | 1 & r } } return Nt(r) || s } function Nt(e) { return 0 == (1 & e) } function AM(e, t, n, r) { if (null === t) return -1; let o = 0; if (r || !n) { let i = !1; for (; o < t.length;) { const s = t[o]; if (s === e) return o; if (3 === s || 6 === s) i = !0; else { if (1 === s || 2 === s) { let a = t[++o]; for (; "string" == typeof a;)a = t[++o]; continue } if (4 === s) break; if (0 === s) { o += 4; continue } } o += i ? 1 : 2 } return -1 } return function NM(e, t) { let n = e.indexOf(4); if (n > -1) for (n++; n < e.length;) { const r = e[n]; if ("number" == typeof r) return -1; if (r === t) return n; n++ } return -1 }(t, e) } function np(e, t, n = !1) { for (let r = 0; r < t.length; r++)if (SM(e, t[r], n)) return !0; return !1 } function rp(e, t) { return e ? ":not(" + t.trim() + ")" : t } function xM(e) { let t = e[0], n = 1, r = 2, o = "", i = !1; for (; n < e.length;) { let s = e[n]; if ("string" == typeof s) if (2 & r) { const a = e[++n]; o += "[" + s + (a.length > 0 ? '="' + a + '"' : "") + "]" } else 8 & r ? o += "." + s : 4 & r && (o += " " + s); else "" !== o && !Nt(s) && (t += rp(i, o), o = ""), r = s, i = i || !Nt(r); n++ } return "" !== o && (t += rp(i, o)), t } function Ds(e) { return sn(() => { const t = ip(e), n = { ...t, decls: e.decls, vars: e.vars, template: e.template, consts: e.consts || null, ngContentSelectors: e.ngContentSelectors, onPush: e.changeDetection === _s.OnPush, directiveDefs: null, pipeDefs: null, dependencies: t.standalone && e.dependencies || null, getStandaloneInjector: null, signals: e.signals ?? !1, data: e.data || {}, encapsulation: e.encapsulation || Ot.Emulated, styles: e.styles || Z, _: null, schemas: e.schemas || null, tView: null, id: "" }; sp(n); const r = e.dependencies; return n.directiveDefs = ws(r, !1), n.pipeDefs = ws(r, !0), n.id = function HM(e) { let t = 0; const n = [e.selectors, e.ngContentSelectors, e.hostVars, e.hostAttrs, e.consts, e.vars, e.decls, e.encapsulation, e.standalone, e.signals, e.exportAs, JSON.stringify(e.inputs), JSON.stringify(e.outputs), Object.getOwnPropertyNames(e.type.prototype), !!e.contentQueries, !!e.viewQuery].join("|"); for (const o of n) t = Math.imul(31, t) + o.charCodeAt(0) << 0; return t += 2147483648, "c" + t }(n), n }) } function LM(e) { return q(e) || Oe(e) } function VM(e) { return null !== e } function _t(e) { return sn(() => ({ type: e.type, bootstrap: e.bootstrap || Z, declarations: e.declarations || Z, imports: e.imports || Z, exports: e.exports || Z, transitiveCompileScopes: null, schemas: e.schemas || null, id: e.id || null })) } function op(e, t) { if (null == e) return $t; const n = {}; for (const r in e) if (e.hasOwnProperty(r)) { let o = e[r], i = o; Array.isArray(o) && (i = o[1], o = o[0]), n[o] = r, t && (t[o] = i) } return n } function k(e) { return sn(() => { const t = ip(e); return sp(t), t }) } function q(e) { return e[Cs] || null } function Oe(e) { return e[uc] || null } function He(e) { return e[cc] || null } function ut(e, t) { const n = e[Zh] || null; if (!n && !0 === t) throw new Error(`Type ${Ee(e)} does not have '\u0275mod' property.`); return n } function ip(e) { const t = {}; return { type: e.type, providersResolver: null, factory: null, hostBindings: e.hostBindings || null, hostVars: e.hostVars || 0, hostAttrs: e.hostAttrs || null, contentQueries: e.contentQueries || null, declaredInputs: t, inputTransforms: null, inputConfig: e.inputs || $t, exportAs: e.exportAs || null, standalone: !0 === e.standalone, signals: !0 === e.signals, selectors: e.selectors || Z, viewQuery: e.viewQuery || null, features: e.features || null, setInput: null, findHostDirectiveDefs: null, hostDirectives: null, inputs: op(e.inputs, t), outputs: op(e.outputs) } } function sp(e) { e.features?.forEach(t => t(e)) } function ws(e, t) { if (!e) return null; const n = t ? He : LM; return () => ("function" == typeof e ? e() : e).map(r => n(r)).filter(VM) } const he = 0, w = 1, B = 2, le = 3, Pt = 4, jo = 5, Fe = 6, _r = 7, ve = 8, Sn = 9, Cr = 10, V = 11, Bo = 12, ap = 13, Dr = 14, ye = 15, Ho = 16, wr = 17, Ut = 18, $o = 19, up = 20, An = 21, un = 22, Uo = 23, zo = 24, G = 25, dc = 1, cp = 2, zt = 7, br = 9, Ne = 11; function Ke(e) { return Array.isArray(e) && "object" == typeof e[dc] } function $e(e) { return Array.isArray(e) && !0 === e[dc] } function fc(e) { return 0 != (4 & e.flags) } function Yn(e) { return e.componentOffset > -1 } function Es(e) { return 1 == (1 & e.flags) } function xt(e) { return !!e.template } function hc(e) { return 0 != (512 & e[B]) } function Qn(e, t) { return e.hasOwnProperty(an) ? e[an] : null } let Pe = null, Ms = !1; function Ct(e) { const t = Pe; return Pe = e, t } const fp = { version: 0, dirty: !1, producerNode: void 0, producerLastReadVersion: void 0, producerIndexOfThis: void 0, nextProducerIndex: 0, liveConsumerNode: void 0, liveConsumerIndexOfThis: void 0, consumerAllowSignalWrites: !1, consumerIsAlwaysLive: !1, producerMustRecompute: () => !1, producerRecomputeValue: () => { }, consumerMarkedDirty: () => { } }; function pp(e) { if (!qo(e) || e.dirty) { if (!e.producerMustRecompute(e) && !vp(e)) return void (e.dirty = !1); e.producerRecomputeValue(e), e.dirty = !1 } } function mp(e) { e.dirty = !0, function gp(e) { if (void 0 === e.liveConsumerNode) return; const t = Ms; Ms = !0; try { for (const n of e.liveConsumerNode) n.dirty || mp(n) } finally { Ms = t } }(e), e.consumerMarkedDirty?.(e) } function gc(e) { return e && (e.nextProducerIndex = 0), Ct(e) } function mc(e, t) { if (Ct(t), e && void 0 !== e.producerNode && void 0 !== e.producerIndexOfThis && void 0 !== e.producerLastReadVersion) { if (qo(e)) for (let n = e.nextProducerIndex; n < e.producerNode.length; n++)Is(e.producerNode[n], e.producerIndexOfThis[n]); for (; e.producerNode.length > e.nextProducerIndex;)e.producerNode.pop(), e.producerLastReadVersion.pop(), e.producerIndexOfThis.pop() } } function vp(e) { Er(e); for (let t = 0; t < e.producerNode.length; t++) { const n = e.producerNode[t], r = e.producerLastReadVersion[t]; if (r !== n.version || (pp(n), r !== n.version)) return !0 } return !1 } function yp(e) { if (Er(e), qo(e)) for (let t = 0; t < e.producerNode.length; t++)Is(e.producerNode[t], e.producerIndexOfThis[t]); e.producerNode.length = e.producerLastReadVersion.length = e.producerIndexOfThis.length = 0, e.liveConsumerNode && (e.liveConsumerNode.length = e.liveConsumerIndexOfThis.length = 0) } function Is(e, t) { if (function Cp(e) { e.liveConsumerNode ??= [], e.liveConsumerIndexOfThis ??= [] }(e), Er(e), 1 === e.liveConsumerNode.length) for (let r = 0; r < e.producerNode.length; r++)Is(e.producerNode[r], e.producerIndexOfThis[r]); const n = e.liveConsumerNode.length - 1; if (e.liveConsumerNode[t] = e.liveConsumerNode[n], e.liveConsumerIndexOfThis[t] = e.liveConsumerIndexOfThis[n], e.liveConsumerNode.length--, e.liveConsumerIndexOfThis.length--, t < e.liveConsumerNode.length) { const r = e.liveConsumerIndexOfThis[t], o = e.liveConsumerNode[t]; Er(o), o.producerIndexOfThis[r] = t } } function qo(e) { return e.consumerIsAlwaysLive || (e?.liveConsumerNode?.length ?? 0) > 0 } function Er(e) { e.producerNode ??= [], e.producerIndexOfThis ??= [], e.producerLastReadVersion ??= [] } let Dp = null; const Mp = () => { }, eI = (() => ({ ...fp, consumerIsAlwaysLive: !0, consumerAllowSignalWrites: !1, consumerMarkedDirty: e => { e.schedule(e.ref) }, hasRun: !1, cleanupFn: Mp }))(); class tI { constructor(t, n, r) { this.previousValue = t, this.currentValue = n, this.firstChange = r } isFirstChange() { return this.firstChange } } function Dt() { return Ip } function Ip(e) { return e.type.prototype.ngOnChanges && (e.setInput = rI), nI } function nI() { const e = Ap(this), t = e?.current; if (t) { const n = e.previous; if (n === $t) e.previous = t; else for (let r in t) n[r] = t[r]; e.current = null, this.ngOnChanges(t) } } function rI(e, t, n, r) { const o = this.declaredInputs[n], i = Ap(e) || function oI(e, t) { return e[Sp] = t }(e, { previous: $t, current: null }), s = i.current || (i.current = {}), a = i.previous, u = a[o]; s[o] = new tI(u && u.currentValue, t, a === $t), e[r] = t } Dt.ngInherit = !0; const Sp = "__ngSimpleChanges__"; function Ap(e) { return e[Sp] || null } const Gt = function (e, t, n) { }; function se(e) { for (; Array.isArray(e);)e = e[he]; return e } function Ss(e, t) { return se(t[e]) } function et(e, t) { return se(t[e.index]) } function Np(e, t) { return e.data[t] } function ct(e, t) { const n = t[e]; return Ke(n) ? n : n[he] } function On(e, t) { return null == t ? null : e[t] } function Pp(e) { e[wr] = 0 } function lI(e) { 1024 & e[B] || (e[B] |= 1024, Rp(e, 1)) } function xp(e) { 1024 & e[B] && (e[B] &= -1025, Rp(e, -1)) } function Rp(e, t) { let n = e[le]; if (null === n) return; n[jo] += t; let r = n; for (n = n[le]; null !== n && (1 === t && 1 === r[jo] || -1 === t && 0 === r[jo]);)n[jo] += t, r = n, n = n[le] } const R = { lFrame: Wp(null), bindingsEnabled: !0, skipHydrationRootTNode: null }; function Lp() { return R.bindingsEnabled } function y() { return R.lFrame.lView } function W() { return R.lFrame.tView } function xe() { let e = Bp(); for (; null !== e && 64 === e.type;)e = e.parent; return e } function Bp() { return R.lFrame.currentTNode } function qt(e, t) { const n = R.lFrame; n.currentTNode = e, n.isParent = t } function Dc() { return R.lFrame.isParent } function Sr() { return R.lFrame.bindingIndex++ } function wI(e, t) { const n = R.lFrame; n.bindingIndex = n.bindingRootIndex = e, bc(t) } function bc(e) { R.lFrame.currentDirectiveIndex = e } function Mc(e) { R.lFrame.currentQueryIndex = e } function EI(e) { const t = e[w]; return 2 === t.type ? t.declTNode : 1 === t.type ? e[Fe] : null } function Gp(e, t, n) { if (n & z.SkipSelf) { let o = t, i = e; for (; !(o = o.parent, null !== o || n & z.Host || (o = EI(i), null === o || (i = i[Dr], 10 & o.type)));); if (null === o) return !1; t = o, e = i } const r = R.lFrame = qp(); return r.currentTNode = t, r.lView = e, !0 } function Ic(e) { const t = qp(), n = e[w]; R.lFrame = t, t.currentTNode = n.firstChild, t.lView = e, t.tView = n, t.contextLView = e, t.bindingIndex = n.bindingStartIndex, t.inI18n = !1 } function qp() { const e = R.lFrame, t = null === e ? null : e.child; return null === t ? Wp(e) : t } function Wp(e) { const t = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: e, child: null, inI18n: !1 }; return null !== e && (e.child = t), t } function Zp() { const e = R.lFrame; return R.lFrame = e.parent, e.currentTNode = null, e.lView = null, e } const Yp = Zp; function Sc() { const e = Zp(); e.isParent = !0, e.tView = null, e.selectedIndex = -1, e.contextLView = null, e.elementDepthCount = 0, e.currentDirectiveIndex = -1, e.currentNamespace = null, e.bindingRootIndex = -1, e.bindingIndex = -1, e.currentQueryIndex = 0 } function ze() { return R.lFrame.selectedIndex } function Xn(e) { R.lFrame.selectedIndex = e } let Xp = !0; function As() { return Xp } function Nn(e) { Xp = e } function Ts(e, t) { for (let n = t.directiveStart, r = t.directiveEnd; n < r; n++) { const i = e.data[n].type.prototype, { ngAfterContentInit: s, ngAfterContentChecked: a, ngAfterViewInit: u, ngAfterViewChecked: c, ngOnDestroy: l } = i; s && (e.contentHooks ??= []).push(-n, s), a && ((e.contentHooks ??= []).push(n, a), (e.contentCheckHooks ??= []).push(n, a)), u && (e.viewHooks ??= []).push(-n, u), c && ((e.viewHooks ??= []).push(n, c), (e.viewCheckHooks ??= []).push(n, c)), null != l && (e.destroyHooks ??= []).push(n, l) } } function Os(e, t, n) { Jp(e, t, 3, n) } function Ns(e, t, n, r) { (3 & e[B]) === n && Jp(e, t, n, r) } function Ac(e, t) { let n = e[B]; (3 & n) === t && (n &= 8191, n += 1, e[B] = n) } function Jp(e, t, n, r) { const i = r ?? -1, s = t.length - 1; let a = 0; for (let u = void 0 !== r ? 65535 & e[wr] : 0; u < s; u++)if ("number" == typeof t[u + 1]) { if (a = t[u], null != r && a >= r) break } else t[u] < 0 && (e[wr] += 65536), (a < i || -1 == i) && (PI(e, n, t, u), e[wr] = (4294901760 & e[wr]) + u + 2), u++ } function Kp(e, t) { Gt(4, e, t); const n = Ct(null); try { t.call(e) } finally { Ct(n), Gt(5, e, t) } } function PI(e, t, n, r) { const o = n[r] < 0, i = n[r + 1], a = e[o ? -n[r] : n[r]]; o ? e[B] >> 13 < e[wr] >> 16 && (3 & e[B]) === t && (e[B] += 8192, Kp(a, i)) : Kp(a, i) } const Ar = -1; class Zo { constructor(t, n, r) { this.factory = t, this.resolving = !1, this.canSeeViewProviders = n, this.injectImpl = r } } function Oc(e) { return e !== Ar } function Yo(e) { return 32767 & e } function Qo(e, t) { let n = function kI(e) { return e >> 16 }(e), r = t; for (; n > 0;)r = r[Dr], n--; return r } let Nc = !0; function Ps(e) { const t = Nc; return Nc = e, t } const eg = 255, tg = 5; let LI = 0; const Wt = {}; function xs(e, t) { const n = ng(e, t); if (-1 !== n) return n; const r = t[w]; r.firstCreatePass && (e.injectorIndex = t.length, Pc(r.data, e), Pc(t, null), Pc(r.blueprint, null)); const o = Rs(e, t), i = e.injectorIndex; if (Oc(o)) { const s = Yo(o), a = Qo(o, t), u = a[w].data; for (let c = 0; c < 8; c++)t[i + c] = a[s + c] | u[s + c] } return t[i + 8] = o, i } function Pc(e, t) { e.push(0, 0, 0, 0, 0, 0, 0, 0, t) } function ng(e, t) { return -1 === e.injectorIndex || e.parent && e.parent.injectorIndex === e.injectorIndex || null === t[e.injectorIndex + 8] ? -1 : e.injectorIndex } function Rs(e, t) { if (e.parent && -1 !== e.parent.injectorIndex) return e.parent.injectorIndex; let n = 0, r = null, o = t; for (; null !== o;) { if (r = cg(o), null === r) return Ar; if (n++, o = o[Dr], -1 !== r.injectorIndex) return r.injectorIndex | n << 16 } return Ar } function xc(e, t, n) { !function VI(e, t, n) { let r; "string" == typeof n ? r = n.charCodeAt(0) || 0 : n.hasOwnProperty(Lo) && (r = n[Lo]), null == r && (r = n[Lo] = LI++); const o = r & eg; t.data[e + (o >> tg)] |= 1 << o }(e, t, n) } function rg(e, t, n) { if (n & z.Optional || void 0 !== e) return e; Ku() } function og(e, t, n, r) { if (n & z.Optional && void 0 === r && (r = null), !(n & (z.Self | z.Host))) { const o = e[Sn], i = Xe(void 0); try { return o ? o.get(t, r, n & z.Optional) : zh(t, r, n & z.Optional) } finally { Xe(i) } } return rg(r, 0, n) } function ig(e, t, n, r = z.Default, o) { if (null !== e) { if (2048 & t[B] && !(r & z.Self)) { const s = function zI(e, t, n, r, o) { let i = e, s = t; for (; null !== i && null !== s && 2048 & s[B] && !(512 & s[B]);) { const a = sg(i, s, n, r | z.Self, Wt); if (a !== Wt) return a; let u = i.parent; if (!u) { const c = s[up]; if (c) { const l = c.get(n, Wt, r); if (l !== Wt) return l } u = cg(s), s = s[Dr] } i = u } return o }(e, t, n, r, Wt); if (s !== Wt) return s } const i = sg(e, t, n, r, Wt); if (i !== Wt) return i } return og(t, n, r, o) } function sg(e, t, n, r, o) { const i = function HI(e) { if ("string" == typeof e) return e.charCodeAt(0) || 0; const t = e.hasOwnProperty(Lo) ? e[Lo] : void 0; return "number" == typeof t ? t >= 0 ? t & eg : UI : t }(n); if ("function" == typeof i) { if (!Gp(t, e, r)) return r & z.Host ? rg(o, 0, r) : og(t, n, r, o); try { let s; if (s = i(r), null != s || r & z.Optional) return s; Ku() } finally { Yp() } } else if ("number" == typeof i) { let s = null, a = ng(e, t), u = Ar, c = r & z.Host ? t[ye][Fe] : null; for ((-1 === a || r & z.SkipSelf) && (u = -1 === a ? Rs(e, t) : t[a + 8], u !== Ar && ug(r, !1) ? (s = t[w], a = Yo(u), t = Qo(u, t)) : a = -1); -1 !== a;) { const l = t[w]; if (ag(i, a, l.data)) { const d = BI(a, t, n, s, r, c); if (d !== Wt) return d } u = t[a + 8], u !== Ar && ug(r, t[w].data[a + 8] === c) && ag(i, a, t) ? (s = l, a = Yo(u), t = Qo(u, t)) : a = -1 } } return o } function BI(e, t, n, r, o, i) { const s = t[w], a = s.data[e + 8], l = function Fs(e, t, n, r, o) { const i = e.providerIndexes, s = t.data, a = 1048575 & i, u = e.directiveStart, l = i >> 20, f = o ? a + l : e.directiveEnd; for (let h = r ? a : a + l; h < f; h++) { const p = s[h]; if (h < u && n === p || h >= u && p.type === n) return h } if (o) { const h = s[u]; if (h && xt(h) && h.type === n) return u } return null }(a, s, n, null == r ? Yn(a) && Nc : r != s && 0 != (3 & a.type), o & z.Host && i === a); return null !== l ? Jn(t, s, l, a) : Wt } function Jn(e, t, n, r) { let o = e[n]; const i = t.data; if (function xI(e) { return e instanceof Zo }(o)) { const s = o; s.resolving && function uM(e, t) { const n = t ? `. Dependency path: ${t.join(" > ")} > ${e}` : ""; throw new C(-200, `Circular dependency in DI detected for ${e}${n}`) }(function J(e) { return "function" == typeof e ? e.name || e.toString() : "object" == typeof e && null != e && "function" == typeof e.type ? e.type.name || e.type.toString() : L(e) }(i[n])); const a = Ps(s.canSeeViewProviders); s.resolving = !0; const c = s.injectImpl ? Xe(s.injectImpl) : null; Gp(e, r, z.Default); try { o = e[n] = s.factory(void 0, i, e, r), t.firstCreatePass && n >= r.directiveStart && function NI(e, t, n) { const { ngOnChanges: r, ngOnInit: o, ngDoCheck: i } = t.type.prototype; if (r) { const s = Ip(t); (n.preOrderHooks ??= []).push(e, s), (n.preOrderCheckHooks ??= []).push(e, s) } o && (n.preOrderHooks ??= []).push(0 - e, o), i && ((n.preOrderHooks ??= []).push(e, i), (n.preOrderCheckHooks ??= []).push(e, i)) }(n, i[n], t) } finally { null !== c && Xe(c), Ps(a), s.resolving = !1, Yp() } } return o } function ag(e, t, n) { return !!(n[t + (e >> tg)] & 1 << e) } function ug(e, t) { return !(e & z.Self || e & z.Host && t) } class Ge { constructor(t, n) { this._tNode = t, this._lView = n } get(t, n, r) { return ig(this._tNode, this._lView, t, ys(r), n) } } function UI() { return new Ge(xe(), y()) } function Re(e) { return sn(() => { const t = e.prototype.constructor, n = t[an] || Rc(t), r = Object.prototype; let o = Object.getPrototypeOf(e.prototype).constructor; for (; o && o !== r;) { const i = o[an] || Rc(o); if (i && i !== n) return i; o = Object.getPrototypeOf(o) } return i => new i }) } function Rc(e) { return Xu(e) ? () => { const t = Rc(F(e)); return t && t() } : Qn(e) } function cg(e) { const t = e[w], n = t.type; return 2 === n ? t.declTNode : 1 === n ? e[Fe] : null } const Or = "__parameters__"; function Pr(e, t, n) { return sn(() => { const r = function Fc(e) { return function (...n) { if (e) { const r = e(...n); for (const o in r) this[o] = r[o] } } }(t); function o(...i) { if (this instanceof o) return r.apply(this, i), this; const s = new o(...i); return a.annotation = s, a; function a(u, c, l) { const d = u.hasOwnProperty(Or) ? u[Or] : Object.defineProperty(u, Or, { value: [] })[Or]; for (; d.length <= l;)d.push(null); return (d[l] = d[l] || []).push(s), u } } return n && (o.prototype = Object.create(n.prototype)), o.prototype.ngMetadataName = e, o.annotationCls = o, o }) } function Rr(e, t) { e.forEach(n => Array.isArray(n) ? Rr(n, t) : t(n)) } function dg(e, t, n) { t >= e.length ? e.push(n) : e.splice(t, 0, n) } function Ls(e, t) { return t >= e.length - 1 ? e.pop() : e.splice(t, 1)[0] } function lt(e, t, n) { let r = Fr(e, t); return r >= 0 ? e[1 | r] = n : (r = ~r, function XI(e, t, n, r) { let o = e.length; if (o == t) e.push(n, r); else if (1 === o) e.push(r, e[0]), e[0] = n; else { for (o--, e.push(e[o - 1], e[o]); o > t;)e[o] = e[o - 2], o--; e[t] = n, e[t + 1] = r } }(e, r, t, n)), r } function kc(e, t) { const n = Fr(e, t); if (n >= 0) return e[1 | n] } function Fr(e, t) { return function fg(e, t, n) { let r = 0, o = e.length >> n; for (; o !== r;) { const i = r + (o - r >> 1), s = e[i << n]; if (t === s) return i << n; s > t ? o = i : r = i + 1 } return ~(o << n) }(e, t, 1) } const js = ko(Pr("Optional"), 8), Bs = ko(Pr("SkipSelf"), 4); function Gs(e) { return 128 == (128 & e.flags) } var Pn = function (e) { return e[e.Important = 1] = "Important", e[e.DashCase = 2] = "DashCase", e }(Pn || {}); const Hc = new Map; let DS = 0; const Uc = "__ngContext__"; function ke(e, t) { Ke(t) ? (e[Uc] = t[$o], function bS(e) { Hc.set(e[$o], e) }(t)) : e[Uc] = t } let zc; function Gc(e, t) { return zc(e, t) } function ni(e) { const t = e[le]; return $e(t) ? t[le] : t } function Pg(e) { return Rg(e[Bo]) } function xg(e) { return Rg(e[Pt]) } function Rg(e) { for (; null !== e && !$e(e);)e = e[Pt]; return e } function Vr(e, t, n, r, o) { if (null != r) { let i, s = !1; $e(r) ? i = r : Ke(r) && (s = !0, r = r[he]); const a = se(r); 0 === e && null !== n ? null == o ? Vg(t, n, a) : Kn(t, n, a, o || null, !0) : 1 === e && null !== n ? Kn(t, n, a, o || null, !0) : 2 === e ? function Js(e, t, n) { const r = Qs(e, t); r && function $S(e, t, n, r) { e.removeChild(t, n, r) }(e, r, t, n) }(t, a, s) : 3 === e && t.destroyNode(a), null != i && function GS(e, t, n, r, o) { const i = n[zt]; i !== se(n) && Vr(t, e, r, i, o); for (let a = Ne; a < n.length; a++) { const u = n[a]; oi(u[w], u, e, t, r, i) } }(t, e, i, n, o) } } function Zs(e, t, n) { return e.createElement(t, n) } function kg(e, t) { const n = e[br], r = n.indexOf(t); xp(t), n.splice(r, 1) } function Ys(e, t) { if (e.length <= Ne) return; const n = Ne + t, r = e[n]; if (r) { const o = r[Ho]; null !== o && o !== e && kg(o, r), t > 0 && (e[n - 1][Pt] = r[Pt]); const i = Ls(e, Ne + t); !function RS(e, t) { oi(e, t, t[V], 2, null, null), t[he] = null, t[Fe] = null }(r[w], r); const s = i[Ut]; null !== s && s.detachView(i[w]), r[le] = null, r[Pt] = null, r[B] &= -129 } return r } function Wc(e, t) { if (!(256 & t[B])) { const n = t[V]; t[Uo] && yp(t[Uo]), t[zo] && yp(t[zo]), n.destroyNode && oi(e, t, n, 3, null, null), function LS(e) { let t = e[Bo]; if (!t) return Zc(e[w], e); for (; t;) { let n = null; if (Ke(t)) n = t[Bo]; else { const r = t[Ne]; r && (n = r) } if (!n) { for (; t && !t[Pt] && t !== e;)Ke(t) && Zc(t[w], t), t = t[le]; null === t && (t = e), Ke(t) && Zc(t[w], t), n = t && t[Pt] } t = n } }(t) } } function Zc(e, t) { if (!(256 & t[B])) { t[B] &= -129, t[B] |= 256, function HS(e, t) { let n; if (null != e && null != (n = e.destroyHooks)) for (let r = 0; r < n.length; r += 2) { const o = t[n[r]]; if (!(o instanceof Zo)) { const i = n[r + 1]; if (Array.isArray(i)) for (let s = 0; s < i.length; s += 2) { const a = o[i[s]], u = i[s + 1]; Gt(4, a, u); try { u.call(a) } finally { Gt(5, a, u) } } else { Gt(4, o, i); try { i.call(o) } finally { Gt(5, o, i) } } } } }(e, t), function BS(e, t) { const n = e.cleanup, r = t[_r]; if (null !== n) for (let i = 0; i < n.length - 1; i += 2)if ("string" == typeof n[i]) { const s = n[i + 3]; s >= 0 ? r[s]() : r[-s].unsubscribe(), i += 2 } else n[i].call(r[n[i + 1]]); null !== r && (t[_r] = null); const o = t[An]; if (null !== o) { t[An] = null; for (let i = 0; i < o.length; i++)(0, o[i])() } }(e, t), 1 === t[w].type && t[V].destroy(); const n = t[Ho]; if (null !== n && $e(t[le])) { n !== t[le] && kg(n, t); const r = t[Ut]; null !== r && r.detachView(e) } !function ES(e) { Hc.delete(e[$o]) }(t) } } function Yc(e, t, n) { return function Lg(e, t, n) { let r = t; for (; null !== r && 40 & r.type;)r = (t = r).parent; if (null === r) return n[he]; { const { componentOffset: o } = r; if (o > -1) { const { encapsulation: i } = e.data[r.directiveStart + o]; if (i === Ot.None || i === Ot.Emulated) return null } return et(r, n) } }(e, t.parent, n) } function Kn(e, t, n, r, o) { e.insertBefore(t, n, r, o) } function Vg(e, t, n) { e.appendChild(t, n) } function jg(e, t, n, r, o) { null !== r ? Kn(e, t, n, r, o) : Vg(e, t, n) } function Qs(e, t) { return e.parentNode(t) } let Qc, el, $g = function Hg(e, t, n) { return 40 & e.type ? et(e, n) : null }; function Xs(e, t, n, r) { const o = Yc(e, r, t), i = t[V], a = function Bg(e, t, n) { return $g(e, t, n) }(r.parent || t[Fe], r, t); if (null != o) if (Array.isArray(n)) for (let u = 0; u < n.length; u++)jg(i, o, n[u], a, !1); else jg(i, o, n, a, !1); void 0 !== Qc && Qc(i, r, t, n, o) } function ri(e, t) { if (null !== t) { const n = t.type; if (3 & n) return et(t, e); if (4 & n) return Xc(-1, e[t.index]); if (8 & n) { const r = t.child; if (null !== r) return ri(e, r); { const o = e[t.index]; return $e(o) ? Xc(-1, o) : se(o) } } if (32 & n) return Gc(t, e)() || se(e[t.index]); { const r = zg(e, t); return null !== r ? Array.isArray(r) ? r[0] : ri(ni(e[ye]), r) : ri(e, t.next) } } return null } function zg(e, t) { return null !== t ? e[ye][Fe].projection[t.projection] : null } function Xc(e, t) { const n = Ne + e + 1; if (n < t.length) { const r = t[n], o = r[w].firstChild; if (null !== o) return ri(r, o) } return t[zt] } function Jc(e, t, n, r, o, i, s) { for (; null != n;) { const a = r[n.index], u = n.type; if (s && 0 === t && (a && ke(se(a), r), n.flags |= 2), 32 != (32 & n.flags)) if (8 & u) Jc(e, t, n.child, r, o, i, !1), Vr(t, e, o, a, i); else if (32 & u) { const c = Gc(n, r); let l; for (; l = c();)Vr(t, e, o, l, i); Vr(t, e, o, a, i) } else 16 & u ? qg(e, t, r, n, o, i) : Vr(t, e, o, a, i); n = s ? n.projectionNext : n.next } } function oi(e, t, n, r, o, i) { Jc(n, r, e.firstChild, t, o, i, !1) } function qg(e, t, n, r, o, i) { const s = n[ye], u = s[Fe].projection[r.projection]; if (Array.isArray(u)) for (let c = 0; c < u.length; c++)Vr(t, e, o, u[c], i); else { let c = u; const l = s[le]; Gs(r) && (c.flags |= 128), Jc(e, t, c, l, o, i, !0) } } function Wg(e, t, n) { "" === n ? e.removeAttribute(t, "class") : e.setAttribute(t, "class", n) } function Zg(e, t, n) { const { mergedAttrs: r, classes: o, styles: i } = n; null !== r && lc(e, t, r), null !== o && Wg(e, t, o), null !== i && function WS(e, t, n) { e.setAttribute(t, "style", n) }(e, t, i) } class Jg { constructor(t) { this.changingThisBreaksApplicationSecurity = t } toString() { return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)` } } const ui = new M("ENVIRONMENT_INITIALIZER"), um = new M("INJECTOR", -1), cm = new M("INJECTOR_DEF_TYPES"); class sl { get(t, n = Fo) { if (n === Fo) { const r = new Error(`NullInjectorError: No provider for ${Ee(t)}!`); throw r.name = "NullInjectorError", r } return n } } function D0(...e) { return { \u0275providers: lm(0, e), \u0275fromNgModule: !0 } } function lm(e, ...t) { const n = [], r = new Set; let o; const i = s => { n.push(s) }; return Rr(t, s => { const a = s; na(a, i, [], r) && (o ||= [], o.push(a)) }), void 0 !== o && dm(o, i), n } function dm(e, t) { for (let n = 0; n < e.length; n++) { const { ngModule: r, providers: o } = e[n]; ul(o, i => { t(i, r) }) } } function na(e, t, n, r) { if (!(e = F(e))) return !1; let o = null, i = gs(e); const s = !i && q(e); if (i || s) { if (s && !s.standalone) return !1; o = e } else { const u = e.ngModule; if (i = gs(u), !i) return !1; o = u } const a = r.has(o); if (s) { if (a) return !1; if (r.add(o), s.dependencies) { const u = "function" == typeof s.dependencies ? s.dependencies() : s.dependencies; for (const c of u) na(c, t, n, r) } } else { if (!i) return !1; { if (null != i.imports && !a) { let c; r.add(o); try { Rr(i.imports, l => { na(l, t, n, r) && (c ||= [], c.push(l)) }) } finally { } void 0 !== c && dm(c, t) } if (!a) { const c = Qn(o) || (() => new o); t({ provide: o, useFactory: c, deps: Z }, o), t({ provide: cm, useValue: o, multi: !0 }, o), t({ provide: ui, useValue: () => A(o), multi: !0 }, o) } const u = i.providers; if (null != u && !a) { const c = e; ul(u, l => { t(l, c) }) } } } return o !== e && void 0 !== e.providers } function ul(e, t) { for (let n of e) Ju(n) && (n = n.\u0275providers), Array.isArray(n) ? ul(n, t) : t(n) } const w0 = K({ provide: String, useValue: K }); function cl(e) { return null !== e && "object" == typeof e && w0 in e } function er(e) { return "function" == typeof e } const ll = new M("Set Injector scope."), ra = {}, E0 = {}; let dl; function oa() { return void 0 === dl && (dl = new sl), dl } class dt { } class $r extends dt { get destroyed() { return this._destroyed } constructor(t, n, r, o) { super(), this.parent = n, this.source = r, this.scopes = o, this.records = new Map, this._ngOnDestroyHooks = new Set, this._onDestroyHooks = [], this._destroyed = !1, hl(t, s => this.processProvider(s)), this.records.set(um, Ur(void 0, this)), o.has("environment") && this.records.set(dt, Ur(void 0, this)); const i = this.records.get(ll); null != i && "string" == typeof i.value && this.scopes.add(i.value), this.injectorDefTypes = new Set(this.get(cm.multi, Z, z.Self)) } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { for (const n of this._ngOnDestroyHooks) n.ngOnDestroy(); const t = this._onDestroyHooks; this._onDestroyHooks = []; for (const n of t) n() } finally { this.records.clear(), this._ngOnDestroyHooks.clear(), this.injectorDefTypes.clear() } } onDestroy(t) { return this.assertNotDestroyed(), this._onDestroyHooks.push(t), () => this.removeOnDestroy(t) } runInContext(t) { this.assertNotDestroyed(); const n = In(this), r = Xe(void 0); try { return t() } finally { In(n), Xe(r) } } get(t, n = Fo, r = z.Default) { if (this.assertNotDestroyed(), t.hasOwnProperty(Yh)) return t[Yh](this); r = ys(r); const i = In(this), s = Xe(void 0); try { if (!(r & z.SkipSelf)) { let u = this.records.get(t); if (void 0 === u) { const c = function T0(e) { return "function" == typeof e || "object" == typeof e && e instanceof M }(t) && ps(t); u = c && this.injectableDefInScope(c) ? Ur(fl(t), ra) : null, this.records.set(t, u) } if (null != u) return this.hydrate(t, u) } return (r & z.Self ? oa() : this.parent).get(t, n = r & z.Optional && n === Fo ? null : n) } catch (a) { if ("NullInjectorError" === a.name) { if ((a[vs] = a[vs] || []).unshift(Ee(t)), i) throw a; return function bM(e, t, n, r) { const o = e[vs]; throw t[qh] && o.unshift(t[qh]), e.message = function EM(e, t, n, r = null) { e = e && "\n" === e.charAt(0) && "\u0275" == e.charAt(1) ? e.slice(2) : e; let o = Ee(t); if (Array.isArray(t)) o = t.map(Ee).join(" -> "); else if ("object" == typeof t) { let i = []; for (let s in t) if (t.hasOwnProperty(s)) { let a = t[s]; i.push(s + ":" + ("string" == typeof a ? JSON.stringify(a) : Ee(a))) } o = `{${i.join(", ")}}` } return `${n}${r ? "(" + r + ")" : ""}[${o}]: ${e.replace(yM, "\n  ")}` }("\n" + e.message, o, n, r), e.ngTokenPath = o, e[vs] = null, e }(a, t, "R3InjectorError", this.source) } throw a } finally { Xe(s), In(i) } } resolveInjectorInitializers() { const t = In(this), n = Xe(void 0); try { const o = this.get(ui.multi, Z, z.Self); for (const i of o) i() } finally { In(t), Xe(n) } } toString() { const t = [], n = this.records; for (const r of n.keys()) t.push(Ee(r)); return `R3Injector[${t.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new C(205, !1) } processProvider(t) { let n = er(t = F(t)) ? t : F(t && t.provide); const r = function I0(e) { return cl(e) ? Ur(void 0, e.useValue) : Ur(pm(e), ra) }(t); if (er(t) || !0 !== t.multi) this.records.get(n); else { let o = this.records.get(n); o || (o = Ur(void 0, ra, !0), o.factory = () => ac(o.multi), this.records.set(n, o)), n = t, o.multi.push(t) } this.records.set(n, r) } hydrate(t, n) { return n.value === ra && (n.value = E0, n.value = n.factory()), "object" == typeof n.value && n.value && function A0(e) { return null !== e && "object" == typeof e && "function" == typeof e.ngOnDestroy }(n.value) && this._ngOnDestroyHooks.add(n.value), n.value } injectableDefInScope(t) { if (!t.providedIn) return !1; const n = F(t.providedIn); return "string" == typeof n ? "any" === n || this.scopes.has(n) : this.injectorDefTypes.has(n) } removeOnDestroy(t) { const n = this._onDestroyHooks.indexOf(t); -1 !== n && this._onDestroyHooks.splice(n, 1) } } function fl(e) { const t = ps(e), n = null !== t ? t.factory : Qn(e); if (null !== n) return n; if (e instanceof M) throw new C(204, !1); if (e instanceof Function) return function M0(e) { const t = e.length; if (t > 0) throw function Ko(e, t) { const n = []; for (let r = 0; r < e; r++)n.push(t); return n }(t, "?"), new C(204, !1); const n = function pM(e) { return e && (e[ms] || e[$h]) || null }(e); return null !== n ? () => n.factory(e) : () => new e }(e); throw new C(204, !1) } function pm(e, t, n) { let r; if (er(e)) { const o = F(e); return Qn(o) || fl(o) } if (cl(e)) r = () => F(e.useValue); else if (function hm(e) { return !(!e || !e.useFactory) }(e)) r = () => e.useFactory(...ac(e.deps || [])); else if (function fm(e) { return !(!e || !e.useExisting) }(e)) r = () => A(F(e.useExisting)); else { const o = F(e && (e.useClass || e.provide)); if (!function S0(e) { return !!e.deps }(e)) return Qn(o) || fl(o); r = () => new o(...ac(e.deps)) } return r } function Ur(e, t, n = !1) { return { factory: e, value: t, multi: n ? [] : void 0 } } function hl(e, t) { for (const n of e) Array.isArray(n) ? hl(n, t) : n && Ju(n) ? hl(n.\u0275providers, t) : t(n) } const ia = new M("AppId", { providedIn: "root", factory: () => O0 }), O0 = "ng", gm = new M("Platform Initializer"), tr = new M("Platform ID", { providedIn: "platform", factory: () => "unknown" }), mm = new M("CSP nonce", { providedIn: "root", factory: () => function Br() { if (void 0 !== el) return el; if (typeof document < "u") return document; throw new C(210, !1) }().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce") || null }); let vm = (e, t, n) => null; function Dl(e, t, n = !1) { return vm(e, t, n) } class B0 { } class Cm { } class $0 { resolveComponentFactory(t) { throw function H0(e) { const t = Error(`No component factory found for ${Ee(e)}.`); return t.ngComponent = e, t }(t) } } let da = (() => { class e { static #e = this.NULL = new $0 } return e })(); function U0() { return qr(xe(), y()) } function qr(e, t) { return new ft(et(e, t)) } let ft = (() => { class e { constructor(n) { this.nativeElement = n } static #e = this.__NG_ELEMENT_ID__ = U0 } return e })(); class wm { } let fn = (() => { class e { constructor() { this.destroyNode = null } static #e = this.__NG_ELEMENT_ID__ = () => function G0() { const e = y(), n = ct(xe().index, e); return (Ke(n) ? n : e)[V] }() } return e })(), q0 = (() => { class e { static #e = this.\u0275prov = T({ token: e, providedIn: "root", factory: () => null }) } return e })(); class di { constructor(t) { this.full = t, this.major = t.split(".")[0], this.minor = t.split(".")[1], this.patch = t.split(".").slice(2).join(".") } } const W0 = new di("16.2.12"), El = {}; function Im(e, t = null, n = null, r) { const o = Sm(e, t, n, r); return o.resolveInjectorInitializers(), o } function Sm(e, t = null, n = null, r, o = new Set) { const i = [n || Z, D0(e)]; return r = r || ("object" == typeof e ? void 0 : Ee(e)), new $r(i, t || oa(), r || null, o) } let ht = (() => { class e { static #e = this.THROW_IF_NOT_FOUND = Fo; static #t = this.NULL = new sl; static create(n, r) { if (Array.isArray(n)) return Im({ name: "" }, r, n, ""); { const o = n.name ?? ""; return Im({ name: o }, n.parent, n.providers, o) } } static #n = this.\u0275prov = T({ token: e, providedIn: "any", factory: () => A(um) }); static #r = this.__NG_ELEMENT_ID__ = -1 } return e })(); function Il(e) { return e.ngOriginalError } class hn { constructor() { this._console = console } handleError(t) { const n = this._findOriginalError(t); this._console.error("ERROR", t), n && this._console.error("ORIGINAL ERROR", n) } _findOriginalError(t) { let n = t && Il(t); for (; n && Il(n);)n = Il(n); return n || null } } function Al(e) { return t => { setTimeout(e, void 0, t) } } const pe = class eA extends At { constructor(t = !1) { super(), this.__isAsync = t } emit(t) { super.next(t) } subscribe(t, n, r) { let o = t, i = n || (() => null), s = r; if (t && "object" == typeof t) { const u = t; o = u.next?.bind(u), i = u.error?.bind(u), s = u.complete?.bind(u) } this.__isAsync && (i = Al(i), o && (o = Al(o)), s && (s = Al(s))); const a = super.subscribe({ next: o, error: i, complete: s }); return t instanceof ot && t.add(a), a } }; function Tm(...e) { } class ae { constructor({ enableLongStackTrace: t = !1, shouldCoalesceEventChangeDetection: n = !1, shouldCoalesceRunChangeDetection: r = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new pe(!1), this.onMicrotaskEmpty = new pe(!1), this.onStable = new pe(!1), this.onError = new pe(!1), typeof Zone > "u") throw new C(908, !1); Zone.assertZonePatched(); const o = this; o._nesting = 0, o._outer = o._inner = Zone.current, Zone.TaskTrackingZoneSpec && (o._inner = o._inner.fork(new Zone.TaskTrackingZoneSpec)), t && Zone.longStackTraceZoneSpec && (o._inner = o._inner.fork(Zone.longStackTraceZoneSpec)), o.shouldCoalesceEventChangeDetection = !r && n, o.shouldCoalesceRunChangeDetection = r, o.lastRequestAnimationFrameId = -1, o.nativeRequestAnimationFrame = function tA() { const e = "function" == typeof ie.requestAnimationFrame; let t = ie[e ? "requestAnimationFrame" : "setTimeout"], n = ie[e ? "cancelAnimationFrame" : "clearTimeout"]; if (typeof Zone < "u" && t && n) { const r = t[Zone.__symbol__("OriginalDelegate")]; r && (t = r); const o = n[Zone.__symbol__("OriginalDelegate")]; o && (n = o) } return { nativeRequestAnimationFrame: t, nativeCancelAnimationFrame: n } }().nativeRequestAnimationFrame, function oA(e) { const t = () => { !function rA(e) { e.isCheckStableRunning || -1 !== e.lastRequestAnimationFrameId || (e.lastRequestAnimationFrameId = e.nativeRequestAnimationFrame.call(ie, () => { e.fakeTopEventTask || (e.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => { e.lastRequestAnimationFrameId = -1, Ol(e), e.isCheckStableRunning = !0, Tl(e), e.isCheckStableRunning = !1 }, void 0, () => { }, () => { })), e.fakeTopEventTask.invoke() }), Ol(e)) }(e) }; e._inner = e._inner.fork({ name: "angular", properties: { isAngularZone: !0 }, onInvokeTask: (n, r, o, i, s, a) => { if (function sA(e) { return !(!Array.isArray(e) || 1 !== e.length) && !0 === e[0].data?.__ignore_ng_zone__ }(a)) return n.invokeTask(o, i, s, a); try { return Om(e), n.invokeTask(o, i, s, a) } finally { (e.shouldCoalesceEventChangeDetection && "eventTask" === i.type || e.shouldCoalesceRunChangeDetection) && t(), Nm(e) } }, onInvoke: (n, r, o, i, s, a, u) => { try { return Om(e), n.invoke(o, i, s, a, u) } finally { e.shouldCoalesceRunChangeDetection && t(), Nm(e) } }, onHasTask: (n, r, o, i) => { n.hasTask(o, i), r === o && ("microTask" == i.change ? (e._hasPendingMicrotasks = i.microTask, Ol(e), Tl(e)) : "macroTask" == i.change && (e.hasPendingMacrotasks = i.macroTask)) }, onHandleError: (n, r, o, i) => (n.handleError(o, i), e.runOutsideAngular(() => e.onError.emit(i)), !1) }) }(o) } static isInAngularZone() { return typeof Zone < "u" && !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!ae.isInAngularZone()) throw new C(909, !1) } static assertNotInAngularZone() { if (ae.isInAngularZone()) throw new C(909, !1) } run(t, n, r) { return this._inner.run(t, n, r) } runTask(t, n, r, o) { const i = this._inner, s = i.scheduleEventTask("NgZoneEvent: " + o, t, nA, Tm, Tm); try { return i.runTask(s, n, r) } finally { i.cancelTask(s) } } runGuarded(t, n, r) { return this._inner.runGuarded(t, n, r) } runOutsideAngular(t) { return this._outer.run(t) } } const nA = {}; function Tl(e) { if (0 == e._nesting && !e.hasPendingMicrotasks && !e.isStable) try { e._nesting++, e.onMicrotaskEmpty.emit(null) } finally { if (e._nesting--, !e.hasPendingMicrotasks) try { e.runOutsideAngular(() => e.onStable.emit(null)) } finally { e.isStable = !0 } } } function Ol(e) { e.hasPendingMicrotasks = !!(e._hasPendingMicrotasks || (e.shouldCoalesceEventChangeDetection || e.shouldCoalesceRunChangeDetection) && -1 !== e.lastRequestAnimationFrameId) } function Om(e) { e._nesting++, e.isStable && (e.isStable = !1, e.onUnstable.emit(null)) } function Nm(e) { e._nesting--, Tl(e) } class iA { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new pe, this.onMicrotaskEmpty = new pe, this.onStable = new pe, this.onError = new pe } run(t, n, r) { return t.apply(n, r) } runGuarded(t, n, r) { return t.apply(n, r) } runOutsideAngular(t) { return t() } runTask(t, n, r, o) { return t.apply(n, r) } } const Pm = new M("", { providedIn: "root", factory: xm }); function xm() { const e = b(ae); let t = !0; return function oM(...e) { const t = Ro(e), n = function XE(e, t) { return "number" == typeof Zu(e) ? e.pop() : t }(e, 1 / 0), r = e; return r.length ? 1 === r.length ? it(r[0]) : mr(n)(be(r, t)) : Ht }(new me(o => { t = e.isStable && !e.hasPendingMacrotasks && !e.hasPendingMicrotasks, e.runOutsideAngular(() => { o.next(t), o.complete() }) }), new me(o => { let i; e.runOutsideAngular(() => { i = e.onStable.subscribe(() => { ae.assertNotInAngularZone(), queueMicrotask(() => { !t && !e.hasPendingMacrotasks && !e.hasPendingMicrotasks && (t = !0, o.next(!0)) }) }) }); const s = e.onUnstable.subscribe(() => { ae.assertInAngularZone(), t && (t = !1, e.runOutsideAngular(() => { o.next(!1) })) }); return () => { i.unsubscribe(), s.unsubscribe() } }).pipe(jh())) } function pn(e) { return e instanceof Function ? e() : e } let Nl = (() => { class e { constructor() { this.renderDepth = 0, this.handler = null } begin() { this.handler?.validateBegin(), this.renderDepth++ } end() { this.renderDepth--, 0 === this.renderDepth && this.handler?.execute() } ngOnDestroy() { this.handler?.destroy(), this.handler = null } static #e = this.\u0275prov = T({ token: e, providedIn: "root", factory: () => new e }) } return e })(); function fi(e) { for (; e;) { e[B] |= 64; const t = ni(e); if (hc(e) && !t) return e; e = t } return null } const Vm = new M("", { providedIn: "root", factory: () => !1 }); let ha = null; function $m(e, t) { return e[t] ?? Gm() } function Um(e, t) { const n = Gm(); n.producerNode?.length && (e[t] = ha, n.lView = e, ha = zm()) } const mA = { ...fp, consumerIsAlwaysLive: !0, consumerMarkedDirty: e => { fi(e.lView) }, lView: null }; function zm() { return Object.create(mA) } function Gm() { return ha ??= zm(), ha } const j = {}; function qe(e) { qm(W(), y(), ze() + e, !1) } function qm(e, t, n, r) { if (!r) if (3 == (3 & t[B])) { const i = e.preOrderCheckHooks; null !== i && Os(t, i, n) } else { const i = e.preOrderHooks; null !== i && Ns(t, i, 0, n) } Xn(n) } function D(e, t = z.Default) { const n = y(); return null === n ? A(e, t) : ig(xe(), n, F(e), t) } function pa(e, t, n, r, o, i, s, a, u, c, l) { const d = t.blueprint.slice(); return d[he] = o, d[B] = 140 | r, (null !== c || e && 2048 & e[B]) && (d[B] |= 2048), Pp(d), d[le] = d[Dr] = e, d[ve] = n, d[Cr] = s || e && e[Cr], d[V] = a || e && e[V], d[Sn] = u || e && e[Sn] || null, d[Fe] = i, d[$o] = function wS() { return DS++ }(), d[un] = l, d[up] = c, d[ye] = 2 == t.type ? e[ye] : d, d } function Yr(e, t, n, r, o) { let i = e.data[t]; if (null === i) i = function Pl(e, t, n, r, o) { const i = Bp(), s = Dc(), u = e.data[t] = function EA(e, t, n, r, o, i) { let s = t ? t.injectorIndex : -1, a = 0; return function Ir() { return null !== R.skipHydrationRootTNode }() && (a |= 128), { type: n, index: r, insertBeforeIndex: null, injectorIndex: s, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, componentOffset: -1, propertyBindings: null, flags: a, providerIndexes: 0, value: o, attrs: i, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tView: null, next: null, prev: null, projectionNext: null, child: null, parent: t, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } }(0, s ? i : i && i.parent, n, t, r, o); return null === e.firstChild && (e.firstChild = u), null !== i && (s ? null == i.child && null !== u.parent && (i.child = u) : null === i.next && (i.next = u, u.prev = i)), u }(e, t, n, r, o), function DI() { return R.lFrame.inI18n }() && (i.flags |= 32); else if (64 & i.type) { i.type = n, i.value = r, i.attrs = o; const s = function Wo() { const e = R.lFrame, t = e.currentTNode; return e.isParent ? t : t.parent }(); i.injectorIndex = null === s ? -1 : s.injectorIndex } return qt(i, !0), i } function hi(e, t, n, r) { if (0 === n) return -1; const o = t.length; for (let i = 0; i < n; i++)t.push(r), e.blueprint.push(r), e.data.push(null); return o } function Zm(e, t, n, r, o) { const i = $m(t, Uo), s = ze(), a = 2 & r; try { Xn(-1), a && t.length > G && qm(e, t, G, !1), Gt(a ? 2 : 0, o); const c = a ? i : null, l = gc(c); try { null !== c && (c.dirty = !1), n(r, o) } finally { mc(c, l) } } finally { a && null === t[Uo] && Um(t, Uo), Xn(s), Gt(a ? 3 : 1, o) } } function xl(e, t, n) { if (fc(t)) { const r = Ct(null); try { const i = t.directiveEnd; for (let s = t.directiveStart; s < i; s++) { const a = e.data[s]; a.contentQueries && a.contentQueries(1, n[s], s) } } finally { Ct(r) } } } function Rl(e, t, n) { Lp() && (function NA(e, t, n, r) { const o = n.directiveStart, i = n.directiveEnd; Yn(n) && function VA(e, t, n) { const r = et(t, e), o = Ym(n); let s = 16; n.signals ? s = 4096 : n.onPush && (s = 64); const a = ga(e, pa(e, o, null, s, r, t, null, e[Cr].rendererFactory.createRenderer(r, n), null, null, null)); e[t.index] = a }(t, n, e.data[o + n.componentOffset]), e.firstCreatePass || xs(n, t), ke(r, t); const s = n.initialInputs; for (let a = o; a < i; a++) { const u = e.data[a], c = Jn(t, e, a, n); ke(c, t), null !== s && jA(0, a - o, c, u, 0, s), xt(u) && (ct(n.index, t)[ve] = Jn(t, e, a, n)) } }(e, t, n, et(n, t)), 64 == (64 & n.flags) && ev(e, t, n)) } function Fl(e, t, n = et) { const r = t.localNames; if (null !== r) { let o = t.index + 1; for (let i = 0; i < r.length; i += 2) { const s = r[i + 1], a = -1 === s ? n(t, e) : e[s]; e[o++] = a } } } function Ym(e) { const t = e.tView; return null === t || t.incompleteFirstPass ? e.tView = kl(1, null, e.template, e.decls, e.vars, e.directiveDefs, e.pipeDefs, e.viewQuery, e.schemas, e.consts, e.id) : t } function kl(e, t, n, r, o, i, s, a, u, c, l) { const d = G + r, f = d + o, h = function yA(e, t) { const n = []; for (let r = 0; r < t; r++)n.push(r < e ? null : j); return n }(d, f), p = "function" == typeof c ? c() : c; return h[w] = { type: e, blueprint: h, template: n, queries: null, viewQuery: a, declTNode: t, data: h.slice().fill(null, d), bindingStartIndex: d, expandoStartIndex: f, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof i ? i() : i, pipeRegistry: "function" == typeof s ? s() : s, firstChild: null, schemas: u, consts: p, incompleteFirstPass: !1, ssrId: l } } let Qm = e => null; function Xm(e, t, n, r) { for (let o in e) if (e.hasOwnProperty(o)) { n = null === n ? {} : n; const i = e[o]; null === r ? Jm(n, t, o, i) : r.hasOwnProperty(o) && Jm(n, t, r[o], i) } return n } function Jm(e, t, n, r) { e.hasOwnProperty(n) ? e[n].push(t, r) : e[n] = [t, r] } function Ll(e, t, n, r) { if (Lp()) { const o = null === r ? null : { "": -1 }, i = function xA(e, t) { const n = e.directiveRegistry; let r = null, o = null; if (n) for (let i = 0; i < n.length; i++) { const s = n[i]; if (np(t, s.selectors, !1)) if (r || (r = []), xt(s)) if (null !== s.findHostDirectiveDefs) { const a = []; o = o || new Map, s.findHostDirectiveDefs(s, a, o), r.unshift(...a, s), Vl(e, t, a.length) } else r.unshift(s), Vl(e, t, 0); else o = o || new Map, s.findHostDirectiveDefs?.(s, r, o), r.push(s) } return null === r ? null : [r, o] }(e, n); let s, a; null === i ? s = a = null : [s, a] = i, null !== s && Km(e, t, n, s, o, a), o && function RA(e, t, n) { if (t) { const r = e.localNames = []; for (let o = 0; o < t.length; o += 2) { const i = n[t[o + 1]]; if (null == i) throw new C(-301, !1); r.push(t[o], i) } } }(n, r, o) } n.mergedAttrs = Vo(n.mergedAttrs, n.attrs) } function Km(e, t, n, r, o, i) { for (let c = 0; c < r.length; c++)xc(xs(n, t), e, r[c].type); !function kA(e, t, n) { e.flags |= 1, e.directiveStart = t, e.directiveEnd = t + n, e.providerIndexes = t }(n, e.data.length, r.length); for (let c = 0; c < r.length; c++) { const l = r[c]; l.providersResolver && l.providersResolver(l) } let s = !1, a = !1, u = hi(e, t, r.length, null); for (let c = 0; c < r.length; c++) { const l = r[c]; n.mergedAttrs = Vo(n.mergedAttrs, l.hostAttrs), LA(e, n, t, u, l), FA(u, l, o), null !== l.contentQueries && (n.flags |= 4), (null !== l.hostBindings || null !== l.hostAttrs || 0 !== l.hostVars) && (n.flags |= 64); const d = l.type.prototype; !s && (d.ngOnChanges || d.ngOnInit || d.ngDoCheck) && ((e.preOrderHooks ??= []).push(n.index), s = !0), !a && (d.ngOnChanges || d.ngDoCheck) && ((e.preOrderCheckHooks ??= []).push(n.index), a = !0), u++ } !function MA(e, t, n) { const o = t.directiveEnd, i = e.data, s = t.attrs, a = []; let u = null, c = null; for (let l = t.directiveStart; l < o; l++) { const d = i[l], f = n ? n.get(d) : null, p = f ? f.outputs : null; u = Xm(d.inputs, l, u, f ? f.inputs : null), c = Xm(d.outputs, l, c, p); const g = null === u || null === s || tp(t) ? null : BA(u, l, s); a.push(g) } null !== u && (u.hasOwnProperty("class") && (t.flags |= 8), u.hasOwnProperty("style") && (t.flags |= 16)), t.initialInputs = a, t.inputs = u, t.outputs = c }(e, n, i) } function ev(e, t, n) { const r = n.directiveStart, o = n.directiveEnd, i = n.index, s = function bI() { return R.lFrame.currentDirectiveIndex }(); try { Xn(i); for (let a = r; a < o; a++) { const u = e.data[a], c = t[a]; bc(a), (null !== u.hostBindings || 0 !== u.hostVars || null !== u.hostAttrs) && PA(u, c) } } finally { Xn(-1), bc(s) } } function PA(e, t) { null !== e.hostBindings && e.hostBindings(1, t) } function Vl(e, t, n) { t.componentOffset = n, (e.components ??= []).push(t.index) } function FA(e, t, n) { if (n) { if (t.exportAs) for (let r = 0; r < t.exportAs.length; r++)n[t.exportAs[r]] = e; xt(t) && (n[""] = e) } } function LA(e, t, n, r, o) { e.data[r] = o; const i = o.factory || (o.factory = Qn(o.type)), s = new Zo(i, xt(o), D); e.blueprint[r] = s, n[r] = s, function TA(e, t, n, r, o) { const i = o.hostBindings; if (i) { let s = e.hostBindingOpCodes; null === s && (s = e.hostBindingOpCodes = []); const a = ~t.index; (function OA(e) { let t = e.length; for (; t > 0;) { const n = e[--t]; if ("number" == typeof n && n < 0) return n } return 0 })(s) != a && s.push(a), s.push(n, r, i) } }(e, t, r, hi(e, n, o.hostVars, j), o) } function jA(e, t, n, r, o, i) { const s = i[t]; if (null !== s) for (let a = 0; a < s.length;)tv(r, n, s[a++], s[a++], s[a++]) } function tv(e, t, n, r, o) { const i = Ct(null); try { const s = e.inputTransforms; null !== s && s.hasOwnProperty(r) && (o = s[r].call(t, o)), null !== e.setInput ? e.setInput(t, o, n, r) : t[r] = o } finally { Ct(i) } } function BA(e, t, n) { let r = null, o = 0; for (; o < n.length;) { const i = n[o]; if (0 !== i) if (5 !== i) { if ("number" == typeof i) break; if (e.hasOwnProperty(i)) { null === r && (r = []); const s = e[i]; for (let a = 0; a < s.length; a += 2)if (s[a] === t) { r.push(i, s[a + 1], n[o + 1]); break } } o += 2 } else o += 2; else o += 4 } return r } function nv(e, t, n, r) { return [e, !0, !1, t, null, 0, r, n, null, null, null] } function rv(e, t) { const n = e.contentQueries; if (null !== n) for (let r = 0; r < n.length; r += 2) { const i = n[r + 1]; if (-1 !== i) { const s = e.data[i]; Mc(n[r]), s.contentQueries(2, t[i], i) } } } function ga(e, t) { return e[Bo] ? e[ap][Pt] = t : e[Bo] = t, e[ap] = t, t } function Bl(e, t, n) { Mc(0); const r = Ct(null); try { t(e, n) } finally { Ct(r) } } function av(e, t) { const n = e[Sn], r = n ? n.get(hn, null) : null; r && r.handleError(t) } function Hl(e, t, n, r, o) { for (let i = 0; i < n.length;) { const s = n[i++], a = n[i++]; tv(e.data[s], t[s], r, a, o) } } function HA(e, t) { const n = ct(t, e), r = n[w]; !function $A(e, t) { for (let n = t.length; n < e.blueprint.length; n++)t.push(e.blueprint[n]) }(r, n); const o = n[he]; null !== o && null === n[un] && (n[un] = Dl(o, n[Sn])), $l(r, n, n[ve]) } function $l(e, t, n) { Ic(t); try { const r = e.viewQuery; null !== r && Bl(1, r, n); const o = e.template; null !== o && Zm(e, t, o, 1, n), e.firstCreatePass && (e.firstCreatePass = !1), e.staticContentQueries && rv(e, t), e.staticViewQueries && Bl(2, e.viewQuery, n); const i = e.components; null !== i && function UA(e, t) { for (let n = 0; n < t.length; n++)HA(e, t[n]) }(t, i) } catch (r) { throw e.firstCreatePass && (e.incompleteFirstPass = !0, e.firstCreatePass = !1), r } finally { t[B] &= -5, Sc() } } let uv = (() => { class e { constructor() { this.all = new Set, this.queue = new Map } create(n, r, o) { const i = typeof Zone > "u" ? null : Zone.current, s = function KM(e, t, n) { const r = Object.create(eI); n && (r.consumerAllowSignalWrites = !0), r.fn = e, r.schedule = t; const o = s => { r.cleanupFn = s }; return r.ref = { notify: () => mp(r), run: () => { if (r.dirty = !1, r.hasRun && !vp(r)) return; r.hasRun = !0; const s = gc(r); try { r.cleanupFn(), r.cleanupFn = Mp, r.fn(o) } finally { mc(r, s) } }, cleanup: () => r.cleanupFn() }, r.ref }(n, c => { this.all.has(c) && this.queue.set(c, i) }, o); let a; this.all.add(s), s.notify(); const u = () => { s.cleanup(), a?.(), this.all.delete(s), this.queue.delete(s) }; return a = r?.onDestroy(u), { destroy: u } } flush() { if (0 !== this.queue.size) for (const [n, r] of this.queue) this.queue.delete(n), r ? r.run(() => n.run()) : n.run() } get isQueueEmpty() { return 0 === this.queue.size } static #e = this.\u0275prov = T({ token: e, providedIn: "root", factory: () => new e }) } return e })(); function ma(e, t, n) { let r = n ? e.styles : null, o = n ? e.classes : null, i = 0; if (null !== t) for (let s = 0; s < t.length; s++) { const a = t[s]; "number" == typeof a ? i = a : 1 == i ? o = Qu(o, a) : 2 == i && (r = Qu(r, a + ": " + t[++s] + ";")) } n ? e.styles = r : e.stylesWithoutHost = r, n ? e.classes = o : e.classesWithoutHost = o } function pi(e, t, n, r, o = !1) { for (; null !== n;) { const i = t[n.index]; null !== i && r.push(se(i)), $e(i) && cv(i, r); const s = n.type; if (8 & s) pi(e, t, n.child, r); else if (32 & s) { const a = Gc(n, t); let u; for (; u = a();)r.push(u) } else if (16 & s) { const a = zg(t, n); if (Array.isArray(a)) r.push(...a); else { const u = ni(t[ye]); pi(u[w], u, a, r, !0) } } n = o ? n.projectionNext : n.next } return r } function cv(e, t) { for (let n = Ne; n < e.length; n++) { const r = e[n], o = r[w].firstChild; null !== o && pi(r[w], r, o, t) } e[zt] !== e[he] && t.push(e[zt]) } function va(e, t, n, r = !0) { const o = t[Cr], i = o.rendererFactory, s = o.afterRenderEventManager; i.begin?.(), s?.begin(); try { lv(e, t, e.template, n) } catch (u) { throw r && av(t, u), u } finally { i.end?.(), o.effectManager?.flush(), s?.end() } } function lv(e, t, n, r) { const o = t[B]; if (256 != (256 & o)) { t[Cr].effectManager?.flush(), Ic(t); try { Pp(t), function $p(e) { return R.lFrame.bindingIndex = e }(e.bindingStartIndex), null !== n && Zm(e, t, n, 2, r); const s = 3 == (3 & o); if (s) { const c = e.preOrderCheckHooks; null !== c && Os(t, c, null) } else { const c = e.preOrderHooks; null !== c && Ns(t, c, 0, null), Ac(t, 0) } if (function qA(e) { for (let t = Pg(e); null !== t; t = xg(t)) { if (!t[cp]) continue; const n = t[br]; for (let r = 0; r < n.length; r++) { lI(n[r]) } } }(t), dv(t, 2), null !== e.contentQueries && rv(e, t), s) { const c = e.contentCheckHooks; null !== c && Os(t, c) } else { const c = e.contentHooks; null !== c && Ns(t, c, 1), Ac(t, 1) } !function vA(e, t) { const n = e.hostBindingOpCodes; if (null === n) return; const r = $m(t, zo); try { for (let o = 0; o < n.length; o++) { const i = n[o]; if (i < 0) Xn(~i); else { const s = i, a = n[++o], u = n[++o]; wI(a, s), r.dirty = !1; const c = gc(r); try { u(2, t[s]) } finally { mc(r, c) } } } } finally { null === t[zo] && Um(t, zo), Xn(-1) } }(e, t); const a = e.components; null !== a && hv(t, a, 0); const u = e.viewQuery; if (null !== u && Bl(2, u, r), s) { const c = e.viewCheckHooks; null !== c && Os(t, c) } else { const c = e.viewHooks; null !== c && Ns(t, c, 2), Ac(t, 2) } !0 === e.firstUpdatePass && (e.firstUpdatePass = !1), t[B] &= -73, xp(t) } finally { Sc() } } } function dv(e, t) { for (let n = Pg(e); null !== n; n = xg(n))for (let r = Ne; r < n.length; r++)fv(n[r], t) } function WA(e, t, n) { fv(ct(t, e), n) } function fv(e, t) { if (!function uI(e) { return 128 == (128 & e[B]) }(e)) return; const n = e[w], r = e[B]; if (80 & r && 0 === t || 1024 & r || 2 === t) lv(n, e, n.template, e[ve]); else if (e[jo] > 0) { dv(e, 1); const o = n.components; null !== o && hv(e, o, 1) } } function hv(e, t, n) { for (let r = 0; r < t.length; r++)WA(e, t[r], n) } class gi { get rootNodes() { const t = this._lView, n = t[w]; return pi(n, t, n.firstChild, []) } constructor(t, n) { this._lView = t, this._cdRefInjectingView = n, this._appRef = null, this._attachedToViewContainer = !1 } get context() { return this._lView[ve] } set context(t) { this._lView[ve] = t } get destroyed() { return 256 == (256 & this._lView[B]) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { const t = this._lView[le]; if ($e(t)) { const n = t[8], r = n ? n.indexOf(this) : -1; r > -1 && (Ys(t, r), Ls(n, r)) } this._attachedToViewContainer = !1 } Wc(this._lView[w], this._lView) } onDestroy(t) { !function Fp(e, t) { if (256 == (256 & e[B])) throw new C(911, !1); null === e[An] && (e[An] = []), e[An].push(t) }(this._lView, t) } markForCheck() { fi(this._cdRefInjectingView || this._lView) } detach() { this._lView[B] &= -129 } reattach() { this._lView[B] |= 128 } detectChanges() { va(this._lView[w], this._lView, this.context) } checkNoChanges() { } attachToViewContainerRef() { if (this._appRef) throw new C(902, !1); this._attachedToViewContainer = !0 } detachFromAppRef() { this._appRef = null, function kS(e, t) { oi(e, t, t[V], 2, null, null) }(this._lView[w], this._lView) } attachToAppRef(t) { if (this._attachedToViewContainer) throw new C(902, !1); this._appRef = t } } class ZA extends gi { constructor(t) { super(t), this._view = t } detectChanges() { const t = this._view; va(t[w], t, t[ve], !1) } checkNoChanges() { } get context() { return null } } class pv extends da { constructor(t) { super(), this.ngModule = t } resolveComponentFactory(t) { const n = q(t); return new mi(n, this.ngModule) } } function gv(e) { const t = []; for (let n in e) e.hasOwnProperty(n) && t.push({ propName: e[n], templateName: n }); return t } class QA { constructor(t, n) { this.injector = t, this.parentInjector = n } get(t, n, r) { r = ys(r); const o = this.injector.get(t, El, r); return o !== El || n === El ? o : this.parentInjector.get(t, n, r) } } class mi extends Cm { get inputs() { const t = this.componentDef, n = t.inputTransforms, r = gv(t.inputs); if (null !== n) for (const o of r) n.hasOwnProperty(o.propName) && (o.transform = n[o.propName]); return r } get outputs() { return gv(this.componentDef.outputs) } constructor(t, n) { super(), this.componentDef = t, this.ngModule = n, this.componentType = t.type, this.selector = function RM(e) { return e.map(xM).join(",") }(t.selectors), this.ngContentSelectors = t.ngContentSelectors ? t.ngContentSelectors : [], this.isBoundToModule = !!n } create(t, n, r, o) { let i = (o = o || this.ngModule) instanceof dt ? o : o?.injector; i && null !== this.componentDef.getStandaloneInjector && (i = this.componentDef.getStandaloneInjector(i) || i); const s = i ? new QA(t, i) : t, a = s.get(wm, null); if (null === a) throw new C(407, !1); const d = { rendererFactory: a, sanitizer: s.get(q0, null), effectManager: s.get(uv, null), afterRenderEventManager: s.get(Nl, null) }, f = a.createRenderer(null, this.componentDef), h = this.componentDef.selectors[0][0] || "div", p = r ? function _A(e, t, n, r) { const i = r.get(Vm, !1) || n === Ot.ShadowDom, s = e.selectRootElement(t, i); return function CA(e) { Qm(e) }(s), s }(f, r, this.componentDef.encapsulation, s) : Zs(f, h, function YA(e) { const t = e.toLowerCase(); return "svg" === t ? "svg" : "math" === t ? "math" : null }(h)), _ = this.componentDef.signals ? 4608 : this.componentDef.onPush ? 576 : 528; let m = null; null !== p && (m = Dl(p, s, !0)); const E = kl(0, null, null, 1, 0, null, null, null, null, null, null), N = pa(null, E, null, _, null, null, d, f, s, null, m); let U, Ae; Ic(N); try { const rn = this.componentDef; let gr, fh = null; rn.findHostDirectiveDefs ? (gr = [], fh = new Map, rn.findHostDirectiveDefs(rn, gr, fh), gr.push(rn)) : gr = [rn]; const Z2 = function JA(e, t) { const n = e[w], r = G; return e[r] = t, Yr(n, r, 2, "#host", null) }(N, p), Y2 = function KA(e, t, n, r, o, i, s) { const a = o[w]; !function eT(e, t, n, r) { for (const o of e) t.mergedAttrs = Vo(t.mergedAttrs, o.hostAttrs); null !== t.mergedAttrs && (ma(t, t.mergedAttrs, !0), null !== n && Zg(r, n, t)) }(r, e, t, s); let u = null; null !== t && (u = Dl(t, o[Sn])); const c = i.rendererFactory.createRenderer(t, n); let l = 16; n.signals ? l = 4096 : n.onPush && (l = 64); const d = pa(o, Ym(n), null, l, o[e.index], e, i, c, null, null, u); return a.firstCreatePass && Vl(a, e, r.length - 1), ga(o, d), o[e.index] = d }(Z2, p, rn, gr, N, d, f); Ae = Np(E, G), p && function nT(e, t, n, r) { if (r) lc(e, n, ["ng-version", W0.full]); else { const { attrs: o, classes: i } = function FM(e) { const t = [], n = []; let r = 1, o = 2; for (; r < e.length;) { let i = e[r]; if ("string" == typeof i) 2 === o ? "" !== i && t.push(i, e[++r]) : 8 === o && n.push(i); else { if (!Nt(o)) break; o = i } r++ } return { attrs: t, classes: n } }(t.selectors[0]); o && lc(e, n, o), i && i.length > 0 && Wg(e, n, i.join(" ")) } }(f, rn, p, r), void 0 !== n && function rT(e, t, n) { const r = e.projection = []; for (let o = 0; o < t.length; o++) { const i = n[o]; r.push(null != i ? Array.from(i) : null) } }(Ae, this.ngContentSelectors, n), U = function tT(e, t, n, r, o, i) { const s = xe(), a = o[w], u = et(s, o); Km(a, o, s, n, null, r); for (let l = 0; l < n.length; l++)ke(Jn(o, a, s.directiveStart + l, s), o); ev(a, o, s), u && ke(u, o); const c = Jn(o, a, s.directiveStart + s.componentOffset, s); if (e[ve] = o[ve] = c, null !== i) for (const l of i) l(c, t); return xl(a, s, e), c }(Y2, rn, gr, fh, N, [oT]), $l(E, N, null) } finally { Sc() } return new XA(this.componentType, U, qr(Ae, N), N, Ae) } } class XA extends B0 { constructor(t, n, r, o, i) { super(), this.location = r, this._rootLView = o, this._tNode = i, this.previousInputValues = null, this.instance = n, this.hostView = this.changeDetectorRef = new ZA(o), this.componentType = t } setInput(t, n) { const r = this._tNode.inputs; let o; if (null !== r && (o = r[t])) { if (this.previousInputValues ??= new Map, this.previousInputValues.has(t) && Object.is(this.previousInputValues.get(t), n)) return; const i = this._rootLView; Hl(i[w], i, o, t, n), this.previousInputValues.set(t, n), fi(ct(this._tNode.index, i)) } } get injector() { return new Ge(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(t) { this.hostView.onDestroy(t) } } function oT() { const e = xe(); Ts(y()[w], e) } function ee(e) { let t = function mv(e) { return Object.getPrototypeOf(e.prototype).constructor }(e.type), n = !0; const r = [e]; for (; t;) { let o; if (xt(e)) o = t.\u0275cmp || t.\u0275dir; else { if (t.\u0275cmp) throw new C(903, !1); o = t.\u0275dir } if (o) { if (n) { r.push(o); const s = e; s.inputs = ya(e.inputs), s.inputTransforms = ya(e.inputTransforms), s.declaredInputs = ya(e.declaredInputs), s.outputs = ya(e.outputs); const a = o.hostBindings; a && uT(e, a); const u = o.viewQuery, c = o.contentQueries; if (u && sT(e, u), c && aT(e, c), fs(e.inputs, o.inputs), fs(e.declaredInputs, o.declaredInputs), fs(e.outputs, o.outputs), null !== o.inputTransforms && (null === s.inputTransforms && (s.inputTransforms = {}), fs(s.inputTransforms, o.inputTransforms)), xt(o) && o.data.animation) { const l = e.data; l.animation = (l.animation || []).concat(o.data.animation) } } const i = o.features; if (i) for (let s = 0; s < i.length; s++) { const a = i[s]; a && a.ngInherit && a(e), a === ee && (n = !1) } } t = Object.getPrototypeOf(t) } !function iT(e) { let t = 0, n = null; for (let r = e.length - 1; r >= 0; r--) { const o = e[r]; o.hostVars = t += o.hostVars, o.hostAttrs = Vo(o.hostAttrs, n = Vo(n, o.hostAttrs)) } }(r) } function ya(e) { return e === $t ? {} : e === Z ? [] : e } function sT(e, t) { const n = e.viewQuery; e.viewQuery = n ? (r, o) => { t(r, o), n(r, o) } : t } function aT(e, t) { const n = e.contentQueries; e.contentQueries = n ? (r, o, i) => { t(r, o, i), n(r, o, i) } : t } function uT(e, t) { const n = e.hostBindings; e.hostBindings = n ? (r, o) => { t(r, o), n(r, o) } : t } function _a(e) { return !!Ul(e) && (Array.isArray(e) || !(e instanceof Map) && Symbol.iterator in e) } function Ul(e) { return null !== e && ("function" == typeof e || "object" == typeof e) } function Le(e, t, n) { return !Object.is(e[t], n) && (e[t] = n, !0) } function Rn(e, t, n, r, o, i, s, a) { const u = y(), c = W(), l = e + G, d = c.firstCreatePass ? function xT(e, t, n, r, o, i, s, a, u) { const c = t.consts, l = Yr(t, e, 4, s || null, On(c, a)); Ll(t, n, l, On(c, u)), Ts(t, l); const d = l.tView = kl(2, l, r, o, i, t.directiveRegistry, t.pipeRegistry, null, t.schemas, c, null); return null !== t.queries && (t.queries.template(t, l), d.queries = t.queries.embeddedTView(l)), l }(l, c, u, t, n, r, o, i, s) : c.data[l]; qt(d, !1); const f = xv(c, u, d, e); As() && Xs(c, u, f, d), ke(f, u), ga(u, u[l] = nv(f, u, f, d)), Es(d) && Rl(c, u, d), null != s && Fl(u, d, a) } let xv = function Rv(e, t, n, r) { return Nn(!0), t[V].createComment("") }; function Et(e, t, n) { const r = y(); return Le(r, Sr(), t) && function pt(e, t, n, r, o, i, s, a) { const u = et(t, n); let l, c = t.inputs; !a && null != c && (l = c[r]) ? (Hl(e, n, l, r, o), Yn(t) && function SA(e, t) { const n = ct(t, e); 16 & n[B] || (n[B] |= 64) }(n, t.index)) : 3 & t.type && (r = function IA(e) { return "class" === e ? "className" : "for" === e ? "htmlFor" : "formaction" === e ? "formAction" : "innerHtml" === e ? "innerHTML" : "readonly" === e ? "readOnly" : "tabindex" === e ? "tabIndex" : e }(r), o = null != s ? s(o, t.value || "", r) : o, i.setProperty(u, r, o)) }(W(), function fe() { const e = R.lFrame; return Np(e.tView, e.selectedIndex) }(), r, e, t, r[V], n, !1), Et } function Yl(e, t, n, r, o) { const s = o ? "class" : "style"; Hl(e, n, t.inputs[s], s, r) } function S(e, t, n, r) { const o = y(), i = W(), s = G + e, a = o[V], u = i.firstCreatePass ? function VT(e, t, n, r, o, i) { const s = t.consts, u = Yr(t, e, 2, r, On(s, o)); return Ll(t, n, u, On(s, i)), null !== u.attrs && ma(u, u.attrs, !1), null !== u.mergedAttrs && ma(u, u.mergedAttrs, !0), null !== t.queries && t.queries.elementStart(t, u), u }(s, i, o, t, n, r) : i.data[s], c = Fv(i, o, u, a, t, e); o[s] = c; const l = Es(u); return qt(u, !0), Zg(a, c, u), 32 != (32 & u.flags) && As() && Xs(i, o, c, u), 0 === function fI() { return R.lFrame.elementDepthCount }() && ke(c, o), function hI() { R.lFrame.elementDepthCount++ }(), l && (Rl(i, o, u), xl(i, u, o)), null !== r && Fl(o, u), S } function I() { let e = xe(); Dc() ? function wc() { R.lFrame.isParent = !1 }() : (e = e.parent, qt(e, !1)); const t = e; (function gI(e) { return R.skipHydrationRootTNode === e })(t) && function _I() { R.skipHydrationRootTNode = null }(), function pI() { R.lFrame.elementDepthCount-- }(); const n = W(); return n.firstCreatePass && (Ts(n, e), fc(e) && n.queries.elementEnd(e)), null != t.classesWithoutHost && function RI(e) { return 0 != (8 & e.flags) }(t) && Yl(n, t, y(), t.classesWithoutHost, !0), null != t.stylesWithoutHost && function FI(e) { return 0 != (16 & e.flags) }(t) && Yl(n, t, y(), t.stylesWithoutHost, !1), I } function Ie(e, t, n, r) { return S(e, t, n, r), I(), Ie } let Fv = (e, t, n, r, o, i) => (Nn(!0), Zs(r, o, function Qp() { return R.lFrame.currentNamespace }())); function Di(e) { return !!e && "function" == typeof e.then } function jv(e) { return !!e && "function" == typeof e.subscribe } function Ve(e, t, n, r) { const o = y(), i = W(), s = xe(); return function Hv(e, t, n, r, o, i, s) { const a = Es(r), c = e.firstCreatePass && function iv(e) { return e.cleanup || (e.cleanup = []) }(e), l = t[ve], d = function ov(e) { return e[_r] || (e[_r] = []) }(t); let f = !0; if (3 & r.type || s) { const g = et(r, t), v = s ? s(g) : g, _ = d.length, m = s ? N => s(se(N[r.index])) : r.index; let E = null; if (!s && a && (E = function zT(e, t, n, r) { const o = e.cleanup; if (null != o) for (let i = 0; i < o.length - 1; i += 2) { const s = o[i]; if (s === n && o[i + 1] === r) { const a = t[_r], u = o[i + 2]; return a.length > u ? a[u] : null } "string" == typeof s && (i += 2) } return null }(e, t, o, r.index)), null !== E) (E.__ngLastListenerFn__ || E).__ngNextListenerFn__ = i, E.__ngLastListenerFn__ = i, f = !1; else { i = Uv(r, t, l, i, !1); const N = n.listen(v, o, i); d.push(i, N), c && c.push(o, m, _, _ + 1) } } else i = Uv(r, t, l, i, !1); const h = r.outputs; let p; if (f && null !== h && (p = h[o])) { const g = p.length; if (g) for (let v = 0; v < g; v += 2) { const U = t[p[v]][p[v + 1]].subscribe(i), Ae = d.length; d.push(i, U), c && c.push(o, r.index, Ae, -(Ae + 1)) } } }(i, o, o[V], s, e, t, r), Ve } function $v(e, t, n, r) { try { return Gt(6, t, n), !1 !== n(r) } catch (o) { return av(e, o), !1 } finally { Gt(7, t, n) } } function Uv(e, t, n, r, o) { return function i(s) { if (s === Function) return r; fi(e.componentOffset > -1 ? ct(e.index, t) : t); let u = $v(t, n, r, s), c = i.__ngNextListenerFn__; for (; c;)u = $v(t, n, c, s) && u, c = c.__ngNextListenerFn__; return o && !1 === u && s.preventDefault(), u } } function zv(e = 1) { return function MI(e) { return (R.lFrame.contextLView = function II(e, t) { for (; e > 0;)t = t[Dr], e--; return t }(e, R.lFrame.contextLView))[ve] }(e) } function Ea(e, t) { return e << 17 | t << 2 } function Fn(e) { return e >> 17 & 32767 } function Kl(e) { return 2 | e } function rr(e) { return (131068 & e) >> 2 } function ed(e, t) { return -131069 & e | t << 2 } function td(e) { return 1 | e } function ey(e, t, n, r, o) { const i = e[n + 1], s = null === t; let a = r ? Fn(i) : rr(i), u = !1; for (; 0 !== a && (!1 === u || s);) { const l = e[a + 1]; KT(e[a], t) && (u = !0, e[a + 1] = r ? td(l) : Kl(l)), a = r ? Fn(l) : rr(l) } u && (e[n + 1] = r ? Kl(i) : td(i)) } function KT(e, t) { return null === e || null == t || (Array.isArray(e) ? e[1] : e) === t || !(!Array.isArray(e) || "string" != typeof t) && Fr(e, t) >= 0 } function Ma(e, t) { return function Rt(e, t, n, r) { const o = y(), i = W(), s = function ln(e) { const t = R.lFrame, n = t.bindingIndex; return t.bindingIndex = t.bindingIndex + e, n }(2); i.firstUpdatePass && function cy(e, t, n, r) { const o = e.data; if (null === o[n + 1]) { const i = o[ze()], s = function uy(e, t) { return t >= e.expandoStartIndex }(e, n); (function hy(e, t) { return 0 != (e.flags & (t ? 8 : 16)) })(i, r) && null === t && !s && (t = !1), t = function uO(e, t, n, r) { const o = function Ec(e) { const t = R.lFrame.currentDirectiveIndex; return -1 === t ? null : e[t] }(e); let i = r ? t.residualClasses : t.residualStyles; if (null === o) 0 === (r ? t.classBindings : t.styleBindings) && (n = wi(n = nd(null, e, t, n, r), t.attrs, r), i = null); else { const s = t.directiveStylingLast; if (-1 === s || e[s] !== o) if (n = nd(o, e, t, n, r), null === i) { let u = function cO(e, t, n) { const r = n ? t.classBindings : t.styleBindings; if (0 !== rr(r)) return e[Fn(r)] }(e, t, r); void 0 !== u && Array.isArray(u) && (u = nd(null, e, t, u[1], r), u = wi(u, t.attrs, r), function lO(e, t, n, r) { e[Fn(n ? t.classBindings : t.styleBindings)] = r }(e, t, r, u)) } else i = function dO(e, t, n) { let r; const o = t.directiveEnd; for (let i = 1 + t.directiveStylingLast; i < o; i++)r = wi(r, e[i].hostAttrs, n); return wi(r, t.attrs, n) }(e, t, r) } return void 0 !== i && (r ? t.residualClasses = i : t.residualStyles = i), n }(o, i, t, r), function XT(e, t, n, r, o, i) { let s = i ? t.classBindings : t.styleBindings, a = Fn(s), u = rr(s); e[r] = n; let l, c = !1; if (Array.isArray(n) ? (l = n[1], (null === l || Fr(n, l) > 0) && (c = !0)) : l = n, o) if (0 !== u) { const f = Fn(e[a + 1]); e[r + 1] = Ea(f, a), 0 !== f && (e[f + 1] = ed(e[f + 1], r)), e[a + 1] = function YT(e, t) { return 131071 & e | t << 17 }(e[a + 1], r) } else e[r + 1] = Ea(a, 0), 0 !== a && (e[a + 1] = ed(e[a + 1], r)), a = r; else e[r + 1] = Ea(u, 0), 0 === a ? a = r : e[u + 1] = ed(e[u + 1], r), u = r; c && (e[r + 1] = Kl(e[r + 1])), ey(e, l, r, !0), ey(e, l, r, !1), function JT(e, t, n, r, o) { const i = o ? e.residualClasses : e.residualStyles; null != i && "string" == typeof t && Fr(i, t) >= 0 && (n[r + 1] = td(n[r + 1])) }(t, l, e, r, i), s = Ea(a, u), i ? t.classBindings = s : t.styleBindings = s }(o, i, t, n, s, r) } }(i, e, s, r), t !== j && Le(o, s, t) && function dy(e, t, n, r, o, i, s, a) { if (!(3 & t.type)) return; const u = e.data, c = u[a + 1], l = function QT(e) { return 1 == (1 & e) }(c) ? fy(u, t, n, o, rr(c), s) : void 0; Ia(l) || (Ia(i) || function ZT(e) { return 2 == (2 & e) }(c) && (i = fy(u, null, n, o, a, s)), function qS(e, t, n, r, o) { if (t) o ? e.addClass(n, r) : e.removeClass(n, r); else { let i = -1 === r.indexOf("-") ? void 0 : Pn.DashCase; null == o ? e.removeStyle(n, r, i) : ("string" == typeof o && o.endsWith("!important") && (o = o.slice(0, -10), i |= Pn.Important), e.setStyle(n, r, o, i)) } }(r, s, Ss(ze(), n), o, i)) }(i, i.data[ze()], o, o[V], e, o[s + 1] = function gO(e, t) { return null == e || "" === e || ("string" == typeof t ? e += t : "object" == typeof e && (e = Ee(function xn(e) { return e instanceof Jg ? e.changingThisBreaksApplicationSecurity : e }(e)))), e }(t, n), r, s) }(e, t, null, !0), Ma } function nd(e, t, n, r, o) { let i = null; const s = n.directiveEnd; let a = n.directiveStylingLast; for (-1 === a ? a = n.directiveStart : a++; a < s && (i = t[a], r = wi(r, i.hostAttrs, o), i !== e);)a++; return null !== e && (n.directiveStylingLast = a), r } function wi(e, t, n) { const r = n ? 1 : 2; let o = -1; if (null !== t) for (let i = 0; i < t.length; i++) { const s = t[i]; "number" == typeof s ? o = s : o === r && (Array.isArray(e) || (e = void 0 === e ? [] : ["", e]), lt(e, s, !!n || t[++i])) } return void 0 === e ? null : e } function fy(e, t, n, r, o, i) { const s = null === t; let a; for (; o > 0;) { const u = e[o], c = Array.isArray(u), l = c ? u[1] : u, d = null === l; let f = n[o + 1]; f === j && (f = d ? Z : void 0); let h = d ? kc(f, r) : l === r ? f : void 0; if (c && !Ia(h) && (h = kc(u, r)), Ia(h) && (a = h, s)) return a; const p = e[o + 1]; o = s ? Fn(p) : rr(p) } if (null !== t) { let u = i ? t.residualClasses : t.residualStyles; null != u && (a = kc(u, r)) } return a } function Ia(e) { return void 0 !== e } function O(e, t = "") { const n = y(), r = W(), o = e + G, i = r.firstCreatePass ? Yr(r, o, 1, t, null) : r.data[o], s = py(r, n, i, t, e); n[o] = s, As() && Xs(r, n, s, i), qt(i, !1) } let py = (e, t, n, r, o) => (Nn(!0), function Ws(e, t) { return e.createText(t) }(t[V], r)); function so(e) { return rd("", e, ""), so } function rd(e, t, n) { const r = y(), o = function Xr(e, t, n, r) { return Le(e, Sr(), n) ? t + L(n) + r : j }(r, e, t, n); return o !== j && function gn(e, t, n) { const r = Ss(t, e); !function Fg(e, t, n) { e.setValue(t, n) }(e[V], r, n) }(r, ze(), o), rd } const uo = "en-US"; let ky = uo; function sd(e, t, n, r, o) { if (e = F(e), Array.isArray(e)) for (let i = 0; i < e.length; i++)sd(e[i], t, n, r, o); else { const i = W(), s = y(), a = xe(); let u = er(e) ? e : F(e.provide); const c = pm(e), l = 1048575 & a.providerIndexes, d = a.directiveStart, f = a.providerIndexes >> 20; if (er(e) || !e.multi) { const h = new Zo(c, o, D), p = ud(u, t, o ? l : l + f, d); -1 === p ? (xc(xs(a, s), i, u), ad(i, e, t.length), t.push(u), a.directiveStart++, a.directiveEnd++, o && (a.providerIndexes += 1048576), n.push(h), s.push(h)) : (n[p] = h, s[p] = h) } else { const h = ud(u, t, l + f, d), p = ud(u, t, l, l + f), v = p >= 0 && n[p]; if (o && !v || !o && !(h >= 0 && n[h])) { xc(xs(a, s), i, u); const _ = function kN(e, t, n, r, o) { const i = new Zo(e, n, D); return i.multi = [], i.index = t, i.componentProviders = 0, a_(i, o, r && !n), i }(o ? FN : RN, n.length, o, r, c); !o && v && (n[p].providerFactory = _), ad(i, e, t.length, 0), t.push(u), a.directiveStart++, a.directiveEnd++, o && (a.providerIndexes += 1048576), n.push(_), s.push(_) } else ad(i, e, h > -1 ? h : p, a_(n[o ? p : h], c, !o && r)); !o && r && v && n[p].componentProviders++ } } } function ad(e, t, n, r) { const o = er(t), i = function b0(e) { return !!e.useClass }(t); if (o || i) { const u = (i ? F(t.useClass) : t).prototype.ngOnDestroy; if (u) { const c = e.destroyHooks || (e.destroyHooks = []); if (!o && t.multi) { const l = c.indexOf(n); -1 === l ? c.push(n, [r, u]) : c[l + 1].push(r, u) } else c.push(n, u) } } } function a_(e, t, n) { return n && e.componentProviders++, e.multi.push(t) - 1 } function ud(e, t, n, r) { for (let o = n; o < r; o++)if (t[o] === e) return o; return -1 } function RN(e, t, n, r) { return cd(this.multi, []) } function FN(e, t, n, r) { const o = this.multi; let i; if (this.providerFactory) { const s = this.providerFactory.componentProviders, a = Jn(n, n[w], this.providerFactory.index, r); i = a.slice(0, s), cd(o, i); for (let u = s; u < a.length; u++)i.push(a[u]) } else i = [], cd(o, i); return i } function cd(e, t) { for (let n = 0; n < e.length; n++)t.push((0, e[n])()); return t } function de(e, t = []) { return n => { n.providersResolver = (r, o) => function xN(e, t, n) { const r = W(); if (r.firstCreatePass) { const o = xt(e); sd(n, r.data, r.blueprint, o, !0), sd(t, r.data, r.blueprint, o, !1) } }(r, o ? o(e) : e, t) } } class ir { } class u_ { } class ld extends ir { constructor(t, n, r) { super(), this._parent = n, this._bootstrapComponents = [], this.destroyCbs = [], this.componentFactoryResolver = new pv(this); const o = ut(t); this._bootstrapComponents = pn(o.bootstrap), this._r3Injector = Sm(t, n, [{ provide: ir, useValue: this }, { provide: da, useValue: this.componentFactoryResolver }, ...r], Ee(t), new Set(["environment"])), this._r3Injector.resolveInjectorInitializers(), this.instance = this._r3Injector.get(t) } get injector() { return this._r3Injector } destroy() { const t = this._r3Injector; !t.destroyed && t.destroy(), this.destroyCbs.forEach(n => n()), this.destroyCbs = null } onDestroy(t) { this.destroyCbs.push(t) } } class dd extends u_ { constructor(t) { super(), this.moduleType = t } create(t) { return new ld(this.moduleType, t, []) } } class c_ extends ir { constructor(t) { super(), this.componentFactoryResolver = new pv(this), this.instance = null; const n = new $r([...t.providers, { provide: ir, useValue: this }, { provide: da, useValue: this.componentFactoryResolver }], t.parent || oa(), t.debugName, new Set(["environment"])); this.injector = n, t.runEnvironmentInitializers && n.resolveInjectorInitializers() } destroy() { this.injector.destroy() } onDestroy(t) { this.injector.onDestroy(t) } } function fd(e, t, n = null) { return new c_({ providers: e, parent: t, debugName: n, runEnvironmentInitializers: !0 }).injector } let jN = (() => { class e { constructor(n) { this._injector = n, this.cachedInjectors = new Map } getOrCreateStandaloneInjector(n) { if (!n.standalone) return null; if (!this.cachedInjectors.has(n)) { const r = lm(0, n.type), o = r.length > 0 ? fd([r], this._injector, `Standalone[${n.type.name}]`) : null; this.cachedInjectors.set(n, o) } return this.cachedInjectors.get(n) } ngOnDestroy() { try { for (const n of this.cachedInjectors.values()) null !== n && n.destroy() } finally { this.cachedInjectors.clear() } } static #e = this.\u0275prov = T({ token: e, providedIn: "environment", factory: () => new e(A(dt)) }) } return e })(); function l_(e) { e.getStandaloneInjector = t => t.get(jN).getOrCreateStandaloneInjector(e) } function hP(e, t, n, r = !0) { const o = t[w]; if (function VS(e, t, n, r) { const o = Ne + r, i = n.length; r > 0 && (n[o - 1][Pt] = t), r < i - Ne ? (t[Pt] = n[o], dg(n, Ne + r, t)) : (n.push(t), t[Pt] = null), t[le] = n; const s = t[Ho]; null !== s && n !== s && function jS(e, t) { const n = e[br]; t[ye] !== t[le][le][ye] && (e[cp] = !0), null === n ? e[br] = [t] : n.push(t) }(s, t); const a = t[Ut]; null !== a && a.insertView(e), t[B] |= 128 }(o, t, e, n), r) { const i = Xc(n, e), s = t[V], a = Qs(s, e[zt]); null !== a && function FS(e, t, n, r, o, i) { r[he] = o, r[Fe] = t, oi(e, r, n, 1, o, i) }(o, e[Fe], s, t, a, i) } } Symbol; let mn = (() => { class e { static #e = this.__NG_ELEMENT_ID__ = mP } return e })(); const pP = mn, gP = class extends pP { constructor(t, n, r) { super(), this._declarationLView = t, this._declarationTContainer = n, this.elementRef = r } get ssrId() { return this._declarationTContainer.tView?.ssrId || null } createEmbeddedView(t, n) { return this.createEmbeddedViewImpl(t, n) } createEmbeddedViewImpl(t, n, r) { const o = function fP(e, t, n, r) { const o = t.tView, a = pa(e, o, n, 4096 & e[B] ? 4096 : 16, null, t, null, null, null, r?.injector ?? null, r?.hydrationInfo ?? null); a[Ho] = e[t.index]; const c = e[Ut]; return null !== c && (a[Ut] = c.createEmbeddedView(o)), $l(o, a, n), a }(this._declarationLView, this._declarationTContainer, t, { injector: n, hydrationInfo: r }); return new gi(o) } }; function mP() { return function Na(e, t) { return 4 & e.type ? new gP(t, e, qr(e, t)) : null }(xe(), y()) } let kt = (() => { class e { static #e = this.__NG_ELEMENT_ID__ = wP } return e })(); function wP() { return function A_(e, t) { let n; const r = t[e.index]; return $e(r) ? n = r : (n = nv(r, t, null, e), t[e.index] = n, ga(t, n)), T_(n, t, e, r), new I_(n, e, t) }(xe(), y()) } const bP = kt, I_ = class extends bP { constructor(t, n, r) { super(), this._lContainer = t, this._hostTNode = n, this._hostLView = r } get element() { return qr(this._hostTNode, this._hostLView) } get injector() { return new Ge(this._hostTNode, this._hostLView) } get parentInjector() { const t = Rs(this._hostTNode, this._hostLView); if (Oc(t)) { const n = Qo(t, this._hostLView), r = Yo(t); return new Ge(n[w].data[r + 8], n) } return new Ge(null, this._hostLView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(t) { const n = S_(this._lContainer); return null !== n && n[t] || null } get length() { return this._lContainer.length - Ne } createEmbeddedView(t, n, r) { let o, i; "number" == typeof r ? o = r : null != r && (o = r.index, i = r.injector); const a = t.createEmbeddedViewImpl(n || {}, i, null); return this.insertImpl(a, o, false), a } createComponent(t, n, r, o, i) { const s = t && !function Jo(e) { return "function" == typeof e }(t); let a; if (s) a = n; else { const g = n || {}; a = g.index, r = g.injector, o = g.projectableNodes, i = g.environmentInjector || g.ngModuleRef } const u = s ? t : new mi(q(t)), c = r || this.parentInjector; if (!i && null == u.ngModule) { const v = (s ? c : this.parentInjector).get(dt, null); v && (i = v) } q(u.componentType ?? {}); const h = u.create(c, o, null, i); return this.insertImpl(h.hostView, a, false), h } insert(t, n) { return this.insertImpl(t, n, !1) } insertImpl(t, n, r) { const o = t._lView; if (function cI(e) { return $e(e[le]) }(o)) { const u = this.indexOf(t); if (-1 !== u) this.detach(u); else { const c = o[le], l = new I_(c, c[Fe], c[le]); l.detach(l.indexOf(t)) } } const s = this._adjustIndex(n), a = this._lContainer; return hP(a, o, s, !r), t.attachToViewContainerRef(), dg(gd(a), s, t), t } move(t, n) { return this.insert(t, n) } indexOf(t) { const n = S_(this._lContainer); return null !== n ? n.indexOf(t) : -1 } remove(t) { const n = this._adjustIndex(t, -1), r = Ys(this._lContainer, n); r && (Ls(gd(this._lContainer), n), Wc(r[w], r)) } detach(t) { const n = this._adjustIndex(t, -1), r = Ys(this._lContainer, n); return r && null != Ls(gd(this._lContainer), n) ? new gi(r) : null } _adjustIndex(t, n = 0) { return t ?? this.length + n } }; function S_(e) { return e[8] } function gd(e) { return e[8] || (e[8] = []) } let T_ = function O_(e, t, n, r) { if (e[zt]) return; let o; o = 8 & n.type ? se(r) : function EP(e, t) { const n = e[V], r = n.createComment(""), o = et(t, e); return Kn(n, Qs(n, o), r, function US(e, t) { return e.nextSibling(t) }(n, o), !1), r }(t, n), e[zt] = o }; const Id = new M("Application Initializer"); let Sd = (() => { class e { constructor() { this.initialized = !1, this.done = !1, this.donePromise = new Promise((n, r) => { this.resolve = n, this.reject = r }), this.appInits = b(Id, { optional: !0 }) ?? [] } runInitializers() { if (this.initialized) return; const n = []; for (const o of this.appInits) { const i = o(); if (Di(i)) n.push(i); else if (jv(i)) { const s = new Promise((a, u) => { i.subscribe({ complete: a, error: u }) }); n.push(s) } } const r = () => { this.done = !0, this.resolve() }; Promise.all(n).then(() => { r() }).catch(o => { this.reject(o) }), 0 === n.length && r(), this.initialized = !0 } static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275prov = T({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(), tC = (() => { class e { log(n) { console.log(n) } warn(n) { console.warn(n) } static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275prov = T({ token: e, factory: e.\u0275fac, providedIn: "platform" }) } return e })(); const vn = new M("LocaleId", { providedIn: "root", factory: () => b(vn, z.Optional | z.SkipSelf) || function tx() { return typeof $localize < "u" && $localize.locale || uo }() }); let Ra = (() => { class e { constructor() { this.taskId = 0, this.pendingTasks = new Set, this.hasPendingTasks = new vt(!1) } add() { this.hasPendingTasks.next(!0); const n = this.taskId++; return this.pendingTasks.add(n), n } remove(n) { this.pendingTasks.delete(n), 0 === this.pendingTasks.size && this.hasPendingTasks.next(!1) } ngOnDestroy() { this.pendingTasks.clear(), this.hasPendingTasks.next(!1) } static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275prov = T({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); class ox { constructor(t, n) { this.ngModuleFactory = t, this.componentFactories = n } } let nC = (() => { class e { compileModuleSync(n) { return new dd(n) } compileModuleAsync(n) { return Promise.resolve(this.compileModuleSync(n)) } compileModuleAndAllComponentsSync(n) { const r = this.compileModuleSync(n), i = pn(ut(n).declarations).reduce((s, a) => { const u = q(a); return u && s.push(new mi(u)), s }, []); return new ox(r, i) } compileModuleAndAllComponentsAsync(n) { return Promise.resolve(this.compileModuleAndAllComponentsSync(n)) } clearCache() { } clearCacheFor(n) { } getModuleId(n) { } static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275prov = T({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); const sC = new M(""), ka = new M(""); let Pd, Od = (() => { class e { constructor(n, r, o) { this._ngZone = n, this.registry = r, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, Pd || (function Ix(e) { Pd = e }(o), o.addToWindow(r)), this._watchAngularEvents(), n.run(() => { this.taskTrackingZone = typeof Zone > "u" ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { ae.assertNotInAngularZone(), queueMicrotask(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) queueMicrotask(() => { for (; 0 !== this._callbacks.length;) { let n = this._callbacks.pop(); clearTimeout(n.timeoutId), n.doneCb(this._didWork) } this._didWork = !1 }); else { let n = this.getPendingTasks(); this._callbacks = this._callbacks.filter(r => !r.updateCb || !r.updateCb(n) || (clearTimeout(r.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(n => ({ source: n.source, creationLocation: n.creationLocation, data: n.data })) : [] } addCallback(n, r, o) { let i = -1; r && r > 0 && (i = setTimeout(() => { this._callbacks = this._callbacks.filter(s => s.timeoutId !== i), n(this._didWork, this.getPendingTasks()) }, r)), this._callbacks.push({ doneCb: n, timeoutId: i, updateCb: o }) } whenStable(n, r, o) { if (o && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?'); this.addCallback(n, r, o), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } registerApplication(n) { this.registry.registerApplication(n, this) } unregisterApplication(n) { this.registry.unregisterApplication(n) } findProviders(n, r, o) { return [] } static #e = this.\u0275fac = function (r) { return new (r || e)(A(ae), A(Nd), A(ka)) }; static #t = this.\u0275prov = T({ token: e, factory: e.\u0275fac }) } return e })(), Nd = (() => { class e { constructor() { this._applications = new Map } registerApplication(n, r) { this._applications.set(n, r) } unregisterApplication(n) { this._applications.delete(n) } unregisterAllApplications() { this._applications.clear() } getTestability(n) { return this._applications.get(n) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(n, r = !0) { return Pd?.findTestabilityInTree(this, n, r) ?? null } static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275prov = T({ token: e, factory: e.\u0275fac, providedIn: "platform" }) } return e })(), kn = null; const aC = new M("AllowMultipleToken"), xd = new M("PlatformDestroyListeners"), Rd = new M("appBootstrapListener"); class cC { constructor(t, n) { this.name = t, this.token = n } } function dC(e, t, n = []) { const r = `Platform: ${t}`, o = new M(r); return (i = []) => { let s = Fd(); if (!s || s.injector.get(aC, !1)) { const a = [...n, ...i, { provide: o, useValue: !0 }]; e ? e(a) : function Tx(e) { if (kn && !kn.get(aC, !1)) throw new C(400, !1); (function uC() { !function ZM(e) { Dp = e }(() => { throw new C(600, !1) }) })(), kn = e; const t = e.get(hC); (function lC(e) { e.get(gm, null)?.forEach(n => n()) })(e) }(function fC(e = [], t) { return ht.create({ name: t, providers: [{ provide: ll, useValue: "platform" }, { provide: xd, useValue: new Set([() => kn = null]) }, ...e] }) }(a, r)) } return function Nx(e) { const t = Fd(); if (!t) throw new C(401, !1); return t }() } } function Fd() { return kn?.get(hC) ?? null } let hC = (() => { class e { constructor(n) { this._injector = n, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(n, r) { const o = function Px(e = "zone.js", t) { return "noop" === e ? new iA : "zone.js" === e ? new ae(t) : e }(r?.ngZone, function pC(e) { return { enableLongStackTrace: !1, shouldCoalesceEventChangeDetection: e?.eventCoalescing ?? !1, shouldCoalesceRunChangeDetection: e?.runCoalescing ?? !1 } }({ eventCoalescing: r?.ngZoneEventCoalescing, runCoalescing: r?.ngZoneRunCoalescing })); return o.run(() => { const i = function VN(e, t, n) { return new ld(e, t, n) }(n.moduleType, this.injector, function _C(e) { return [{ provide: ae, useFactory: e }, { provide: ui, multi: !0, useFactory: () => { const t = b(Rx, { optional: !0 }); return () => t.initialize() } }, { provide: yC, useFactory: xx }, { provide: Pm, useFactory: xm }] }(() => o)), s = i.injector.get(hn, null); return o.runOutsideAngular(() => { const a = o.onError.subscribe({ next: u => { s.handleError(u) } }); i.onDestroy(() => { La(this._modules, i), a.unsubscribe() }) }), function gC(e, t, n) { try { const r = n(); return Di(r) ? r.catch(o => { throw t.runOutsideAngular(() => e.handleError(o)), o }) : r } catch (r) { throw t.runOutsideAngular(() => e.handleError(r)), r } }(s, o, () => { const a = i.injector.get(Sd); return a.runInitializers(), a.donePromise.then(() => (function Ly(e) { yt(e, "Expected localeId to be defined"), "string" == typeof e && (ky = e.toLowerCase().replace(/_/g, "-")) }(i.injector.get(vn, uo) || uo), this._moduleDoBootstrap(i), i)) }) }) } bootstrapModule(n, r = []) { const o = mC({}, r); return function Sx(e, t, n) { const r = new dd(n); return Promise.resolve(r) }(0, 0, n).then(i => this.bootstrapModuleFactory(i, o)) } _moduleDoBootstrap(n) { const r = n.injector.get(fo); if (n._bootstrapComponents.length > 0) n._bootstrapComponents.forEach(o => r.bootstrap(o)); else { if (!n.instance.ngDoBootstrap) throw new C(-403, !1); n.instance.ngDoBootstrap(r) } this._modules.push(n) } onDestroy(n) { this._destroyListeners.push(n) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new C(404, !1); this._modules.slice().forEach(r => r.destroy()), this._destroyListeners.forEach(r => r()); const n = this._injector.get(xd, null); n && (n.forEach(r => r()), n.clear()), this._destroyed = !0 } get destroyed() { return this._destroyed } static #e = this.\u0275fac = function (r) { return new (r || e)(A(ht)) }; static #t = this.\u0275prov = T({ token: e, factory: e.\u0275fac, providedIn: "platform" }) } return e })(); function mC(e, t) { return Array.isArray(t) ? t.reduce(mC, e) : { ...e, ...t } } let fo = (() => { class e { constructor() { this._bootstrapListeners = [], this._runningTick = !1, this._destroyed = !1, this._destroyListeners = [], this._views = [], this.internalErrorHandler = b(yC), this.zoneIsStable = b(Pm), this.componentTypes = [], this.components = [], this.isStable = b(Ra).hasPendingTasks.pipe(Tt(n => n ? P(!1) : this.zoneIsStable), function iM(e, t = En) { return e = e ?? sM, we((n, r) => { let o, i = !0; n.subscribe(Ce(r, s => { const a = t(s); (i || !e(o, a)) && (i = !1, o = a, r.next(s)) })) }) }(), jh()), this._injector = b(dt) } get destroyed() { return this._destroyed } get injector() { return this._injector } bootstrap(n, r) { const o = n instanceof Cm; if (!this._injector.get(Sd).done) throw !o && function yr(e) { const t = q(e) || Oe(e) || He(e); return null !== t && t.standalone }(n), new C(405, !1); let s; s = o ? n : this._injector.get(da).resolveComponentFactory(n), this.componentTypes.push(s.componentType); const a = function Ax(e) { return e.isBoundToModule }(s) ? void 0 : this._injector.get(ir), c = s.create(ht.NULL, [], r || s.selector, a), l = c.location.nativeElement, d = c.injector.get(sC, null); return d?.registerApplication(l), c.onDestroy(() => { this.detachView(c.hostView), La(this.components, c), d?.unregisterApplication(l) }), this._loadComponent(c), c } tick() { if (this._runningTick) throw new C(101, !1); try { this._runningTick = !0; for (let n of this._views) n.detectChanges() } catch (n) { this.internalErrorHandler(n) } finally { this._runningTick = !1 } } attachView(n) { const r = n; this._views.push(r), r.attachToAppRef(this) } detachView(n) { const r = n; La(this._views, r), r.detachFromAppRef() } _loadComponent(n) { this.attachView(n.hostView), this.tick(), this.components.push(n); const r = this._injector.get(Rd, []); r.push(...this._bootstrapListeners), r.forEach(o => o(n)) } ngOnDestroy() { if (!this._destroyed) try { this._destroyListeners.forEach(n => n()), this._views.slice().forEach(n => n.destroy()) } finally { this._destroyed = !0, this._views = [], this._bootstrapListeners = [], this._destroyListeners = [] } } onDestroy(n) { return this._destroyListeners.push(n), () => La(this._destroyListeners, n) } destroy() { if (this._destroyed) throw new C(406, !1); const n = this._injector; n.destroy && !n.destroyed && n.destroy() } get viewCount() { return this._views.length } warnIfDestroyed() { } static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275prov = T({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); function La(e, t) { const n = e.indexOf(t); n > -1 && e.splice(n, 1) } const yC = new M("", { providedIn: "root", factory: () => b(hn).handleError.bind(void 0) }); function xx() { const e = b(ae), t = b(hn); return n => e.runOutsideAngular(() => t.handleError(n)) } let Rx = (() => { class e { constructor() { this.zone = b(ae), this.applicationRef = b(fo) } initialize() { this._onMicrotaskEmptySubscription || (this._onMicrotaskEmptySubscription = this.zone.onMicrotaskEmpty.subscribe({ next: () => { this.zone.run(() => { this.applicationRef.tick() }) } })) } ngOnDestroy() { this._onMicrotaskEmptySubscription?.unsubscribe() } static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275prov = T({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); let Va = (() => { class e { static #e = this.__NG_ELEMENT_ID__ = kx } return e })(); function kx(e) { return function Lx(e, t, n) { if (Yn(e) && !n) { const r = ct(e.index, t); return new gi(r, r) } return 47 & e.type ? new gi(t[ye], t) : null }(xe(), y(), 16 == (16 & e)) } class bC { constructor() { } supports(t) { return _a(t) } create(t) { return new Ux(t) } } const $x = (e, t) => t; class Ux { constructor(t) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = t || $x } forEachItem(t) { let n; for (n = this._itHead; null !== n; n = n._next)t(n) } forEachOperation(t) { let n = this._itHead, r = this._removalsHead, o = 0, i = null; for (; n || r;) { const s = !r || n && n.currentIndex < MC(r, o, i) ? n : r, a = MC(s, o, i), u = s.currentIndex; if (s === r) o--, r = r._nextRemoved; else if (n = n._next, null == s.previousIndex) o++; else { i || (i = []); const c = a - o, l = u - o; if (c != l) { for (let f = 0; f < c; f++) { const h = f < i.length ? i[f] : i[f] = 0, p = h + f; l <= p && p < c && (i[f] = h + 1) } i[s.previousIndex] = l - c } } a !== u && t(s, a, u) } } forEachPreviousItem(t) { let n; for (n = this._previousItHead; null !== n; n = n._nextPrevious)t(n) } forEachAddedItem(t) { let n; for (n = this._additionsHead; null !== n; n = n._nextAdded)t(n) } forEachMovedItem(t) { let n; for (n = this._movesHead; null !== n; n = n._nextMoved)t(n) } forEachRemovedItem(t) { let n; for (n = this._removalsHead; null !== n; n = n._nextRemoved)t(n) } forEachIdentityChange(t) { let n; for (n = this._identityChangesHead; null !== n; n = n._nextIdentityChange)t(n) } diff(t) { if (null == t && (t = []), !_a(t)) throw new C(900, !1); return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let o, i, s, n = this._itHead, r = !1; if (Array.isArray(t)) { this.length = t.length; for (let a = 0; a < this.length; a++)i = t[a], s = this._trackByFn(a, i), null !== n && Object.is(n.trackById, s) ? (r && (n = this._verifyReinsertion(n, i, s, a)), Object.is(n.item, i) || this._addIdentityChange(n, i)) : (n = this._mismatch(n, i, s, a), r = !0), n = n._next } else o = 0, function gT(e, t) { if (Array.isArray(e)) for (let n = 0; n < e.length; n++)t(e[n]); else { const n = e[Symbol.iterator](); let r; for (; !(r = n.next()).done;)t(r.value) } }(t, a => { s = this._trackByFn(o, a), null !== n && Object.is(n.trackById, s) ? (r && (n = this._verifyReinsertion(n, a, s, o)), Object.is(n.item, a) || this._addIdentityChange(n, a)) : (n = this._mismatch(n, a, s, o), r = !0), n = n._next, o++ }), this.length = o; return this._truncate(n), this.collection = t, this.isDirty } get isDirty() { return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead } _reset() { if (this.isDirty) { let t; for (t = this._previousItHead = this._itHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._additionsHead; null !== t; t = t._nextAdded)t.previousIndex = t.currentIndex; for (this._additionsHead = this._additionsTail = null, t = this._movesHead; null !== t; t = t._nextMoved)t.previousIndex = t.currentIndex; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(t, n, r, o) { let i; return null === t ? i = this._itTail : (i = t._prev, this._remove(t)), null !== (t = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(r, null)) ? (Object.is(t.item, n) || this._addIdentityChange(t, n), this._reinsertAfter(t, i, o)) : null !== (t = null === this._linkedRecords ? null : this._linkedRecords.get(r, o)) ? (Object.is(t.item, n) || this._addIdentityChange(t, n), this._moveAfter(t, i, o)) : t = this._addAfter(new zx(n, r), i, o), t } _verifyReinsertion(t, n, r, o) { let i = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(r, null); return null !== i ? t = this._reinsertAfter(i, t._prev, o) : t.currentIndex != o && (t.currentIndex = o, this._addToMoves(t, o)), t } _truncate(t) { for (; null !== t;) { const n = t._next; this._addToRemovals(this._unlink(t)), t = n } null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(t, n, r) { null !== this._unlinkedRecords && this._unlinkedRecords.remove(t); const o = t._prevRemoved, i = t._nextRemoved; return null === o ? this._removalsHead = i : o._nextRemoved = i, null === i ? this._removalsTail = o : i._prevRemoved = o, this._insertAfter(t, n, r), this._addToMoves(t, r), t } _moveAfter(t, n, r) { return this._unlink(t), this._insertAfter(t, n, r), this._addToMoves(t, r), t } _addAfter(t, n, r) { return this._insertAfter(t, n, r), this._additionsTail = null === this._additionsTail ? this._additionsHead = t : this._additionsTail._nextAdded = t, t } _insertAfter(t, n, r) { const o = null === n ? this._itHead : n._next; return t._next = o, t._prev = n, null === o ? this._itTail = t : o._prev = t, null === n ? this._itHead = t : n._next = t, null === this._linkedRecords && (this._linkedRecords = new EC), this._linkedRecords.put(t), t.currentIndex = r, t } _remove(t) { return this._addToRemovals(this._unlink(t)) } _unlink(t) { null !== this._linkedRecords && this._linkedRecords.remove(t); const n = t._prev, r = t._next; return null === n ? this._itHead = r : n._next = r, null === r ? this._itTail = n : r._prev = n, t } _addToMoves(t, n) { return t.previousIndex === n || (this._movesTail = null === this._movesTail ? this._movesHead = t : this._movesTail._nextMoved = t), t } _addToRemovals(t) { return null === this._unlinkedRecords && (this._unlinkedRecords = new EC), this._unlinkedRecords.put(t), t.currentIndex = null, t._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = t, t._prevRemoved = null) : (t._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = t), t } _addIdentityChange(t, n) { return t.item = n, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = t : this._identityChangesTail._nextIdentityChange = t, t } } class zx { constructor(t, n) { this.item = t, this.trackById = n, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } } class Gx { constructor() { this._head = null, this._tail = null } add(t) { null === this._head ? (this._head = this._tail = t, t._nextDup = null, t._prevDup = null) : (this._tail._nextDup = t, t._prevDup = this._tail, t._nextDup = null, this._tail = t) } get(t, n) { let r; for (r = this._head; null !== r; r = r._nextDup)if ((null === n || n <= r.currentIndex) && Object.is(r.trackById, t)) return r; return null } remove(t) { const n = t._prevDup, r = t._nextDup; return null === n ? this._head = r : n._nextDup = r, null === r ? this._tail = n : r._prevDup = n, null === this._head } } class EC { constructor() { this.map = new Map } put(t) { const n = t.trackById; let r = this.map.get(n); r || (r = new Gx, this.map.set(n, r)), r.add(t) } get(t, n) { const o = this.map.get(t); return o ? o.get(t, n) : null } remove(t) { const n = t.trackById; return this.map.get(n).remove(t) && this.map.delete(n), t } get isEmpty() { return 0 === this.map.size } clear() { this.map.clear() } } function MC(e, t, n) { const r = e.previousIndex; if (null === r) return r; let o = 0; return n && r < n.length && (o = n[r]), r + t + o } class IC { constructor() { } supports(t) { return t instanceof Map || Ul(t) } create() { return new qx } } class qx { constructor() { this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null } get isDirty() { return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead } forEachItem(t) { let n; for (n = this._mapHead; null !== n; n = n._next)t(n) } forEachPreviousItem(t) { let n; for (n = this._previousMapHead; null !== n; n = n._nextPrevious)t(n) } forEachChangedItem(t) { let n; for (n = this._changesHead; null !== n; n = n._nextChanged)t(n) } forEachAddedItem(t) { let n; for (n = this._additionsHead; null !== n; n = n._nextAdded)t(n) } forEachRemovedItem(t) { let n; for (n = this._removalsHead; null !== n; n = n._nextRemoved)t(n) } diff(t) { if (t) { if (!(t instanceof Map || Ul(t))) throw new C(900, !1) } else t = new Map; return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let n = this._mapHead; if (this._appendAfter = null, this._forEach(t, (r, o) => { if (n && n.key === o) this._maybeAddToChanges(n, r), this._appendAfter = n, n = n._next; else { const i = this._getOrCreateRecordForKey(o, r); n = this._insertBeforeOrAppend(n, i) } }), n) { n._prev && (n._prev._next = null), this._removalsHead = n; for (let r = n; null !== r; r = r._nextRemoved)r === this._mapHead && (this._mapHead = null), this._records.delete(r.key), r._nextRemoved = r._next, r.previousValue = r.currentValue, r.currentValue = null, r._prev = null, r._next = null } return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty } _insertBeforeOrAppend(t, n) { if (t) { const r = t._prev; return n._next = t, n._prev = r, t._prev = n, r && (r._next = n), t === this._mapHead && (this._mapHead = n), this._appendAfter = t, t } return this._appendAfter ? (this._appendAfter._next = n, n._prev = this._appendAfter) : this._mapHead = n, this._appendAfter = n, null } _getOrCreateRecordForKey(t, n) { if (this._records.has(t)) { const o = this._records.get(t); this._maybeAddToChanges(o, n); const i = o._prev, s = o._next; return i && (i._next = s), s && (s._prev = i), o._next = null, o._prev = null, o } const r = new Wx(t); return this._records.set(t, r), r.currentValue = n, this._addToAdditions(r), r } _reset() { if (this.isDirty) { let t; for (this._previousMapHead = this._mapHead, t = this._previousMapHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._changesHead; null !== t; t = t._nextChanged)t.previousValue = t.currentValue; for (t = this._additionsHead; null != t; t = t._nextAdded)t.previousValue = t.currentValue; this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null } } _maybeAddToChanges(t, n) { Object.is(n, t.currentValue) || (t.previousValue = t.currentValue, t.currentValue = n, this._addToChanges(t)) } _addToAdditions(t) { null === this._additionsHead ? this._additionsHead = this._additionsTail = t : (this._additionsTail._nextAdded = t, this._additionsTail = t) } _addToChanges(t) { null === this._changesHead ? this._changesHead = this._changesTail = t : (this._changesTail._nextChanged = t, this._changesTail = t) } _forEach(t, n) { t instanceof Map ? t.forEach(n) : Object.keys(t).forEach(r => n(t[r], r)) } } class Wx { constructor(t) { this.key = t, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null } } function SC() { return new Ha([new bC]) } let Ha = (() => { class e { static #e = this.\u0275prov = T({ token: e, providedIn: "root", factory: SC }); constructor(n) { this.factories = n } static create(n, r) { if (null != r) { const o = r.factories.slice(); n = n.concat(o) } return new e(n) } static extend(n) { return { provide: e, useFactory: r => e.create(n, r || SC()), deps: [[e, new Bs, new js]] } } find(n) { const r = this.factories.find(o => o.supports(n)); if (null != r) return r; throw new C(901, !1) } } return e })(); function AC() { return new Pi([new IC]) } let Pi = (() => { class e { static #e = this.\u0275prov = T({ token: e, providedIn: "root", factory: AC }); constructor(n) { this.factories = n } static create(n, r) { if (r) { const o = r.factories.slice(); n = n.concat(o) } return new e(n) } static extend(n) { return { provide: e, useFactory: r => e.create(n, r || AC()), deps: [[e, new Bs, new js]] } } find(n) { const r = this.factories.find(o => o.supports(n)); if (r) return r; throw new C(901, !1) } } return e })(); const Qx = dC(null, "core", []); let Xx = (() => { class e { constructor(n) { } static #e = this.\u0275fac = function (r) { return new (r || e)(A(fo)) }; static #t = this.\u0275mod = _t({ type: e }); static #n = this.\u0275inj = at({}) } return e })(); let Hd = null; function Ln() { return Hd } class dR { } const gt = new M("DocumentToken"); let $d = (() => { class e { historyGo(n) { throw new Error("Not implemented") } static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275prov = T({ token: e, factory: function () { return b(hR) }, providedIn: "platform" }) } return e })(); const fR = new M("Location Initialized"); let hR = (() => { class e extends $d { constructor() { super(), this._doc = b(gt), this._location = window.location, this._history = window.history } getBaseHrefFromDOM() { return Ln().getBaseHref(this._doc) } onPopState(n) { const r = Ln().getGlobalEventTarget(this._doc, "window"); return r.addEventListener("popstate", n, !1), () => r.removeEventListener("popstate", n) } onHashChange(n) { const r = Ln().getGlobalEventTarget(this._doc, "window"); return r.addEventListener("hashchange", n, !1), () => r.removeEventListener("hashchange", n) } get href() { return this._location.href } get protocol() { return this._location.protocol } get hostname() { return this._location.hostname } get port() { return this._location.port } get pathname() { return this._location.pathname } get search() { return this._location.search } get hash() { return this._location.hash } set pathname(n) { this._location.pathname = n } pushState(n, r, o) { this._history.pushState(n, r, o) } replaceState(n, r, o) { this._history.replaceState(n, r, o) } forward() { this._history.forward() } back() { this._history.back() } historyGo(n = 0) { this._history.go(n) } getState() { return this._history.state } static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275prov = T({ token: e, factory: function () { return new e }, providedIn: "platform" }) } return e })(); function Ud(e, t) { if (0 == e.length) return t; if (0 == t.length) return e; let n = 0; return e.endsWith("/") && n++, t.startsWith("/") && n++, 2 == n ? e + t.substring(1) : 1 == n ? e + t : e + "/" + t } function LC(e) { const t = e.match(/#|\?|$/), n = t && t.index || e.length; return e.slice(0, n - ("/" === e[n - 1] ? 1 : 0)) + e.slice(n) } function yn(e) { return e && "?" !== e[0] ? "?" + e : e } let ar = (() => { class e { historyGo(n) { throw new Error("Not implemented") } static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275prov = T({ token: e, factory: function () { return b(jC) }, providedIn: "root" }) } return e })(); const VC = new M("appBaseHref"); let jC = (() => { class e extends ar { constructor(n, r) { super(), this._platformLocation = n, this._removeListenerFns = [], this._baseHref = r ?? this._platformLocation.getBaseHrefFromDOM() ?? b(gt).location?.origin ?? "" } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(n) { this._removeListenerFns.push(this._platformLocation.onPopState(n), this._platformLocation.onHashChange(n)) } getBaseHref() { return this._baseHref } prepareExternalUrl(n) { return Ud(this._baseHref, n) } path(n = !1) { const r = this._platformLocation.pathname + yn(this._platformLocation.search), o = this._platformLocation.hash; return o && n ? `${r}${o}` : r } pushState(n, r, o, i) { const s = this.prepareExternalUrl(o + yn(i)); this._platformLocation.pushState(n, r, s) } replaceState(n, r, o, i) { const s = this.prepareExternalUrl(o + yn(i)); this._platformLocation.replaceState(n, r, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } getState() { return this._platformLocation.getState() } historyGo(n = 0) { this._platformLocation.historyGo?.(n) } static #e = this.\u0275fac = function (r) { return new (r || e)(A($d), A(VC, 8)) }; static #t = this.\u0275prov = T({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(), pR = (() => { class e extends ar { constructor(n, r) { super(), this._platformLocation = n, this._baseHref = "", this._removeListenerFns = [], null != r && (this._baseHref = r) } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(n) { this._removeListenerFns.push(this._platformLocation.onPopState(n), this._platformLocation.onHashChange(n)) } getBaseHref() { return this._baseHref } path(n = !1) { let r = this._platformLocation.hash; return null == r && (r = "#"), r.length > 0 ? r.substring(1) : r } prepareExternalUrl(n) { const r = Ud(this._baseHref, n); return r.length > 0 ? "#" + r : r } pushState(n, r, o, i) { let s = this.prepareExternalUrl(o + yn(i)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.pushState(n, r, s) } replaceState(n, r, o, i) { let s = this.prepareExternalUrl(o + yn(i)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.replaceState(n, r, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } getState() { return this._platformLocation.getState() } historyGo(n = 0) { this._platformLocation.historyGo?.(n) } static #e = this.\u0275fac = function (r) { return new (r || e)(A($d), A(VC, 8)) }; static #t = this.\u0275prov = T({ token: e, factory: e.\u0275fac }) } return e })(), zd = (() => { class e { constructor(n) { this._subject = new pe, this._urlChangeListeners = [], this._urlChangeSubscription = null, this._locationStrategy = n; const r = this._locationStrategy.getBaseHref(); this._basePath = function vR(e) { if (new RegExp("^(https?:)?//").test(e)) { const [, n] = e.split(/\/\/[^\/]+/); return n } return e }(LC(BC(r))), this._locationStrategy.onPopState(o => { this._subject.emit({ url: this.path(!0), pop: !0, state: o.state, type: o.type }) }) } ngOnDestroy() { this._urlChangeSubscription?.unsubscribe(), this._urlChangeListeners = [] } path(n = !1) { return this.normalize(this._locationStrategy.path(n)) } getState() { return this._locationStrategy.getState() } isCurrentPathEqualTo(n, r = "") { return this.path() == this.normalize(n + yn(r)) } normalize(n) { return e.stripTrailingSlash(function mR(e, t) { if (!e || !t.startsWith(e)) return t; const n = t.substring(e.length); return "" === n || ["/", ";", "?", "#"].includes(n[0]) ? n : t }(this._basePath, BC(n))) } prepareExternalUrl(n) { return n && "/" !== n[0] && (n = "/" + n), this._locationStrategy.prepareExternalUrl(n) } go(n, r = "", o = null) { this._locationStrategy.pushState(o, "", n, r), this._notifyUrlChangeListeners(this.prepareExternalUrl(n + yn(r)), o) } replaceState(n, r = "", o = null) { this._locationStrategy.replaceState(o, "", n, r), this._notifyUrlChangeListeners(this.prepareExternalUrl(n + yn(r)), o) } forward() { this._locationStrategy.forward() } back() { this._locationStrategy.back() } historyGo(n = 0) { this._locationStrategy.historyGo?.(n) } onUrlChange(n) { return this._urlChangeListeners.push(n), this._urlChangeSubscription || (this._urlChangeSubscription = this.subscribe(r => { this._notifyUrlChangeListeners(r.url, r.state) })), () => { const r = this._urlChangeListeners.indexOf(n); this._urlChangeListeners.splice(r, 1), 0 === this._urlChangeListeners.length && (this._urlChangeSubscription?.unsubscribe(), this._urlChangeSubscription = null) } } _notifyUrlChangeListeners(n = "", r) { this._urlChangeListeners.forEach(o => o(n, r)) } subscribe(n, r, o) { return this._subject.subscribe({ next: n, error: r, complete: o }) } static #e = this.normalizeQueryParams = yn; static #t = this.joinWithSlash = Ud; static #n = this.stripTrailingSlash = LC; static #r = this.\u0275fac = function (r) { return new (r || e)(A(ar)) }; static #o = this.\u0275prov = T({ token: e, factory: function () { return function gR() { return new zd(A(ar)) }() }, providedIn: "root" }) } return e })(); function BC(e) { return e.replace(/\/index.html$/, "") } function YC(e, t) { t = encodeURIComponent(t); for (const n of e.split(";")) { const r = n.indexOf("="), [o, i] = -1 == r ? [n, ""] : [n.slice(0, r), n.slice(r + 1)]; if (o.trim() === t) return decodeURIComponent(i) } return null } const ef = /\s+/, QC = []; let XC = (() => { class e { constructor(n, r, o, i) { this._iterableDiffers = n, this._keyValueDiffers = r, this._ngEl = o, this._renderer = i, this.initialClasses = QC, this.stateMap = new Map } set klass(n) { this.initialClasses = null != n ? n.trim().split(ef) : QC } set ngClass(n) { this.rawClass = "string" == typeof n ? n.trim().split(ef) : n } ngDoCheck() { for (const r of this.initialClasses) this._updateState(r, !0); const n = this.rawClass; if (Array.isArray(n) || n instanceof Set) for (const r of n) this._updateState(r, !0); else if (null != n) for (const r of Object.keys(n)) this._updateState(r, !!n[r]); this._applyStateDiff() } _updateState(n, r) { const o = this.stateMap.get(n); void 0 !== o ? (o.enabled !== r && (o.changed = !0, o.enabled = r), o.touched = !0) : this.stateMap.set(n, { enabled: r, changed: !0, touched: !0 }) } _applyStateDiff() { for (const n of this.stateMap) { const r = n[0], o = n[1]; o.changed ? (this._toggleClass(r, o.enabled), o.changed = !1) : o.touched || (o.enabled && this._toggleClass(r, !1), this.stateMap.delete(r)), o.touched = !1 } } _toggleClass(n, r) { (n = n.trim()).length > 0 && n.split(ef).forEach(o => { r ? this._renderer.addClass(this._ngEl.nativeElement, o) : this._renderer.removeClass(this._ngEl.nativeElement, o) }) } static #e = this.\u0275fac = function (r) { return new (r || e)(D(Ha), D(Pi), D(ft), D(fn)) }; static #t = this.\u0275dir = k({ type: e, selectors: [["", "ngClass", ""]], inputs: { klass: ["class", "klass"], ngClass: "ngClass" }, standalone: !0 }) } return e })(); class n1 { constructor(t, n, r, o) { this.$implicit = t, this.ngForOf = n, this.index = r, this.count = o } get first() { return 0 === this.index } get last() { return this.index === this.count - 1 } get even() { return this.index % 2 == 0 } get odd() { return !this.even } } let KC = (() => { class e { set ngForOf(n) { this._ngForOf = n, this._ngForOfDirty = !0 } set ngForTrackBy(n) { this._trackByFn = n } get ngForTrackBy() { return this._trackByFn } constructor(n, r, o) { this._viewContainer = n, this._template = r, this._differs = o, this._ngForOf = null, this._ngForOfDirty = !0, this._differ = null } set ngForTemplate(n) { n && (this._template = n) } ngDoCheck() { if (this._ngForOfDirty) { this._ngForOfDirty = !1; const n = this._ngForOf; !this._differ && n && (this._differ = this._differs.find(n).create(this.ngForTrackBy)) } if (this._differ) { const n = this._differ.diff(this._ngForOf); n && this._applyChanges(n) } } _applyChanges(n) { const r = this._viewContainer; n.forEachOperation((o, i, s) => { if (null == o.previousIndex) r.createEmbeddedView(this._template, new n1(o.item, this._ngForOf, -1, -1), null === s ? void 0 : s); else if (null == s) r.remove(null === i ? void 0 : i); else if (null !== i) { const a = r.get(i); r.move(a, s), eD(a, o) } }); for (let o = 0, i = r.length; o < i; o++) { const a = r.get(o).context; a.index = o, a.count = i, a.ngForOf = this._ngForOf } n.forEachIdentityChange(o => { eD(r.get(o.currentIndex), o) }) } static ngTemplateContextGuard(n, r) { return !0 } static #e = this.\u0275fac = function (r) { return new (r || e)(D(kt), D(mn), D(Ha)) }; static #t = this.\u0275dir = k({ type: e, selectors: [["", "ngFor", "", "ngForOf", ""]], inputs: { ngForOf: "ngForOf", ngForTrackBy: "ngForTrackBy", ngForTemplate: "ngForTemplate" }, standalone: !0 }) } return e })(); function eD(e, t) { e.context.$implicit = t.item } let tD = (() => { class e { constructor(n, r) { this._viewContainer = n, this._context = new r1, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = r } set ngIf(n) { this._context.$implicit = this._context.ngIf = n, this._updateView() } set ngIfThen(n) { nD("ngIfThen", n), this._thenTemplateRef = n, this._thenViewRef = null, this._updateView() } set ngIfElse(n) { nD("ngIfElse", n), this._elseTemplateRef = n, this._elseViewRef = null, this._updateView() } _updateView() { this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context))) } static ngTemplateContextGuard(n, r) { return !0 } static #e = this.\u0275fac = function (r) { return new (r || e)(D(kt), D(mn)) }; static #t = this.\u0275dir = k({ type: e, selectors: [["", "ngIf", ""]], inputs: { ngIf: "ngIf", ngIfThen: "ngIfThen", ngIfElse: "ngIfElse" }, standalone: !0 }) } return e })(); class r1 { constructor() { this.$implicit = null, this.ngIf = null } } function nD(e, t) { if (t && !t.createEmbeddedView) throw new Error(`${e} must be a TemplateRef, but received '${Ee(t)}'.`) } let A1 = (() => { class e { static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275mod = _t({ type: e }); static #n = this.\u0275inj = at({}) } return e })(); function sD(e) { return "server" === e } let P1 = (() => { class e { static #e = this.\u0275prov = T({ token: e, providedIn: "root", factory: () => new x1(A(gt), window) }) } return e })(); class x1 { constructor(t, n) { this.document = t, this.window = n, this.offset = () => [0, 0] } setOffset(t) { this.offset = Array.isArray(t) ? () => t : t } getScrollPosition() { return this.supportsScrolling() ? [this.window.pageXOffset, this.window.pageYOffset] : [0, 0] } scrollToPosition(t) { this.supportsScrolling() && this.window.scrollTo(t[0], t[1]) } scrollToAnchor(t) { if (!this.supportsScrolling()) return; const n = function R1(e, t) { const n = e.getElementById(t) || e.getElementsByName(t)[0]; if (n) return n; if ("function" == typeof e.createTreeWalker && e.body && "function" == typeof e.body.attachShadow) { const r = e.createTreeWalker(e.body, NodeFilter.SHOW_ELEMENT); let o = r.currentNode; for (; o;) { const i = o.shadowRoot; if (i) { const s = i.getElementById(t) || i.querySelector(`[name="${t}"]`); if (s) return s } o = r.nextNode() } } return null }(this.document, t); n && (this.scrollToElement(n), n.focus()) } setHistoryScrollRestoration(t) { this.supportsScrolling() && (this.window.history.scrollRestoration = t) } scrollToElement(t) { const n = t.getBoundingClientRect(), r = n.left + this.window.pageXOffset, o = n.top + this.window.pageYOffset, i = this.offset(); this.window.scrollTo(r - i[0], o - i[1]) } supportsScrolling() { try { return !!this.window && !!this.window.scrollTo && "pageXOffset" in this.window } catch { return !1 } } } class aD { } class rF extends dR { constructor() { super(...arguments), this.supportsDOMEvents = !0 } } class cf extends rF { static makeCurrent() { !function lR(e) { Hd || (Hd = e) }(new cf) } onAndCancel(t, n, r) { return t.addEventListener(n, r), () => { t.removeEventListener(n, r) } } dispatchEvent(t, n) { t.dispatchEvent(n) } remove(t) { t.parentNode && t.parentNode.removeChild(t) } createElement(t, n) { return (n = n || this.getDefaultDocument()).createElement(t) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(t) { return t.nodeType === Node.ELEMENT_NODE } isShadowRoot(t) { return t instanceof DocumentFragment } getGlobalEventTarget(t, n) { return "window" === n ? window : "document" === n ? t : "body" === n ? t.body : null } getBaseHref(t) { const n = function oF() { return ki = ki || document.querySelector("base"), ki ? ki.getAttribute("href") : null }(); return null == n ? null : function iF(e) { tu = tu || document.createElement("a"), tu.setAttribute("href", e); const t = tu.pathname; return "/" === t.charAt(0) ? t : `/${t}` }(n) } resetBaseElement() { ki = null } getUserAgent() { return window.navigator.userAgent } getCookie(t) { return YC(document.cookie, t) } } let tu, ki = null, aF = (() => { class e { build() { return new XMLHttpRequest } static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275prov = T({ token: e, factory: e.\u0275fac }) } return e })(); const lf = new M("EventManagerPlugins"); let fD = (() => { class e { constructor(n, r) { this._zone = r, this._eventNameToPlugin = new Map, n.forEach(o => { o.manager = this }), this._plugins = n.slice().reverse() } addEventListener(n, r, o) { return this._findPluginFor(r).addEventListener(n, r, o) } getZone() { return this._zone } _findPluginFor(n) { let r = this._eventNameToPlugin.get(n); if (r) return r; if (r = this._plugins.find(i => i.supports(n)), !r) throw new C(5101, !1); return this._eventNameToPlugin.set(n, r), r } static #e = this.\u0275fac = function (r) { return new (r || e)(A(lf), A(ae)) }; static #t = this.\u0275prov = T({ token: e, factory: e.\u0275fac }) } return e })(); class hD { constructor(t) { this._doc = t } } const df = "ng-app-id"; let pD = (() => { class e { constructor(n, r, o, i = {}) { this.doc = n, this.appId = r, this.nonce = o, this.platformId = i, this.styleRef = new Map, this.hostNodes = new Set, this.styleNodesInDOM = this.collectServerRenderedStyles(), this.platformIsServer = sD(i), this.resetHostNodes() } addStyles(n) { for (const r of n) 1 === this.changeUsageCount(r, 1) && this.onStyleAdded(r) } removeStyles(n) { for (const r of n) this.changeUsageCount(r, -1) <= 0 && this.onStyleRemoved(r) } ngOnDestroy() { const n = this.styleNodesInDOM; n && (n.forEach(r => r.remove()), n.clear()); for (const r of this.getAllStyles()) this.onStyleRemoved(r); this.resetHostNodes() } addHost(n) { this.hostNodes.add(n); for (const r of this.getAllStyles()) this.addStyleToHost(n, r) } removeHost(n) { this.hostNodes.delete(n) } getAllStyles() { return this.styleRef.keys() } onStyleAdded(n) { for (const r of this.hostNodes) this.addStyleToHost(r, n) } onStyleRemoved(n) { const r = this.styleRef; r.get(n)?.elements?.forEach(o => o.remove()), r.delete(n) } collectServerRenderedStyles() { const n = this.doc.head?.querySelectorAll(`style[${df}="${this.appId}"]`); if (n?.length) { const r = new Map; return n.forEach(o => { null != o.textContent && r.set(o.textContent, o) }), r } return null } changeUsageCount(n, r) { const o = this.styleRef; if (o.has(n)) { const i = o.get(n); return i.usage += r, i.usage } return o.set(n, { usage: r, elements: [] }), r } getStyleElement(n, r) { const o = this.styleNodesInDOM, i = o?.get(r); if (i?.parentNode === n) return o.delete(r), i.removeAttribute(df), i; { const s = this.doc.createElement("style"); return this.nonce && s.setAttribute("nonce", this.nonce), s.textContent = r, this.platformIsServer && s.setAttribute(df, this.appId), s } } addStyleToHost(n, r) { const o = this.getStyleElement(n, r); n.appendChild(o); const i = this.styleRef, s = i.get(r)?.elements; s ? s.push(o) : i.set(r, { elements: [o], usage: 1 }) } resetHostNodes() { const n = this.hostNodes; n.clear(), n.add(this.doc.head) } static #e = this.\u0275fac = function (r) { return new (r || e)(A(gt), A(ia), A(mm, 8), A(tr)) }; static #t = this.\u0275prov = T({ token: e, factory: e.\u0275fac }) } return e })(); const ff = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/", math: "http://www.w3.org/1998/MathML/" }, hf = /%COMP%/g, dF = new M("RemoveStylesOnCompDestroy", { providedIn: "root", factory: () => !1 }); function mD(e, t) { return t.map(n => n.replace(hf, e)) } let vD = (() => { class e { constructor(n, r, o, i, s, a, u, c = null) { this.eventManager = n, this.sharedStylesHost = r, this.appId = o, this.removeStylesOnCompDestroy = i, this.doc = s, this.platformId = a, this.ngZone = u, this.nonce = c, this.rendererByCompId = new Map, this.platformIsServer = sD(a), this.defaultRenderer = new pf(n, s, u, this.platformIsServer) } createRenderer(n, r) { if (!n || !r) return this.defaultRenderer; this.platformIsServer && r.encapsulation === Ot.ShadowDom && (r = { ...r, encapsulation: Ot.Emulated }); const o = this.getOrCreateRenderer(n, r); return o instanceof _D ? o.applyToHost(n) : o instanceof gf && o.applyStyles(), o } getOrCreateRenderer(n, r) { const o = this.rendererByCompId; let i = o.get(r.id); if (!i) { const s = this.doc, a = this.ngZone, u = this.eventManager, c = this.sharedStylesHost, l = this.removeStylesOnCompDestroy, d = this.platformIsServer; switch (r.encapsulation) { case Ot.Emulated: i = new _D(u, c, r, this.appId, l, s, a, d); break; case Ot.ShadowDom: return new gF(u, c, n, r, s, a, this.nonce, d); default: i = new gf(u, c, r, l, s, a, d) }o.set(r.id, i) } return i } ngOnDestroy() { this.rendererByCompId.clear() } static #e = this.\u0275fac = function (r) { return new (r || e)(A(fD), A(pD), A(ia), A(dF), A(gt), A(tr), A(ae), A(mm)) }; static #t = this.\u0275prov = T({ token: e, factory: e.\u0275fac }) } return e })(); class pf { constructor(t, n, r, o) { this.eventManager = t, this.doc = n, this.ngZone = r, this.platformIsServer = o, this.data = Object.create(null), this.destroyNode = null } destroy() { } createElement(t, n) { return n ? this.doc.createElementNS(ff[n] || n, t) : this.doc.createElement(t) } createComment(t) { return this.doc.createComment(t) } createText(t) { return this.doc.createTextNode(t) } appendChild(t, n) { (yD(t) ? t.content : t).appendChild(n) } insertBefore(t, n, r) { t && (yD(t) ? t.content : t).insertBefore(n, r) } removeChild(t, n) { t && t.removeChild(n) } selectRootElement(t, n) { let r = "string" == typeof t ? this.doc.querySelector(t) : t; if (!r) throw new C(-5104, !1); return n || (r.textContent = ""), r } parentNode(t) { return t.parentNode } nextSibling(t) { return t.nextSibling } setAttribute(t, n, r, o) { if (o) { n = o + ":" + n; const i = ff[o]; i ? t.setAttributeNS(i, n, r) : t.setAttribute(n, r) } else t.setAttribute(n, r) } removeAttribute(t, n, r) { if (r) { const o = ff[r]; o ? t.removeAttributeNS(o, n) : t.removeAttribute(`${r}:${n}`) } else t.removeAttribute(n) } addClass(t, n) { t.classList.add(n) } removeClass(t, n) { t.classList.remove(n) } setStyle(t, n, r, o) { o & (Pn.DashCase | Pn.Important) ? t.style.setProperty(n, r, o & Pn.Important ? "important" : "") : t.style[n] = r } removeStyle(t, n, r) { r & Pn.DashCase ? t.style.removeProperty(n) : t.style[n] = "" } setProperty(t, n, r) { t[n] = r } setValue(t, n) { t.nodeValue = n } listen(t, n, r) { if ("string" == typeof t && !(t = Ln().getGlobalEventTarget(this.doc, t))) throw new Error(`Unsupported event target ${t} for event ${n}`); return this.eventManager.addEventListener(t, n, this.decoratePreventDefault(r)) } decoratePreventDefault(t) { return n => { if ("__ngUnwrap__" === n) return t; !1 === (this.platformIsServer ? this.ngZone.runGuarded(() => t(n)) : t(n)) && n.preventDefault() } } } function yD(e) { return "TEMPLATE" === e.tagName && void 0 !== e.content } class gF extends pf { constructor(t, n, r, o, i, s, a, u) { super(t, i, s, u), this.sharedStylesHost = n, this.hostEl = r, this.shadowRoot = r.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); const c = mD(o.id, o.styles); for (const l of c) { const d = document.createElement("style"); a && d.setAttribute("nonce", a), d.textContent = l, this.shadowRoot.appendChild(d) } } nodeOrShadowRoot(t) { return t === this.hostEl ? this.shadowRoot : t } appendChild(t, n) { return super.appendChild(this.nodeOrShadowRoot(t), n) } insertBefore(t, n, r) { return super.insertBefore(this.nodeOrShadowRoot(t), n, r) } removeChild(t, n) { return super.removeChild(this.nodeOrShadowRoot(t), n) } parentNode(t) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t))) } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } } class gf extends pf { constructor(t, n, r, o, i, s, a, u) { super(t, i, s, a), this.sharedStylesHost = n, this.removeStylesOnCompDestroy = o, this.styles = u ? mD(u, r.styles) : r.styles } applyStyles() { this.sharedStylesHost.addStyles(this.styles) } destroy() { this.removeStylesOnCompDestroy && this.sharedStylesHost.removeStyles(this.styles) } } class _D extends gf { constructor(t, n, r, o, i, s, a, u) { const c = o + "-" + r.id; super(t, n, r, i, s, a, u, c), this.contentAttr = function fF(e) { return "_ngcontent-%COMP%".replace(hf, e) }(c), this.hostAttr = function hF(e) { return "_nghost-%COMP%".replace(hf, e) }(c) } applyToHost(t) { this.applyStyles(), this.setAttribute(t, this.hostAttr, "") } createElement(t, n) { const r = super.createElement(t, n); return super.setAttribute(r, this.contentAttr, ""), r } } let mF = (() => { class e extends hD { constructor(n) { super(n) } supports(n) { return !0 } addEventListener(n, r, o) { return n.addEventListener(r, o, !1), () => this.removeEventListener(n, r, o) } removeEventListener(n, r, o) { return n.removeEventListener(r, o) } static #e = this.\u0275fac = function (r) { return new (r || e)(A(gt)) }; static #t = this.\u0275prov = T({ token: e, factory: e.\u0275fac }) } return e })(); const CD = ["alt", "control", "meta", "shift"], vF = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, yF = { alt: e => e.altKey, control: e => e.ctrlKey, meta: e => e.metaKey, shift: e => e.shiftKey }; let _F = (() => { class e extends hD { constructor(n) { super(n) } supports(n) { return null != e.parseEventName(n) } addEventListener(n, r, o) { const i = e.parseEventName(r), s = e.eventCallback(i.fullKey, o, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => Ln().onAndCancel(n, i.domEventName, s)) } static parseEventName(n) { const r = n.toLowerCase().split("."), o = r.shift(); if (0 === r.length || "keydown" !== o && "keyup" !== o) return null; const i = e._normalizeKey(r.pop()); let s = "", a = r.indexOf("code"); if (a > -1 && (r.splice(a, 1), s = "code."), CD.forEach(c => { const l = r.indexOf(c); l > -1 && (r.splice(l, 1), s += c + ".") }), s += i, 0 != r.length || 0 === i.length) return null; const u = {}; return u.domEventName = o, u.fullKey = s, u } static matchEventFullKeyCode(n, r) { let o = vF[n.key] || n.key, i = ""; return r.indexOf("code.") > -1 && (o = n.code, i = "code."), !(null == o || !o) && (o = o.toLowerCase(), " " === o ? o = "space" : "." === o && (o = "dot"), CD.forEach(s => { s !== o && (0, yF[s])(n) && (i += s + ".") }), i += o, i === r) } static eventCallback(n, r, o) { return i => { e.matchEventFullKeyCode(i, n) && o.runGuarded(() => r(i)) } } static _normalizeKey(n) { return "esc" === n ? "escape" : n } static #e = this.\u0275fac = function (r) { return new (r || e)(A(gt)) }; static #t = this.\u0275prov = T({ token: e, factory: e.\u0275fac }) } return e })(); const bF = dC(Qx, "browser", [{ provide: tr, useValue: "browser" }, { provide: gm, useValue: function CF() { cf.makeCurrent() }, multi: !0 }, { provide: gt, useFactory: function wF() { return function XS(e) { el = e }(document), document }, deps: [] }]), EF = new M(""), bD = [{ provide: ka, useClass: class sF { addToWindow(t) { ie.getAngularTestability = (r, o = !0) => { const i = t.findTestabilityInTree(r, o); if (null == i) throw new C(5103, !1); return i }, ie.getAllAngularTestabilities = () => t.getAllTestabilities(), ie.getAllAngularRootElements = () => t.getAllRootElements(), ie.frameworkStabilizers || (ie.frameworkStabilizers = []), ie.frameworkStabilizers.push(r => { const o = ie.getAllAngularTestabilities(); let i = o.length, s = !1; const a = function (u) { s = s || u, i--, 0 == i && r(s) }; o.forEach(u => { u.whenStable(a) }) }) } findTestabilityInTree(t, n, r) { return null == n ? null : t.getTestability(n) ?? (r ? Ln().isShadowRoot(n) ? this.findTestabilityInTree(t, n.host, !0) : this.findTestabilityInTree(t, n.parentElement, !0) : null) } }, deps: [] }, { provide: sC, useClass: Od, deps: [ae, Nd, ka] }, { provide: Od, useClass: Od, deps: [ae, Nd, ka] }], ED = [{ provide: ll, useValue: "root" }, { provide: hn, useFactory: function DF() { return new hn }, deps: [] }, { provide: lf, useClass: mF, multi: !0, deps: [gt, ae, tr] }, { provide: lf, useClass: _F, multi: !0, deps: [gt] }, vD, pD, fD, { provide: wm, useExisting: vD }, { provide: aD, useClass: aF, deps: [] }, []]; let MF = (() => { class e { constructor(n) { } static withServerTransition(n) { return { ngModule: e, providers: [{ provide: ia, useValue: n.appId }] } } static #e = this.\u0275fac = function (r) { return new (r || e)(A(EF, 12)) }; static #t = this.\u0275mod = _t({ type: e }); static #n = this.\u0275inj = at({ providers: [...ED, ...bD], imports: [A1, Xx] }) } return e })(), MD = (() => { class e { constructor(n) { this._doc = n } getTitle() { return this._doc.title } setTitle(n) { this._doc.title = n || "" } static #e = this.\u0275fac = function (r) { return new (r || e)(A(gt)) }; static #t = this.\u0275prov = T({ token: e, factory: function (r) { let o = null; return o = r ? new r : function SF() { return new MD(A(gt)) }(), o }, providedIn: "root" }) } return e })(); function go(e, t) { return ne(t) ? Te(e, t, 1) : Te(e, 1) } function Dn(e, t) { return we((n, r) => { let o = 0; n.subscribe(Ce(r, i => e.call(t, i, o++) && r.next(i))) }) } function Li(e) { return we((t, n) => { try { t.subscribe(n) } finally { n.add(e) } }) } typeof window < "u" && window; class nu { } class ru { } class Kt { constructor(t) { this.normalizedNames = new Map, this.lazyUpdate = null, t ? "string" == typeof t ? this.lazyInit = () => { this.headers = new Map, t.split("\n").forEach(n => { const r = n.indexOf(":"); if (r > 0) { const o = n.slice(0, r), i = o.toLowerCase(), s = n.slice(r + 1).trim(); this.maybeSetNormalizedName(o, i), this.headers.has(i) ? this.headers.get(i).push(s) : this.headers.set(i, [s]) } }) } : typeof Headers < "u" && t instanceof Headers ? (this.headers = new Map, t.forEach((n, r) => { this.setHeaderEntries(r, n) })) : this.lazyInit = () => { this.headers = new Map, Object.entries(t).forEach(([n, r]) => { this.setHeaderEntries(n, r) }) } : this.headers = new Map } has(t) { return this.init(), this.headers.has(t.toLowerCase()) } get(t) { this.init(); const n = this.headers.get(t.toLowerCase()); return n && n.length > 0 ? n[0] : null } keys() { return this.init(), Array.from(this.normalizedNames.values()) } getAll(t) { return this.init(), this.headers.get(t.toLowerCase()) || null } append(t, n) { return this.clone({ name: t, value: n, op: "a" }) } set(t, n) { return this.clone({ name: t, value: n, op: "s" }) } delete(t, n) { return this.clone({ name: t, value: n, op: "d" }) } maybeSetNormalizedName(t, n) { this.normalizedNames.has(n) || this.normalizedNames.set(n, t) } init() { this.lazyInit && (this.lazyInit instanceof Kt ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(t => this.applyUpdate(t)), this.lazyUpdate = null)) } copyFrom(t) { t.init(), Array.from(t.headers.keys()).forEach(n => { this.headers.set(n, t.headers.get(n)), this.normalizedNames.set(n, t.normalizedNames.get(n)) }) } clone(t) { const n = new Kt; return n.lazyInit = this.lazyInit && this.lazyInit instanceof Kt ? this.lazyInit : this, n.lazyUpdate = (this.lazyUpdate || []).concat([t]), n } applyUpdate(t) { const n = t.name.toLowerCase(); switch (t.op) { case "a": case "s": let r = t.value; if ("string" == typeof r && (r = [r]), 0 === r.length) return; this.maybeSetNormalizedName(t.name, n); const o = ("a" === t.op ? this.headers.get(n) : void 0) || []; o.push(...r), this.headers.set(n, o); break; case "d": const i = t.value; if (i) { let s = this.headers.get(n); if (!s) return; s = s.filter(a => -1 === i.indexOf(a)), 0 === s.length ? (this.headers.delete(n), this.normalizedNames.delete(n)) : this.headers.set(n, s) } else this.headers.delete(n), this.normalizedNames.delete(n) } } setHeaderEntries(t, n) { const r = (Array.isArray(n) ? n : [n]).map(i => i.toString()), o = t.toLowerCase(); this.headers.set(o, r), this.maybeSetNormalizedName(t, o) } forEach(t) { this.init(), Array.from(this.normalizedNames.keys()).forEach(n => t(this.normalizedNames.get(n), this.headers.get(n))) } } class PF { encodeKey(t) { return TD(t) } encodeValue(t) { return TD(t) } decodeKey(t) { return decodeURIComponent(t) } decodeValue(t) { return decodeURIComponent(t) } } const RF = /%(\d[a-f0-9])/gi, FF = { 40: "@", "3A": ":", 24: "$", "2C": ",", "3B": ";", "3D": "=", "3F": "?", "2F": "/" }; function TD(e) { return encodeURIComponent(e).replace(RF, (t, n) => FF[n] ?? t) } function ou(e) { return `${e}` } class jn { constructor(t = {}) { if (this.updates = null, this.cloneFrom = null, this.encoder = t.encoder || new PF, t.fromString) { if (t.fromObject) throw new Error("Cannot specify both fromString and fromObject."); this.map = function xF(e, t) { const n = new Map; return e.length > 0 && e.replace(/^\?/, "").split("&").forEach(o => { const i = o.indexOf("="), [s, a] = -1 == i ? [t.decodeKey(o), ""] : [t.decodeKey(o.slice(0, i)), t.decodeValue(o.slice(i + 1))], u = n.get(s) || []; u.push(a), n.set(s, u) }), n }(t.fromString, this.encoder) } else t.fromObject ? (this.map = new Map, Object.keys(t.fromObject).forEach(n => { const r = t.fromObject[n], o = Array.isArray(r) ? r.map(ou) : [ou(r)]; this.map.set(n, o) })) : this.map = null } has(t) { return this.init(), this.map.has(t) } get(t) { this.init(); const n = this.map.get(t); return n ? n[0] : null } getAll(t) { return this.init(), this.map.get(t) || null } keys() { return this.init(), Array.from(this.map.keys()) } append(t, n) { return this.clone({ param: t, value: n, op: "a" }) } appendAll(t) { const n = []; return Object.keys(t).forEach(r => { const o = t[r]; Array.isArray(o) ? o.forEach(i => { n.push({ param: r, value: i, op: "a" }) }) : n.push({ param: r, value: o, op: "a" }) }), this.clone(n) } set(t, n) { return this.clone({ param: t, value: n, op: "s" }) } delete(t, n) { return this.clone({ param: t, value: n, op: "d" }) } toString() { return this.init(), this.keys().map(t => { const n = this.encoder.encodeKey(t); return this.map.get(t).map(r => n + "=" + this.encoder.encodeValue(r)).join("&") }).filter(t => "" !== t).join("&") } clone(t) { const n = new jn({ encoder: this.encoder }); return n.cloneFrom = this.cloneFrom || this, n.updates = (this.updates || []).concat(t), n } init() { null === this.map && (this.map = new Map), null !== this.cloneFrom && (this.cloneFrom.init(), this.cloneFrom.keys().forEach(t => this.map.set(t, this.cloneFrom.map.get(t))), this.updates.forEach(t => { switch (t.op) { case "a": case "s": const n = ("a" === t.op ? this.map.get(t.param) : void 0) || []; n.push(ou(t.value)), this.map.set(t.param, n); break; case "d": if (void 0 === t.value) { this.map.delete(t.param); break } { let r = this.map.get(t.param) || []; const o = r.indexOf(ou(t.value)); -1 !== o && r.splice(o, 1), r.length > 0 ? this.map.set(t.param, r) : this.map.delete(t.param) } } }), this.cloneFrom = this.updates = null) } } class kF { constructor() { this.map = new Map } set(t, n) { return this.map.set(t, n), this } get(t) { return this.map.has(t) || this.map.set(t, t.defaultValue()), this.map.get(t) } delete(t) { return this.map.delete(t), this } has(t) { return this.map.has(t) } keys() { return this.map.keys() } } function OD(e) { return typeof ArrayBuffer < "u" && e instanceof ArrayBuffer } function ND(e) { return typeof Blob < "u" && e instanceof Blob } function PD(e) { return typeof FormData < "u" && e instanceof FormData } class Vi { constructor(t, n, r, o) { let i; if (this.url = n, this.body = null, this.reportProgress = !1, this.withCredentials = !1, this.responseType = "json", this.method = t.toUpperCase(), function LF(e) { switch (e) { case "DELETE": case "GET": case "HEAD": case "OPTIONS": case "JSONP": return !1; default: return !0 } }(this.method) || o ? (this.body = void 0 !== r ? r : null, i = o) : i = r, i && (this.reportProgress = !!i.reportProgress, this.withCredentials = !!i.withCredentials, i.responseType && (this.responseType = i.responseType), i.headers && (this.headers = i.headers), i.context && (this.context = i.context), i.params && (this.params = i.params)), this.headers || (this.headers = new Kt), this.context || (this.context = new kF), this.params) { const s = this.params.toString(); if (0 === s.length) this.urlWithParams = n; else { const a = n.indexOf("?"); this.urlWithParams = n + (-1 === a ? "?" : a < n.length - 1 ? "&" : "") + s } } else this.params = new jn, this.urlWithParams = n } serializeBody() { return null === this.body ? null : OD(this.body) || ND(this.body) || PD(this.body) || function VF(e) { return typeof URLSearchParams < "u" && e instanceof URLSearchParams }(this.body) || "string" == typeof this.body ? this.body : this.body instanceof jn ? this.body.toString() : "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString() } detectContentTypeHeader() { return null === this.body || PD(this.body) ? null : ND(this.body) ? this.body.type || null : OD(this.body) ? null : "string" == typeof this.body ? "text/plain" : this.body instanceof jn ? "application/x-www-form-urlencoded;charset=UTF-8" : "object" == typeof this.body || "number" == typeof this.body || "boolean" == typeof this.body ? "application/json" : null } clone(t = {}) { const n = t.method || this.method, r = t.url || this.url, o = t.responseType || this.responseType, i = void 0 !== t.body ? t.body : this.body, s = void 0 !== t.withCredentials ? t.withCredentials : this.withCredentials, a = void 0 !== t.reportProgress ? t.reportProgress : this.reportProgress; let u = t.headers || this.headers, c = t.params || this.params; const l = t.context ?? this.context; return void 0 !== t.setHeaders && (u = Object.keys(t.setHeaders).reduce((d, f) => d.set(f, t.setHeaders[f]), u)), t.setParams && (c = Object.keys(t.setParams).reduce((d, f) => d.set(f, t.setParams[f]), c)), new Vi(n, r, i, { params: c, headers: u, context: l, reportProgress: a, responseType: o, withCredentials: s }) } } var mo = function (e) { return e[e.Sent = 0] = "Sent", e[e.UploadProgress = 1] = "UploadProgress", e[e.ResponseHeader = 2] = "ResponseHeader", e[e.DownloadProgress = 3] = "DownloadProgress", e[e.Response = 4] = "Response", e[e.User = 5] = "User", e }(mo || {}); class vf { constructor(t, n = 200, r = "OK") { this.headers = t.headers || new Kt, this.status = void 0 !== t.status ? t.status : n, this.statusText = t.statusText || r, this.url = t.url || null, this.ok = this.status >= 200 && this.status < 300 } } class yf extends vf { constructor(t = {}) { super(t), this.type = mo.ResponseHeader } clone(t = {}) { return new yf({ headers: t.headers || this.headers, status: void 0 !== t.status ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 }) } } class vo extends vf { constructor(t = {}) { super(t), this.type = mo.Response, this.body = void 0 !== t.body ? t.body : null } clone(t = {}) { return new vo({ body: void 0 !== t.body ? t.body : this.body, headers: t.headers || this.headers, status: void 0 !== t.status ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 }) } } class xD extends vf { constructor(t) { super(t, 0, "Unknown Error"), this.name = "HttpErrorResponse", this.ok = !1, this.message = this.status >= 200 && this.status < 300 ? `Http failure during parsing for ${t.url || "(unknown url)"}` : `Http failure response for ${t.url || "(unknown url)"}: ${t.status} ${t.statusText}`, this.error = t.error || null } } function _f(e, t) { return { body: t, headers: e.headers, context: e.context, observe: e.observe, params: e.params, reportProgress: e.reportProgress, responseType: e.responseType, withCredentials: e.withCredentials } } let RD = (() => { class e { constructor(n) { this.handler = n } request(n, r, o = {}) { let i; if (n instanceof Vi) i = n; else { let u, c; u = o.headers instanceof Kt ? o.headers : new Kt(o.headers), o.params && (c = o.params instanceof jn ? o.params : new jn({ fromObject: o.params })), i = new Vi(n, r, void 0 !== o.body ? o.body : null, { headers: u, context: o.context, params: c, reportProgress: o.reportProgress, responseType: o.responseType || "json", withCredentials: o.withCredentials }) } const s = P(i).pipe(go(u => this.handler.handle(u))); if (n instanceof Vi || "events" === o.observe) return s; const a = s.pipe(Dn(u => u instanceof vo)); switch (o.observe || "body") { case "body": switch (i.responseType) { case "arraybuffer": return a.pipe(Y(u => { if (null !== u.body && !(u.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer."); return u.body })); case "blob": return a.pipe(Y(u => { if (null !== u.body && !(u.body instanceof Blob)) throw new Error("Response is not a Blob."); return u.body })); case "text": return a.pipe(Y(u => { if (null !== u.body && "string" != typeof u.body) throw new Error("Response is not a string."); return u.body })); default: return a.pipe(Y(u => u.body)) }case "response": return a; default: throw new Error(`Unreachable: unhandled observe type ${o.observe}}`) } } delete(n, r = {}) { return this.request("DELETE", n, r) } get(n, r = {}) { return this.request("GET", n, r) } head(n, r = {}) { return this.request("HEAD", n, r) } jsonp(n, r) { return this.request("JSONP", n, { params: (new jn).append(r, "JSONP_CALLBACK"), observe: "body", responseType: "json" }) } options(n, r = {}) { return this.request("OPTIONS", n, r) } patch(n, r, o = {}) { return this.request("PATCH", n, _f(o, r)) } post(n, r, o = {}) { return this.request("POST", n, _f(o, r)) } put(n, r, o = {}) { return this.request("PUT", n, _f(o, r)) } static #e = this.\u0275fac = function (r) { return new (r || e)(A(nu)) }; static #t = this.\u0275prov = T({ token: e, factory: e.\u0275fac }) } return e })(); function LD(e, t) { return t(e) } function BF(e, t) { return (n, r) => t.intercept(n, { handle: o => e(o, r) }) } const $F = new M(""), ji = new M(""), VD = new M(""); function UF() { let e = null; return (t, n) => { null === e && (e = (b($F, { optional: !0 }) ?? []).reduceRight(BF, LD)); const r = b(Ra), o = r.add(); return e(t, n).pipe(Li(() => r.remove(o))) } } let jD = (() => { class e extends nu { constructor(n, r) { super(), this.backend = n, this.injector = r, this.chain = null, this.pendingTasks = b(Ra) } handle(n) { if (null === this.chain) { const o = Array.from(new Set([...this.injector.get(ji), ...this.injector.get(VD, [])])); this.chain = o.reduceRight((i, s) => function HF(e, t, n) { return (r, o) => n.runInContext(() => t(r, i => e(i, o))) }(i, s, this.injector), LD) } const r = this.pendingTasks.add(); return this.chain(n, o => this.backend.handle(o)).pipe(Li(() => this.pendingTasks.remove(r))) } static #e = this.\u0275fac = function (r) { return new (r || e)(A(ru), A(dt)) }; static #t = this.\u0275prov = T({ token: e, factory: e.\u0275fac }) } return e })(); const WF = /^\)\]\}',?\n/; let HD = (() => { class e { constructor(n) { this.xhrFactory = n } handle(n) { if ("JSONP" === n.method) throw new C(-2800, !1); const r = this.xhrFactory; return (r.\u0275loadImpl ? be(r.\u0275loadImpl()) : P(null)).pipe(Tt(() => new me(i => { const s = r.build(); if (s.open(n.method, n.urlWithParams), n.withCredentials && (s.withCredentials = !0), n.headers.forEach((g, v) => s.setRequestHeader(g, v.join(","))), n.headers.has("Accept") || s.setRequestHeader("Accept", "application/json, text/plain, */*"), !n.headers.has("Content-Type")) { const g = n.detectContentTypeHeader(); null !== g && s.setRequestHeader("Content-Type", g) } if (n.responseType) { const g = n.responseType.toLowerCase(); s.responseType = "json" !== g ? g : "text" } const a = n.serializeBody(); let u = null; const c = () => { if (null !== u) return u; const g = s.statusText || "OK", v = new Kt(s.getAllResponseHeaders()), _ = function ZF(e) { return "responseURL" in e && e.responseURL ? e.responseURL : /^X-Request-URL:/m.test(e.getAllResponseHeaders()) ? e.getResponseHeader("X-Request-URL") : null }(s) || n.url; return u = new yf({ headers: v, status: s.status, statusText: g, url: _ }), u }, l = () => { let { headers: g, status: v, statusText: _, url: m } = c(), E = null; 204 !== v && (E = typeof s.response > "u" ? s.responseText : s.response), 0 === v && (v = E ? 200 : 0); let N = v >= 200 && v < 300; if ("json" === n.responseType && "string" == typeof E) { const U = E; E = E.replace(WF, ""); try { E = "" !== E ? JSON.parse(E) : null } catch (Ae) { E = U, N && (N = !1, E = { error: Ae, text: E }) } } N ? (i.next(new vo({ body: E, headers: g, status: v, statusText: _, url: m || void 0 })), i.complete()) : i.error(new xD({ error: E, headers: g, status: v, statusText: _, url: m || void 0 })) }, d = g => { const { url: v } = c(), _ = new xD({ error: g, status: s.status || 0, statusText: s.statusText || "Unknown Error", url: v || void 0 }); i.error(_) }; let f = !1; const h = g => { f || (i.next(c()), f = !0); let v = { type: mo.DownloadProgress, loaded: g.loaded }; g.lengthComputable && (v.total = g.total), "text" === n.responseType && s.responseText && (v.partialText = s.responseText), i.next(v) }, p = g => { let v = { type: mo.UploadProgress, loaded: g.loaded }; g.lengthComputable && (v.total = g.total), i.next(v) }; return s.addEventListener("load", l), s.addEventListener("error", d), s.addEventListener("timeout", d), s.addEventListener("abort", d), n.reportProgress && (s.addEventListener("progress", h), null !== a && s.upload && s.upload.addEventListener("progress", p)), s.send(a), i.next({ type: mo.Sent }), () => { s.removeEventListener("error", d), s.removeEventListener("abort", d), s.removeEventListener("load", l), s.removeEventListener("timeout", d), n.reportProgress && (s.removeEventListener("progress", h), null !== a && s.upload && s.upload.removeEventListener("progress", p)), s.readyState !== s.DONE && s.abort() } }))) } static #e = this.\u0275fac = function (r) { return new (r || e)(A(aD)) }; static #t = this.\u0275prov = T({ token: e, factory: e.\u0275fac }) } return e })(); const Cf = new M("XSRF_ENABLED"), $D = new M("XSRF_COOKIE_NAME", { providedIn: "root", factory: () => "XSRF-TOKEN" }), UD = new M("XSRF_HEADER_NAME", { providedIn: "root", factory: () => "X-XSRF-TOKEN" }); class zD { } let XF = (() => { class e { constructor(n, r, o) { this.doc = n, this.platform = r, this.cookieName = o, this.lastCookieString = "", this.lastToken = null, this.parseCount = 0 } getToken() { if ("server" === this.platform) return null; const n = this.doc.cookie || ""; return n !== this.lastCookieString && (this.parseCount++, this.lastToken = YC(n, this.cookieName), this.lastCookieString = n), this.lastToken } static #e = this.\u0275fac = function (r) { return new (r || e)(A(gt), A(tr), A($D)) }; static #t = this.\u0275prov = T({ token: e, factory: e.\u0275fac }) } return e })(); function JF(e, t) { const n = e.url.toLowerCase(); if (!b(Cf) || "GET" === e.method || "HEAD" === e.method || n.startsWith("http://") || n.startsWith("https://")) return t(e); const r = b(zD).getToken(), o = b(UD); return null != r && !e.headers.has(o) && (e = e.clone({ headers: e.headers.set(o, r) })), t(e) } var Bn = function (e) { return e[e.Interceptors = 0] = "Interceptors", e[e.LegacyInterceptors = 1] = "LegacyInterceptors", e[e.CustomXsrfConfiguration = 2] = "CustomXsrfConfiguration", e[e.NoXsrfProtection = 3] = "NoXsrfProtection", e[e.JsonpSupport = 4] = "JsonpSupport", e[e.RequestsMadeViaParent = 5] = "RequestsMadeViaParent", e[e.Fetch = 6] = "Fetch", e }(Bn || {}); function KF(...e) { const t = [RD, HD, jD, { provide: nu, useExisting: jD }, { provide: ru, useExisting: HD }, { provide: ji, useValue: JF, multi: !0 }, { provide: Cf, useValue: !0 }, { provide: zD, useClass: XF }]; for (const n of e) t.push(...n.\u0275providers); return function al(e) { return { \u0275providers: e } }(t) } const GD = new M("LEGACY_INTERCEPTOR_FN"); function ek() { return function ur(e, t) { return { \u0275kind: e, \u0275providers: t } }(Bn.LegacyInterceptors, [{ provide: GD, useFactory: UF }, { provide: ji, useExisting: GD, multi: !0 }]) } let tk = (() => { class e { static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275mod = _t({ type: e }); static #n = this.\u0275inj = at({ providers: [KF(ek())] }) } return e })(); const { isArray: uk } = Array, { getPrototypeOf: ck, prototype: lk, keys: dk } = Object; function qD(e) { if (1 === e.length) { const t = e[0]; if (uk(t)) return { args: t, keys: null }; if (function fk(e) { return e && "object" == typeof e && ck(e) === lk }(t)) { const n = dk(t); return { args: n.map(r => t[r]), keys: n } } } return { args: e, keys: null } } const { isArray: hk } = Array; function WD(e) { return Y(t => function pk(e, t) { return hk(t) ? e(...t) : e(t) }(e, t)) } function ZD(e, t) { return e.reduce((n, r, o) => (n[r] = t[o], n), {}) } function Df(...e) { const t = Ro(e), n = Fh(e), { args: r, keys: o } = qD(e); if (0 === r.length) return be([], t); const i = new me(function gk(e, t, n = En) { return r => { YD(t, () => { const { length: o } = e, i = new Array(o); let s = o, a = o; for (let u = 0; u < o; u++)YD(t, () => { const c = be(e[u], t); let l = !1; c.subscribe(Ce(r, d => { i[u] = d, l || (l = !0, a--), a || r.next(n(i.slice())) }, () => { --s || r.complete() })) }, r) }, r) } }(r, t, o ? s => ZD(o, s) : En)); return n ? i.pipe(WD(n)) : i } function YD(e, t, n) { e ? on(n, e, t) : t() } const su = No(e => function () { e(this), this.name = "EmptyError", this.message = "no elements in sequence" }); function wf(...e) { return function mk() { return mr(1) }()(be(e, Ro(e))) } function QD(e) { return new me(t => { it(e()).subscribe(t) }) } function yo(e, t) { const n = ne(e) ? e : () => e, r = o => o.error(n()); return new me(t ? o => t.schedule(r, 0, o) : r) } function bf() { return we((e, t) => { let n = null; e._refCount++; const r = Ce(t, void 0, void 0, void 0, () => { if (!e || e._refCount <= 0 || 0 < --e._refCount) return void (n = null); const o = e._connection, i = n; n = null, o && (!i || o === i) && o.unsubscribe(), t.unsubscribe() }); e.subscribe(r), r.closed || (n = e.connect()) }) } class XD extends me { constructor(t, n) { super(), this.source = t, this.subjectFactory = n, this._subject = null, this._refCount = 0, this._connection = null, Ch(t) && (this.lift = t.lift) } _subscribe(t) { return this.getSubject().subscribe(t) } getSubject() { const t = this._subject; return (!t || t.isStopped) && (this._subject = this.subjectFactory()), this._subject } _teardown() { this._refCount = 0; const { _connection: t } = this; this._subject = this._connection = null, t?.unsubscribe() } connect() { let t = this._connection; if (!t) { t = this._connection = new ot; const n = this.getSubject(); t.add(this.source.subscribe(Ce(n, void 0, () => { this._teardown(), n.complete() }, r => { this._teardown(), n.error(r) }, () => this._teardown()))), t.closed && (this._connection = null, t = ot.EMPTY) } return t } refCount() { return bf()(this) } } function _o(e) { return e <= 0 ? () => Ht : we((t, n) => { let r = 0; t.subscribe(Ce(n, o => { ++r <= e && (n.next(o), e <= r && n.complete()) })) }) } function au(e) { return we((t, n) => { let r = !1; t.subscribe(Ce(n, o => { r = !0, n.next(o) }, () => { r || n.next(e), n.complete() })) }) } function JD(e = yk) { return we((t, n) => { let r = !1; t.subscribe(Ce(n, o => { r = !0, n.next(o) }, () => r ? n.complete() : n.error(e()))) }) } function yk() { return new su } function cr(e, t) { const n = arguments.length >= 2; return r => r.pipe(e ? Dn((o, i) => e(o, i, r)) : En, _o(1), n ? au(t) : JD(() => new su)) } function je(e, t, n) { const r = ne(e) || t || n ? { next: e, error: t, complete: n } : e; return r ? we((o, i) => { var s; null === (s = r.subscribe) || void 0 === s || s.call(r); let a = !0; o.subscribe(Ce(i, u => { var c; null === (c = r.next) || void 0 === c || c.call(r, u), i.next(u) }, () => { var u; a = !1, null === (u = r.complete) || void 0 === u || u.call(r), i.complete() }, u => { var c; a = !1, null === (c = r.error) || void 0 === c || c.call(r, u), i.error(u) }, () => { var u, c; a && (null === (u = r.unsubscribe) || void 0 === u || u.call(r)), null === (c = r.finalize) || void 0 === c || c.call(r) })) }) : En } function jt(e) { return we((t, n) => { let i, r = null, o = !1; r = t.subscribe(Ce(n, void 0, void 0, s => { i = it(e(s, jt(e)(t))), r ? (r.unsubscribe(), r = null, i.subscribe(n)) : o = !0 })), o && (r.unsubscribe(), r = null, i.subscribe(n)) }) } function Ef(e) { return e <= 0 ? () => Ht : we((t, n) => { let r = []; t.subscribe(Ce(n, o => { r.push(o), e < r.length && r.shift() }, () => { for (const o of r) n.next(o); n.complete() }, void 0, () => { r = null })) }) } const H = "primary", Bi = Symbol("RouteTitle"); class Ek { constructor(t) { this.params = t || {} } has(t) { return Object.prototype.hasOwnProperty.call(this.params, t) } get(t) { if (this.has(t)) { const n = this.params[t]; return Array.isArray(n) ? n[0] : n } return null } getAll(t) { if (this.has(t)) { const n = this.params[t]; return Array.isArray(n) ? n : [n] } return [] } get keys() { return Object.keys(this.params) } } function Co(e) { return new Ek(e) } function Mk(e, t, n) { const r = n.path.split("/"); if (r.length > e.length || "full" === n.pathMatch && (t.hasChildren() || r.length < e.length)) return null; const o = {}; for (let i = 0; i < r.length; i++) { const s = r[i], a = e[i]; if (s.startsWith(":")) o[s.substring(1)] = a; else if (s !== a.path) return null } return { consumed: e.slice(0, r.length), posParams: o } } function en(e, t) { const n = e ? Object.keys(e) : void 0, r = t ? Object.keys(t) : void 0; if (!n || !r || n.length != r.length) return !1; let o; for (let i = 0; i < n.length; i++)if (o = n[i], !KD(e[o], t[o])) return !1; return !0 } function KD(e, t) { if (Array.isArray(e) && Array.isArray(t)) { if (e.length !== t.length) return !1; const n = [...e].sort(), r = [...t].sort(); return n.every((o, i) => r[i] === o) } return e === t } function ew(e) { return e.length > 0 ? e[e.length - 1] : null } function Hn(e) { return function ak(e) { return !!e && (e instanceof me || ne(e.lift) && ne(e.subscribe)) }(e) ? e : Di(e) ? be(Promise.resolve(e)) : P(e) } const Sk = { exact: function rw(e, t, n) { if (!lr(e.segments, t.segments) || !uu(e.segments, t.segments, n) || e.numberOfChildren !== t.numberOfChildren) return !1; for (const r in t.children) if (!e.children[r] || !rw(e.children[r], t.children[r], n)) return !1; return !0 }, subset: ow }, tw = { exact: function Ak(e, t) { return en(e, t) }, subset: function Tk(e, t) { return Object.keys(t).length <= Object.keys(e).length && Object.keys(t).every(n => KD(e[n], t[n])) }, ignored: () => !0 }; function nw(e, t, n) { return Sk[n.paths](e.root, t.root, n.matrixParams) && tw[n.queryParams](e.queryParams, t.queryParams) && !("exact" === n.fragment && e.fragment !== t.fragment) } function ow(e, t, n) { return iw(e, t, t.segments, n) } function iw(e, t, n, r) { if (e.segments.length > n.length) { const o = e.segments.slice(0, n.length); return !(!lr(o, n) || t.hasChildren() || !uu(o, n, r)) } if (e.segments.length === n.length) { if (!lr(e.segments, n) || !uu(e.segments, n, r)) return !1; for (const o in t.children) if (!e.children[o] || !ow(e.children[o], t.children[o], r)) return !1; return !0 } { const o = n.slice(0, e.segments.length), i = n.slice(e.segments.length); return !!(lr(e.segments, o) && uu(e.segments, o, r) && e.children[H]) && iw(e.children[H], t, i, r) } } function uu(e, t, n) { return t.every((r, o) => tw[n](e[o].parameters, r.parameters)) } class Do { constructor(t = new te([], {}), n = {}, r = null) { this.root = t, this.queryParams = n, this.fragment = r } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = Co(this.queryParams)), this._queryParamMap } toString() { return Pk.serialize(this) } } class te { constructor(t, n) { this.segments = t, this.children = n, this.parent = null, Object.values(n).forEach(r => r.parent = this) } hasChildren() { return this.numberOfChildren > 0 } get numberOfChildren() { return Object.keys(this.children).length } toString() { return cu(this) } } class Hi { constructor(t, n) { this.path = t, this.parameters = n } get parameterMap() { return this._parameterMap || (this._parameterMap = Co(this.parameters)), this._parameterMap } toString() { return uw(this) } } function lr(e, t) { return e.length === t.length && e.every((n, r) => n.path === t[r].path) } let $i = (() => { class e { static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275prov = T({ token: e, factory: function () { return new Mf }, providedIn: "root" }) } return e })(); class Mf { parse(t) { const n = new Uk(t); return new Do(n.parseRootSegment(), n.parseQueryParams(), n.parseFragment()) } serialize(t) { const n = `/${Ui(t.root, !0)}`, r = function Fk(e) { const t = Object.keys(e).map(n => { const r = e[n]; return Array.isArray(r) ? r.map(o => `${lu(n)}=${lu(o)}`).join("&") : `${lu(n)}=${lu(r)}` }).filter(n => !!n); return t.length ? `?${t.join("&")}` : "" }(t.queryParams); return `${n}${r}${"string" == typeof t.fragment ? `#${function xk(e) { return encodeURI(e) }(t.fragment)}` : ""}` } } const Pk = new Mf; function cu(e) { return e.segments.map(t => uw(t)).join("/") } function Ui(e, t) { if (!e.hasChildren()) return cu(e); if (t) { const n = e.children[H] ? Ui(e.children[H], !1) : "", r = []; return Object.entries(e.children).forEach(([o, i]) => { o !== H && r.push(`${o}:${Ui(i, !1)}`) }), r.length > 0 ? `${n}(${r.join("//")})` : n } { const n = function Nk(e, t) { let n = []; return Object.entries(e.children).forEach(([r, o]) => { r === H && (n = n.concat(t(o, r))) }), Object.entries(e.children).forEach(([r, o]) => { r !== H && (n = n.concat(t(o, r))) }), n }(e, (r, o) => o === H ? [Ui(e.children[H], !1)] : [`${o}:${Ui(r, !1)}`]); return 1 === Object.keys(e.children).length && null != e.children[H] ? `${cu(e)}/${n[0]}` : `${cu(e)}/(${n.join("//")})` } } function sw(e) { return encodeURIComponent(e).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",") } function lu(e) { return sw(e).replace(/%3B/gi, ";") } function If(e) { return sw(e).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&") } function du(e) { return decodeURIComponent(e) } function aw(e) { return du(e.replace(/\+/g, "%20")) } function uw(e) { return `${If(e.path)}${function Rk(e) { return Object.keys(e).map(t => `;${If(t)}=${If(e[t])}`).join("") }(e.parameters)}` } const kk = /^[^\/()?;#]+/; function Sf(e) { const t = e.match(kk); return t ? t[0] : "" } const Lk = /^[^\/()?;=#]+/, jk = /^[^=?&#]+/, Hk = /^[^&#]+/; class Uk { constructor(t) { this.url = t, this.remaining = t } parseRootSegment() { return this.consumeOptional("/"), "" === this.remaining || this.peekStartsWith("?") || this.peekStartsWith("#") ? new te([], {}) : new te([], this.parseChildren()) } parseQueryParams() { const t = {}; if (this.consumeOptional("?")) do { this.parseQueryParam(t) } while (this.consumeOptional("&")); return t } parseFragment() { return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null } parseChildren() { if ("" === this.remaining) return {}; this.consumeOptional("/"); const t = []; for (this.peekStartsWith("(") || t.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");)this.capture("/"), t.push(this.parseSegment()); let n = {}; this.peekStartsWith("/(") && (this.capture("/"), n = this.parseParens(!0)); let r = {}; return this.peekStartsWith("(") && (r = this.parseParens(!1)), (t.length > 0 || Object.keys(n).length > 0) && (r[H] = new te(t, n)), r } parseSegment() { const t = Sf(this.remaining); if ("" === t && this.peekStartsWith(";")) throw new C(4009, !1); return this.capture(t), new Hi(du(t), this.parseMatrixParams()) } parseMatrixParams() { const t = {}; for (; this.consumeOptional(";");)this.parseParam(t); return t } parseParam(t) { const n = function Vk(e) { const t = e.match(Lk); return t ? t[0] : "" }(this.remaining); if (!n) return; this.capture(n); let r = ""; if (this.consumeOptional("=")) { const o = Sf(this.remaining); o && (r = o, this.capture(r)) } t[du(n)] = du(r) } parseQueryParam(t) { const n = function Bk(e) { const t = e.match(jk); return t ? t[0] : "" }(this.remaining); if (!n) return; this.capture(n); let r = ""; if (this.consumeOptional("=")) { const s = function $k(e) { const t = e.match(Hk); return t ? t[0] : "" }(this.remaining); s && (r = s, this.capture(r)) } const o = aw(n), i = aw(r); if (t.hasOwnProperty(o)) { let s = t[o]; Array.isArray(s) || (s = [s], t[o] = s), s.push(i) } else t[o] = i } parseParens(t) { const n = {}; for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) { const r = Sf(this.remaining), o = this.remaining[r.length]; if ("/" !== o && ")" !== o && ";" !== o) throw new C(4010, !1); let i; r.indexOf(":") > -1 ? (i = r.slice(0, r.indexOf(":")), this.capture(i), this.capture(":")) : t && (i = H); const s = this.parseChildren(); n[i] = 1 === Object.keys(s).length ? s[H] : new te([], s), this.consumeOptional("//") } return n } peekStartsWith(t) { return this.remaining.startsWith(t) } consumeOptional(t) { return !!this.peekStartsWith(t) && (this.remaining = this.remaining.substring(t.length), !0) } capture(t) { if (!this.consumeOptional(t)) throw new C(4011, !1) } } function cw(e) { return e.segments.length > 0 ? new te([], { [H]: e }) : e } function lw(e) { const t = {}; for (const r of Object.keys(e.children)) { const i = lw(e.children[r]); if (r === H && 0 === i.segments.length && i.hasChildren()) for (const [s, a] of Object.entries(i.children)) t[s] = a; else (i.segments.length > 0 || i.hasChildren()) && (t[r] = i) } return function zk(e) { if (1 === e.numberOfChildren && e.children[H]) { const t = e.children[H]; return new te(e.segments.concat(t.segments), t.children) } return e }(new te(e.segments, t)) } function dr(e) { return e instanceof Do } function dw(e) { let t; const o = cw(function n(i) { const s = {}; for (const u of i.children) { const c = n(u); s[u.outlet] = c } const a = new te(i.url, s); return i === e && (t = a), a }(e.root)); return t ?? o } function fw(e, t, n, r) { let o = e; for (; o.parent;)o = o.parent; if (0 === t.length) return Af(o, o, o, n, r); const i = function qk(e) { if ("string" == typeof e[0] && 1 === e.length && "/" === e[0]) return new pw(!0, 0, e); let t = 0, n = !1; const r = e.reduce((o, i, s) => { if ("object" == typeof i && null != i) { if (i.outlets) { const a = {}; return Object.entries(i.outlets).forEach(([u, c]) => { a[u] = "string" == typeof c ? c.split("/") : c }), [...o, { outlets: a }] } if (i.segmentPath) return [...o, i.segmentPath] } return "string" != typeof i ? [...o, i] : 0 === s ? (i.split("/").forEach((a, u) => { 0 == u && "." === a || (0 == u && "" === a ? n = !0 : ".." === a ? t++ : "" != a && o.push(a)) }), o) : [...o, i] }, []); return new pw(n, t, r) }(t); if (i.toRoot()) return Af(o, o, new te([], {}), n, r); const s = function Wk(e, t, n) { if (e.isAbsolute) return new hu(t, !0, 0); if (!n) return new hu(t, !1, NaN); if (null === n.parent) return new hu(n, !0, 0); const r = fu(e.commands[0]) ? 0 : 1; return function Zk(e, t, n) { let r = e, o = t, i = n; for (; i > o;) { if (i -= o, r = r.parent, !r) throw new C(4005, !1); o = r.segments.length } return new hu(r, !1, o - i) }(n, n.segments.length - 1 + r, e.numberOfDoubleDots) }(i, o, e), a = s.processChildren ? Gi(s.segmentGroup, s.index, i.commands) : gw(s.segmentGroup, s.index, i.commands); return Af(o, s.segmentGroup, a, n, r) } function fu(e) { return "object" == typeof e && null != e && !e.outlets && !e.segmentPath } function zi(e) { return "object" == typeof e && null != e && e.outlets } function Af(e, t, n, r, o) { let s, i = {}; r && Object.entries(r).forEach(([u, c]) => { i[u] = Array.isArray(c) ? c.map(l => `${l}`) : `${c}` }), s = e === t ? n : hw(e, t, n); const a = cw(lw(s)); return new Do(a, i, o) } function hw(e, t, n) { const r = {}; return Object.entries(e.children).forEach(([o, i]) => { r[o] = i === t ? n : hw(i, t, n) }), new te(e.segments, r) } class pw { constructor(t, n, r) { if (this.isAbsolute = t, this.numberOfDoubleDots = n, this.commands = r, t && r.length > 0 && fu(r[0])) throw new C(4003, !1); const o = r.find(zi); if (o && o !== ew(r)) throw new C(4004, !1) } toRoot() { return this.isAbsolute && 1 === this.commands.length && "/" == this.commands[0] } } class hu { constructor(t, n, r) { this.segmentGroup = t, this.processChildren = n, this.index = r } } function gw(e, t, n) { if (e || (e = new te([], {})), 0 === e.segments.length && e.hasChildren()) return Gi(e, t, n); const r = function Qk(e, t, n) { let r = 0, o = t; const i = { match: !1, pathIndex: 0, commandIndex: 0 }; for (; o < e.segments.length;) { if (r >= n.length) return i; const s = e.segments[o], a = n[r]; if (zi(a)) break; const u = `${a}`, c = r < n.length - 1 ? n[r + 1] : null; if (o > 0 && void 0 === u) break; if (u && c && "object" == typeof c && void 0 === c.outlets) { if (!vw(u, c, s)) return i; r += 2 } else { if (!vw(u, {}, s)) return i; r++ } o++ } return { match: !0, pathIndex: o, commandIndex: r } }(e, t, n), o = n.slice(r.commandIndex); if (r.match && r.pathIndex < e.segments.length) { const i = new te(e.segments.slice(0, r.pathIndex), {}); return i.children[H] = new te(e.segments.slice(r.pathIndex), e.children), Gi(i, 0, o) } return r.match && 0 === o.length ? new te(e.segments, {}) : r.match && !e.hasChildren() ? Tf(e, t, n) : r.match ? Gi(e, 0, o) : Tf(e, t, n) } function Gi(e, t, n) { if (0 === n.length) return new te(e.segments, {}); { const r = function Yk(e) { return zi(e[0]) ? e[0].outlets : { [H]: e } }(n), o = {}; if (Object.keys(r).some(i => i !== H) && e.children[H] && 1 === e.numberOfChildren && 0 === e.children[H].segments.length) { const i = Gi(e.children[H], t, n); return new te(e.segments, i.children) } return Object.entries(r).forEach(([i, s]) => { "string" == typeof s && (s = [s]), null !== s && (o[i] = gw(e.children[i], t, s)) }), Object.entries(e.children).forEach(([i, s]) => { void 0 === r[i] && (o[i] = s) }), new te(e.segments, o) } } function Tf(e, t, n) { const r = e.segments.slice(0, t); let o = 0; for (; o < n.length;) { const i = n[o]; if (zi(i)) { const u = Xk(i.outlets); return new te(r, u) } if (0 === o && fu(n[0])) { r.push(new Hi(e.segments[t].path, mw(n[0]))), o++; continue } const s = zi(i) ? i.outlets[H] : `${i}`, a = o < n.length - 1 ? n[o + 1] : null; s && a && fu(a) ? (r.push(new Hi(s, mw(a))), o += 2) : (r.push(new Hi(s, {})), o++) } return new te(r, {}) } function Xk(e) { const t = {}; return Object.entries(e).forEach(([n, r]) => { "string" == typeof r && (r = [r]), null !== r && (t[n] = Tf(new te([], {}), 0, r)) }), t } function mw(e) { const t = {}; return Object.entries(e).forEach(([n, r]) => t[n] = `${r}`), t } function vw(e, t, n) { return e == n.path && en(t, n.parameters) } const qi = "imperative"; class tn { constructor(t, n) { this.id = t, this.url = n } } class pu extends tn { constructor(t, n, r = "imperative", o = null) { super(t, n), this.type = 0, this.navigationTrigger = r, this.restoredState = o } toString() { return `NavigationStart(id: ${this.id}, url: '${this.url}')` } } class $n extends tn { constructor(t, n, r) { super(t, n), this.urlAfterRedirects = r, this.type = 1 } toString() { return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')` } } class Wi extends tn { constructor(t, n, r, o) { super(t, n), this.reason = r, this.code = o, this.type = 2 } toString() { return `NavigationCancel(id: ${this.id}, url: '${this.url}')` } } class wo extends tn { constructor(t, n, r, o) { super(t, n), this.reason = r, this.code = o, this.type = 16 } } class gu extends tn { constructor(t, n, r, o) { super(t, n), this.error = r, this.target = o, this.type = 3 } toString() { return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})` } } class yw extends tn { constructor(t, n, r, o) { super(t, n), this.urlAfterRedirects = r, this.state = o, this.type = 4 } toString() { return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class Jk extends tn { constructor(t, n, r, o) { super(t, n), this.urlAfterRedirects = r, this.state = o, this.type = 7 } toString() { return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class Kk extends tn { constructor(t, n, r, o, i) { super(t, n), this.urlAfterRedirects = r, this.state = o, this.shouldActivate = i, this.type = 8 } toString() { return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})` } } class eL extends tn { constructor(t, n, r, o) { super(t, n), this.urlAfterRedirects = r, this.state = o, this.type = 5 } toString() { return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class tL extends tn { constructor(t, n, r, o) { super(t, n), this.urlAfterRedirects = r, this.state = o, this.type = 6 } toString() { return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class nL { constructor(t) { this.route = t, this.type = 9 } toString() { return `RouteConfigLoadStart(path: ${this.route.path})` } } class rL { constructor(t) { this.route = t, this.type = 10 } toString() { return `RouteConfigLoadEnd(path: ${this.route.path})` } } class oL { constructor(t) { this.snapshot = t, this.type = 11 } toString() { return `ChildActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class iL { constructor(t) { this.snapshot = t, this.type = 12 } toString() { return `ChildActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class sL { constructor(t) { this.snapshot = t, this.type = 13 } toString() { return `ActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class aL { constructor(t) { this.snapshot = t, this.type = 14 } toString() { return `ActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class _w { constructor(t, n, r) { this.routerEvent = t, this.position = n, this.anchor = r, this.type = 15 } toString() { return `Scroll(anchor: '${this.anchor}', position: '${this.position ? `${this.position[0]}, ${this.position[1]}` : null}')` } } class Of { } class Nf { constructor(t) { this.url = t } } class uL { constructor() { this.outlet = null, this.route = null, this.injector = null, this.children = new Zi, this.attachRef = null } } let Zi = (() => { class e { constructor() { this.contexts = new Map } onChildOutletCreated(n, r) { const o = this.getOrCreateContext(n); o.outlet = r, this.contexts.set(n, o) } onChildOutletDestroyed(n) { const r = this.getContext(n); r && (r.outlet = null, r.attachRef = null) } onOutletDeactivated() { const n = this.contexts; return this.contexts = new Map, n } onOutletReAttached(n) { this.contexts = n } getOrCreateContext(n) { let r = this.getContext(n); return r || (r = new uL, this.contexts.set(n, r)), r } getContext(n) { return this.contexts.get(n) || null } static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275prov = T({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); class Cw { constructor(t) { this._root = t } get root() { return this._root.value } parent(t) { const n = this.pathFromRoot(t); return n.length > 1 ? n[n.length - 2] : null } children(t) { const n = Pf(t, this._root); return n ? n.children.map(r => r.value) : [] } firstChild(t) { const n = Pf(t, this._root); return n && n.children.length > 0 ? n.children[0].value : null } siblings(t) { const n = xf(t, this._root); return n.length < 2 ? [] : n[n.length - 2].children.map(o => o.value).filter(o => o !== t) } pathFromRoot(t) { return xf(t, this._root).map(n => n.value) } } function Pf(e, t) { if (e === t.value) return t; for (const n of t.children) { const r = Pf(e, n); if (r) return r } return null } function xf(e, t) { if (e === t.value) return [t]; for (const n of t.children) { const r = xf(e, n); if (r.length) return r.unshift(t), r } return [] } class wn { constructor(t, n) { this.value = t, this.children = n } toString() { return `TreeNode(${this.value})` } } function bo(e) { const t = {}; return e && e.children.forEach(n => t[n.value.outlet] = n), t } class Dw extends Cw { constructor(t, n) { super(t), this.snapshot = n, Rf(this, t) } toString() { return this.snapshot.toString() } } function ww(e, t) { const n = function cL(e, t) { const s = new mu([], {}, {}, "", {}, H, t, null, {}); return new Ew("", new wn(s, [])) }(0, t), r = new vt([new Hi("", {})]), o = new vt({}), i = new vt({}), s = new vt({}), a = new vt(""), u = new Eo(r, o, s, a, i, H, t, n.root); return u.snapshot = n.root, new Dw(new wn(u, []), n) } class Eo { constructor(t, n, r, o, i, s, a, u) { this.urlSubject = t, this.paramsSubject = n, this.queryParamsSubject = r, this.fragmentSubject = o, this.dataSubject = i, this.outlet = s, this.component = a, this._futureSnapshot = u, this.title = this.dataSubject?.pipe(Y(c => c[Bi])) ?? P(void 0), this.url = t, this.params = n, this.queryParams = r, this.fragment = o, this.data = i } get routeConfig() { return this._futureSnapshot.routeConfig } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = this.params.pipe(Y(t => Co(t)))), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = this.queryParams.pipe(Y(t => Co(t)))), this._queryParamMap } toString() { return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})` } } function bw(e, t = "emptyOnly") { const n = e.pathFromRoot; let r = 0; if ("always" !== t) for (r = n.length - 1; r >= 1;) { const o = n[r], i = n[r - 1]; if (o.routeConfig && "" === o.routeConfig.path) r--; else { if (i.component) break; r-- } } return function lL(e) { return e.reduce((t, n) => ({ params: { ...t.params, ...n.params }, data: { ...t.data, ...n.data }, resolve: { ...n.data, ...t.resolve, ...n.routeConfig?.data, ...n._resolvedData } }), { params: {}, data: {}, resolve: {} }) }(n.slice(r)) } class mu { get title() { return this.data?.[Bi] } constructor(t, n, r, o, i, s, a, u, c) { this.url = t, this.params = n, this.queryParams = r, this.fragment = o, this.data = i, this.outlet = s, this.component = a, this.routeConfig = u, this._resolve = c } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = Co(this.params)), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = Co(this.queryParams)), this._queryParamMap } toString() { return `Route(url:'${this.url.map(r => r.toString()).join("/")}', path:'${this.routeConfig ? this.routeConfig.path : ""}')` } } class Ew extends Cw { constructor(t, n) { super(n), this.url = t, Rf(this, n) } toString() { return Mw(this._root) } } function Rf(e, t) { t.value._routerState = e, t.children.forEach(n => Rf(e, n)) } function Mw(e) { const t = e.children.length > 0 ? ` { ${e.children.map(Mw).join(", ")} } ` : ""; return `${e.value}${t}` } function Ff(e) { if (e.snapshot) { const t = e.snapshot, n = e._futureSnapshot; e.snapshot = n, en(t.queryParams, n.queryParams) || e.queryParamsSubject.next(n.queryParams), t.fragment !== n.fragment && e.fragmentSubject.next(n.fragment), en(t.params, n.params) || e.paramsSubject.next(n.params), function Ik(e, t) { if (e.length !== t.length) return !1; for (let n = 0; n < e.length; ++n)if (!en(e[n], t[n])) return !1; return !0 }(t.url, n.url) || e.urlSubject.next(n.url), en(t.data, n.data) || e.dataSubject.next(n.data) } else e.snapshot = e._futureSnapshot, e.dataSubject.next(e._futureSnapshot.data) } function kf(e, t) { const n = en(e.params, t.params) && function Ok(e, t) { return lr(e, t) && e.every((n, r) => en(n.parameters, t[r].parameters)) }(e.url, t.url); return n && !(!e.parent != !t.parent) && (!e.parent || kf(e.parent, t.parent)) } let Lf = (() => { class e { constructor() { this.activated = null, this._activatedRoute = null, this.name = H, this.activateEvents = new pe, this.deactivateEvents = new pe, this.attachEvents = new pe, this.detachEvents = new pe, this.parentContexts = b(Zi), this.location = b(kt), this.changeDetector = b(Va), this.environmentInjector = b(dt), this.inputBinder = b(vu, { optional: !0 }), this.supportsBindingToComponentInputs = !0 } get activatedComponentRef() { return this.activated } ngOnChanges(n) { if (n.name) { const { firstChange: r, previousValue: o } = n.name; if (r) return; this.isTrackedInParentContexts(o) && (this.deactivate(), this.parentContexts.onChildOutletDestroyed(o)), this.initializeOutletWithName() } } ngOnDestroy() { this.isTrackedInParentContexts(this.name) && this.parentContexts.onChildOutletDestroyed(this.name), this.inputBinder?.unsubscribeFromRouteData(this) } isTrackedInParentContexts(n) { return this.parentContexts.getContext(n)?.outlet === this } ngOnInit() { this.initializeOutletWithName() } initializeOutletWithName() { if (this.parentContexts.onChildOutletCreated(this.name, this), this.activated) return; const n = this.parentContexts.getContext(this.name); n?.route && (n.attachRef ? this.attach(n.attachRef, n.route) : this.activateWith(n.route, n.injector)) } get isActivated() { return !!this.activated } get component() { if (!this.activated) throw new C(4012, !1); return this.activated.instance } get activatedRoute() { if (!this.activated) throw new C(4012, !1); return this._activatedRoute } get activatedRouteData() { return this._activatedRoute ? this._activatedRoute.snapshot.data : {} } detach() { if (!this.activated) throw new C(4012, !1); this.location.detach(); const n = this.activated; return this.activated = null, this._activatedRoute = null, this.detachEvents.emit(n.instance), n } attach(n, r) { this.activated = n, this._activatedRoute = r, this.location.insert(n.hostView), this.inputBinder?.bindActivatedRouteToOutletComponent(this), this.attachEvents.emit(n.instance) } deactivate() { if (this.activated) { const n = this.component; this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(n) } } activateWith(n, r) { if (this.isActivated) throw new C(4013, !1); this._activatedRoute = n; const o = this.location, s = n.snapshot.component, a = this.parentContexts.getOrCreateContext(this.name).children, u = new dL(n, a, o.injector); this.activated = o.createComponent(s, { index: o.length, injector: u, environmentInjector: r ?? this.environmentInjector }), this.changeDetector.markForCheck(), this.inputBinder?.bindActivatedRouteToOutletComponent(this), this.activateEvents.emit(this.activated.instance) } static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275dir = k({ type: e, selectors: [["router-outlet"]], inputs: { name: "name" }, outputs: { activateEvents: "activate", deactivateEvents: "deactivate", attachEvents: "attach", detachEvents: "detach" }, exportAs: ["outlet"], standalone: !0, features: [Dt] }) } return e })(); class dL { constructor(t, n, r) { this.route = t, this.childContexts = n, this.parent = r } get(t, n) { return t === Eo ? this.route : t === Zi ? this.childContexts : this.parent.get(t, n) } } const vu = new M(""); let Iw = (() => { class e { constructor() { this.outletDataSubscriptions = new Map } bindActivatedRouteToOutletComponent(n) { this.unsubscribeFromRouteData(n), this.subscribeToRouteData(n) } unsubscribeFromRouteData(n) { this.outletDataSubscriptions.get(n)?.unsubscribe(), this.outletDataSubscriptions.delete(n) } subscribeToRouteData(n) { const { activatedRoute: r } = n, o = Df([r.queryParams, r.params, r.data]).pipe(Tt(([i, s, a], u) => (a = { ...i, ...s, ...a }, 0 === u ? P(a) : Promise.resolve(a)))).subscribe(i => { if (!n.isActivated || !n.activatedComponentRef || n.activatedRoute !== r || null === r.component) return void this.unsubscribeFromRouteData(n); const s = function cR(e) { const t = q(e); if (!t) return null; const n = new mi(t); return { get selector() { return n.selector }, get type() { return n.componentType }, get inputs() { return n.inputs }, get outputs() { return n.outputs }, get ngContentSelectors() { return n.ngContentSelectors }, get isStandalone() { return t.standalone }, get isSignal() { return t.signals } } }(r.component); if (s) for (const { templateName: a } of s.inputs) n.activatedComponentRef.setInput(a, i[a]); else this.unsubscribeFromRouteData(n) }); this.outletDataSubscriptions.set(n, o) } static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275prov = T({ token: e, factory: e.\u0275fac }) } return e })(); function Yi(e, t, n) { if (n && e.shouldReuseRoute(t.value, n.value.snapshot)) { const r = n.value; r._futureSnapshot = t.value; const o = function hL(e, t, n) { return t.children.map(r => { for (const o of n.children) if (e.shouldReuseRoute(r.value, o.value.snapshot)) return Yi(e, r, o); return Yi(e, r) }) }(e, t, n); return new wn(r, o) } { if (e.shouldAttach(t.value)) { const i = e.retrieve(t.value); if (null !== i) { const s = i.route; return s.value._futureSnapshot = t.value, s.children = t.children.map(a => Yi(e, a)), s } } const r = function pL(e) { return new Eo(new vt(e.url), new vt(e.params), new vt(e.queryParams), new vt(e.fragment), new vt(e.data), e.outlet, e.component, e) }(t.value), o = t.children.map(i => Yi(e, i)); return new wn(r, o) } } const Vf = "ngNavigationCancelingError"; function Sw(e, t) { const { redirectTo: n, navigationBehaviorOptions: r } = dr(t) ? { redirectTo: t, navigationBehaviorOptions: void 0 } : t, o = Aw(!1, 0, t); return o.url = n, o.navigationBehaviorOptions = r, o } function Aw(e, t, n) { const r = new Error("NavigationCancelingError: " + (e || "")); return r[Vf] = !0, r.cancellationCode = t, n && (r.url = n), r } function Tw(e) { return e && e[Vf] } let Ow = (() => { class e { static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275cmp = Ds({ type: e, selectors: [["ng-component"]], standalone: !0, features: [l_], decls: 1, vars: 0, template: function (r, o) { 1 & r && Ie(0, "router-outlet") }, dependencies: [Lf], encapsulation: 2 }) } return e })(); function jf(e) { const t = e.children && e.children.map(jf), n = t ? { ...e, children: t } : { ...e }; return !n.component && !n.loadComponent && (t || n.loadChildren) && n.outlet && n.outlet !== H && (n.component = Ow), n } function Bt(e) { return e.outlet || H } function Qi(e) { if (!e) return null; if (e.routeConfig?._injector) return e.routeConfig._injector; for (let t = e.parent; t; t = t.parent) { const n = t.routeConfig; if (n?._loadedInjector) return n._loadedInjector; if (n?._injector) return n._injector } return null } class wL { constructor(t, n, r, o, i) { this.routeReuseStrategy = t, this.futureState = n, this.currState = r, this.forwardEvent = o, this.inputBindingEnabled = i } activate(t) { const n = this.futureState._root, r = this.currState ? this.currState._root : null; this.deactivateChildRoutes(n, r, t), Ff(this.futureState.root), this.activateChildRoutes(n, r, t) } deactivateChildRoutes(t, n, r) { const o = bo(n); t.children.forEach(i => { const s = i.value.outlet; this.deactivateRoutes(i, o[s], r), delete o[s] }), Object.values(o).forEach(i => { this.deactivateRouteAndItsChildren(i, r) }) } deactivateRoutes(t, n, r) { const o = t.value, i = n ? n.value : null; if (o === i) if (o.component) { const s = r.getContext(o.outlet); s && this.deactivateChildRoutes(t, n, s.children) } else this.deactivateChildRoutes(t, n, r); else i && this.deactivateRouteAndItsChildren(n, r) } deactivateRouteAndItsChildren(t, n) { t.value.component && this.routeReuseStrategy.shouldDetach(t.value.snapshot) ? this.detachAndStoreRouteSubtree(t, n) : this.deactivateRouteAndOutlet(t, n) } detachAndStoreRouteSubtree(t, n) { const r = n.getContext(t.value.outlet), o = r && t.value.component ? r.children : n, i = bo(t); for (const s of Object.keys(i)) this.deactivateRouteAndItsChildren(i[s], o); if (r && r.outlet) { const s = r.outlet.detach(), a = r.children.onOutletDeactivated(); this.routeReuseStrategy.store(t.value.snapshot, { componentRef: s, route: t, contexts: a }) } } deactivateRouteAndOutlet(t, n) { const r = n.getContext(t.value.outlet), o = r && t.value.component ? r.children : n, i = bo(t); for (const s of Object.keys(i)) this.deactivateRouteAndItsChildren(i[s], o); r && (r.outlet && (r.outlet.deactivate(), r.children.onOutletDeactivated()), r.attachRef = null, r.route = null) } activateChildRoutes(t, n, r) { const o = bo(n); t.children.forEach(i => { this.activateRoutes(i, o[i.value.outlet], r), this.forwardEvent(new aL(i.value.snapshot)) }), t.children.length && this.forwardEvent(new iL(t.value.snapshot)) } activateRoutes(t, n, r) { const o = t.value, i = n ? n.value : null; if (Ff(o), o === i) if (o.component) { const s = r.getOrCreateContext(o.outlet); this.activateChildRoutes(t, n, s.children) } else this.activateChildRoutes(t, n, r); else if (o.component) { const s = r.getOrCreateContext(o.outlet); if (this.routeReuseStrategy.shouldAttach(o.snapshot)) { const a = this.routeReuseStrategy.retrieve(o.snapshot); this.routeReuseStrategy.store(o.snapshot, null), s.children.onOutletReAttached(a.contexts), s.attachRef = a.componentRef, s.route = a.route.value, s.outlet && s.outlet.attach(a.componentRef, a.route.value), Ff(a.route.value), this.activateChildRoutes(t, null, s.children) } else { const a = Qi(o.snapshot); s.attachRef = null, s.route = o, s.injector = a, s.outlet && s.outlet.activateWith(o, s.injector), this.activateChildRoutes(t, null, s.children) } } else this.activateChildRoutes(t, null, r) } } class Nw { constructor(t) { this.path = t, this.route = this.path[this.path.length - 1] } } class yu { constructor(t, n) { this.component = t, this.route = n } } function bL(e, t, n) { const r = e._root; return Xi(r, t ? t._root : null, n, [r.value]) } function Mo(e, t) { const n = Symbol(), r = t.get(e, n); return r === n ? "function" != typeof e || function hM(e) { return null !== ps(e) }(e) ? t.get(e) : e : r } function Xi(e, t, n, r, o = { canDeactivateChecks: [], canActivateChecks: [] }) { const i = bo(t); return e.children.forEach(s => { (function ML(e, t, n, r, o = { canDeactivateChecks: [], canActivateChecks: [] }) { const i = e.value, s = t ? t.value : null, a = n ? n.getContext(e.value.outlet) : null; if (s && i.routeConfig === s.routeConfig) { const u = function IL(e, t, n) { if ("function" == typeof n) return n(e, t); switch (n) { case "pathParamsChange": return !lr(e.url, t.url); case "pathParamsOrQueryParamsChange": return !lr(e.url, t.url) || !en(e.queryParams, t.queryParams); case "always": return !0; case "paramsOrQueryParamsChange": return !kf(e, t) || !en(e.queryParams, t.queryParams); default: return !kf(e, t) } }(s, i, i.routeConfig.runGuardsAndResolvers); u ? o.canActivateChecks.push(new Nw(r)) : (i.data = s.data, i._resolvedData = s._resolvedData), Xi(e, t, i.component ? a ? a.children : null : n, r, o), u && a && a.outlet && a.outlet.isActivated && o.canDeactivateChecks.push(new yu(a.outlet.component, s)) } else s && Ji(t, a, o), o.canActivateChecks.push(new Nw(r)), Xi(e, null, i.component ? a ? a.children : null : n, r, o) })(s, i[s.value.outlet], n, r.concat([s.value]), o), delete i[s.value.outlet] }), Object.entries(i).forEach(([s, a]) => Ji(a, n.getContext(s), o)), o } function Ji(e, t, n) { const r = bo(e), o = e.value; Object.entries(r).forEach(([i, s]) => { Ji(s, o.component ? t ? t.children.getContext(i) : null : t, n) }), n.canDeactivateChecks.push(new yu(o.component && t && t.outlet && t.outlet.isActivated ? t.outlet.component : null, o)) } function Ki(e) { return "function" == typeof e } function Pw(e) { return e instanceof su || "EmptyError" === e?.name } const _u = Symbol("INITIAL_VALUE"); function Io() { return Tt(e => Df(e.map(t => t.pipe(_o(1), function vk(...e) { const t = Ro(e); return we((n, r) => { (t ? wf(e, n, t) : wf(e, n)).subscribe(r) }) }(_u)))).pipe(Y(t => { for (const n of t) if (!0 !== n) { if (n === _u) return _u; if (!1 === n || n instanceof Do) return n } return !0 }), Dn(t => t !== _u), _o(1))) } function xw(e) { return function gE(...e) { return vh(e) }(je(t => { if (dr(t)) throw Sw(0, t) }), Y(t => !0 === t)) } class Cu { constructor(t) { this.segmentGroup = t || null } } class Rw { constructor(t) { this.urlTree = t } } function So(e) { return yo(new Cu(e)) } function Fw(e) { return yo(new Rw(e)) } class qL { constructor(t, n) { this.urlSerializer = t, this.urlTree = n } noMatchError(t) { return new C(4002, !1) } lineralizeSegments(t, n) { let r = [], o = n.root; for (; ;) { if (r = r.concat(o.segments), 0 === o.numberOfChildren) return P(r); if (o.numberOfChildren > 1 || !o.children[H]) return yo(new C(4e3, !1)); o = o.children[H] } } applyRedirectCommands(t, n, r) { return this.applyRedirectCreateUrlTree(n, this.urlSerializer.parse(n), t, r) } applyRedirectCreateUrlTree(t, n, r, o) { const i = this.createSegmentGroup(t, n.root, r, o); return new Do(i, this.createQueryParams(n.queryParams, this.urlTree.queryParams), n.fragment) } createQueryParams(t, n) { const r = {}; return Object.entries(t).forEach(([o, i]) => { if ("string" == typeof i && i.startsWith(":")) { const a = i.substring(1); r[o] = n[a] } else r[o] = i }), r } createSegmentGroup(t, n, r, o) { const i = this.createSegments(t, n.segments, r, o); let s = {}; return Object.entries(n.children).forEach(([a, u]) => { s[a] = this.createSegmentGroup(t, u, r, o) }), new te(i, s) } createSegments(t, n, r, o) { return n.map(i => i.path.startsWith(":") ? this.findPosParam(t, i, o) : this.findOrReturn(i, r)) } findPosParam(t, n, r) { const o = r[n.path.substring(1)]; if (!o) throw new C(4001, !1); return o } findOrReturn(t, n) { let r = 0; for (const o of n) { if (o.path === t.path) return n.splice(r), o; r++ } return t } } const Bf = { matched: !1, consumedSegments: [], remainingSegments: [], parameters: {}, positionalParamSegments: {} }; function WL(e, t, n, r, o) { const i = Hf(e, t, n); return i.matched ? (r = function mL(e, t) { return e.providers && !e._injector && (e._injector = fd(e.providers, t, `Route: ${e.path}`)), e._injector ?? t }(t, r), function UL(e, t, n, r) { const o = t.canMatch; return o && 0 !== o.length ? P(o.map(s => { const a = Mo(s, e); return Hn(function PL(e) { return e && Ki(e.canMatch) }(a) ? a.canMatch(t, n) : e.runInContext(() => a(t, n))) })).pipe(Io(), xw()) : P(!0) }(r, t, n).pipe(Y(s => !0 === s ? i : { ...Bf }))) : P(i) } function Hf(e, t, n) { if ("" === t.path) return "full" === t.pathMatch && (e.hasChildren() || n.length > 0) ? { ...Bf } : { matched: !0, consumedSegments: [], remainingSegments: n, parameters: {}, positionalParamSegments: {} }; const o = (t.matcher || Mk)(n, e, t); if (!o) return { ...Bf }; const i = {}; Object.entries(o.posParams ?? {}).forEach(([a, u]) => { i[a] = u.path }); const s = o.consumed.length > 0 ? { ...i, ...o.consumed[o.consumed.length - 1].parameters } : i; return { matched: !0, consumedSegments: o.consumed, remainingSegments: n.slice(o.consumed.length), parameters: s, positionalParamSegments: o.posParams ?? {} } } function kw(e, t, n, r) { return n.length > 0 && function QL(e, t, n) { return n.some(r => Du(e, t, r) && Bt(r) !== H) }(e, n, r) ? { segmentGroup: new te(t, YL(r, new te(n, e.children))), slicedSegments: [] } : 0 === n.length && function XL(e, t, n) { return n.some(r => Du(e, t, r)) }(e, n, r) ? { segmentGroup: new te(e.segments, ZL(e, 0, n, r, e.children)), slicedSegments: n } : { segmentGroup: new te(e.segments, e.children), slicedSegments: n } } function ZL(e, t, n, r, o) { const i = {}; for (const s of r) if (Du(e, n, s) && !o[Bt(s)]) { const a = new te([], {}); i[Bt(s)] = a } return { ...o, ...i } } function YL(e, t) { const n = {}; n[H] = t; for (const r of e) if ("" === r.path && Bt(r) !== H) { const o = new te([], {}); n[Bt(r)] = o } return n } function Du(e, t, n) { return (!(e.hasChildren() || t.length > 0) || "full" !== n.pathMatch) && "" === n.path } class tV { constructor(t, n, r, o, i, s, a) { this.injector = t, this.configLoader = n, this.rootComponentType = r, this.config = o, this.urlTree = i, this.paramsInheritanceStrategy = s, this.urlSerializer = a, this.allowRedirects = !0, this.applyRedirects = new qL(this.urlSerializer, this.urlTree) } noMatchError(t) { return new C(4002, !1) } recognize() { const t = kw(this.urlTree.root, [], [], this.config).segmentGroup; return this.processSegmentGroup(this.injector, this.config, t, H).pipe(jt(n => { if (n instanceof Rw) return this.allowRedirects = !1, this.urlTree = n.urlTree, this.match(n.urlTree); throw n instanceof Cu ? this.noMatchError(n) : n }), Y(n => { const r = new mu([], Object.freeze({}), Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, {}, H, this.rootComponentType, null, {}), o = new wn(r, n), i = new Ew("", o), s = function Gk(e, t, n = null, r = null) { return fw(dw(e), t, n, r) }(r, [], this.urlTree.queryParams, this.urlTree.fragment); return s.queryParams = this.urlTree.queryParams, i.url = this.urlSerializer.serialize(s), this.inheritParamsAndData(i._root), { state: i, tree: s } })) } match(t) { return this.processSegmentGroup(this.injector, this.config, t.root, H).pipe(jt(r => { throw r instanceof Cu ? this.noMatchError(r) : r })) } inheritParamsAndData(t) { const n = t.value, r = bw(n, this.paramsInheritanceStrategy); n.params = Object.freeze(r.params), n.data = Object.freeze(r.data), t.children.forEach(o => this.inheritParamsAndData(o)) } processSegmentGroup(t, n, r, o) { return 0 === r.segments.length && r.hasChildren() ? this.processChildren(t, n, r) : this.processSegment(t, n, r, r.segments, o, !0) } processChildren(t, n, r) { const o = []; for (const i of Object.keys(r.children)) "primary" === i ? o.unshift(i) : o.push(i); return be(o).pipe(go(i => { const s = r.children[i], a = function CL(e, t) { const n = e.filter(r => Bt(r) === t); return n.push(...e.filter(r => Bt(r) !== t)), n }(n, i); return this.processSegmentGroup(t, a, s, i) }), function Ck(e, t) { return we(function _k(e, t, n, r, o) { return (i, s) => { let a = n, u = t, c = 0; i.subscribe(Ce(s, l => { const d = c++; u = a ? e(u, l, d) : (a = !0, l), r && s.next(u) }, o && (() => { a && s.next(u), s.complete() }))) } }(e, t, arguments.length >= 2, !0)) }((i, s) => (i.push(...s), i)), au(null), function Dk(e, t) { const n = arguments.length >= 2; return r => r.pipe(e ? Dn((o, i) => e(o, i, r)) : En, Ef(1), n ? au(t) : JD(() => new su)) }(), Te(i => { if (null === i) return So(r); const s = Lw(i); return function nV(e) { e.sort((t, n) => t.value.outlet === H ? -1 : n.value.outlet === H ? 1 : t.value.outlet.localeCompare(n.value.outlet)) }(s), P(s) })) } processSegment(t, n, r, o, i, s) { return be(n).pipe(go(a => this.processSegmentAgainstRoute(a._injector ?? t, n, a, r, o, i, s).pipe(jt(u => { if (u instanceof Cu) return P(null); throw u }))), cr(a => !!a), jt(a => { if (Pw(a)) return function KL(e, t, n) { return 0 === t.length && !e.children[n] }(r, o, i) ? P([]) : So(r); throw a })) } processSegmentAgainstRoute(t, n, r, o, i, s, a) { return function JL(e, t, n, r) { return !!(Bt(e) === r || r !== H && Du(t, n, e)) && ("**" === e.path || Hf(t, e, n).matched) }(r, o, i, s) ? void 0 === r.redirectTo ? this.matchSegmentAgainstRoute(t, o, r, i, s, a) : a && this.allowRedirects ? this.expandSegmentAgainstRouteUsingRedirect(t, o, n, r, i, s) : So(o) : So(o) } expandSegmentAgainstRouteUsingRedirect(t, n, r, o, i, s) { return "**" === o.path ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(t, r, o, s) : this.expandRegularSegmentAgainstRouteUsingRedirect(t, n, r, o, i, s) } expandWildCardWithParamsAgainstRouteUsingRedirect(t, n, r, o) { const i = this.applyRedirects.applyRedirectCommands([], r.redirectTo, {}); return r.redirectTo.startsWith("/") ? Fw(i) : this.applyRedirects.lineralizeSegments(r, i).pipe(Te(s => { const a = new te(s, {}); return this.processSegment(t, n, a, s, o, !1) })) } expandRegularSegmentAgainstRouteUsingRedirect(t, n, r, o, i, s) { const { matched: a, consumedSegments: u, remainingSegments: c, positionalParamSegments: l } = Hf(n, o, i); if (!a) return So(n); const d = this.applyRedirects.applyRedirectCommands(u, o.redirectTo, l); return o.redirectTo.startsWith("/") ? Fw(d) : this.applyRedirects.lineralizeSegments(o, d).pipe(Te(f => this.processSegment(t, r, n, f.concat(c), s, !1))) } matchSegmentAgainstRoute(t, n, r, o, i, s) { let a; if ("**" === r.path) { const u = o.length > 0 ? ew(o).parameters : {}; a = P({ snapshot: new mu(o, u, Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, Vw(r), Bt(r), r.component ?? r._loadedComponent ?? null, r, jw(r)), consumedSegments: [], remainingSegments: [] }), n.children = {} } else a = WL(n, r, o, t).pipe(Y(({ matched: u, consumedSegments: c, remainingSegments: l, parameters: d }) => u ? { snapshot: new mu(c, d, Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, Vw(r), Bt(r), r.component ?? r._loadedComponent ?? null, r, jw(r)), consumedSegments: c, remainingSegments: l } : null)); return a.pipe(Tt(u => null === u ? So(n) : this.getChildConfig(t = r._injector ?? t, r, o).pipe(Tt(({ routes: c }) => { const l = r._loadedInjector ?? t, { snapshot: d, consumedSegments: f, remainingSegments: h } = u, { segmentGroup: p, slicedSegments: g } = kw(n, f, h, c); if (0 === g.length && p.hasChildren()) return this.processChildren(l, c, p).pipe(Y(_ => null === _ ? null : [new wn(d, _)])); if (0 === c.length && 0 === g.length) return P([new wn(d, [])]); const v = Bt(r) === i; return this.processSegment(l, c, p, g, v ? H : i, !0).pipe(Y(_ => [new wn(d, _)])) })))) } getChildConfig(t, n, r) { return n.children ? P({ routes: n.children, injector: t }) : n.loadChildren ? void 0 !== n._loadedRoutes ? P({ routes: n._loadedRoutes, injector: n._loadedInjector }) : function $L(e, t, n, r) { const o = t.canLoad; return void 0 === o || 0 === o.length ? P(!0) : P(o.map(s => { const a = Mo(s, e); return Hn(function AL(e) { return e && Ki(e.canLoad) }(a) ? a.canLoad(t, n) : e.runInContext(() => a(t, n))) })).pipe(Io(), xw()) }(t, n, r).pipe(Te(o => o ? this.configLoader.loadChildren(t, n).pipe(je(i => { n._loadedRoutes = i.routes, n._loadedInjector = i.injector })) : function GL(e) { return yo(Aw(!1, 3)) }())) : P({ routes: [], injector: t }) } } function rV(e) { const t = e.value.routeConfig; return t && "" === t.path } function Lw(e) { const t = [], n = new Set; for (const r of e) { if (!rV(r)) { t.push(r); continue } const o = t.find(i => r.value.routeConfig === i.value.routeConfig); void 0 !== o ? (o.children.push(...r.children), n.add(o)) : t.push(r) } for (const r of n) { const o = Lw(r.children); t.push(new wn(r.value, o)) } return t.filter(r => !n.has(r)) } function Vw(e) { return e.data || {} } function jw(e) { return e.resolve || {} } function Bw(e) { return "string" == typeof e.title || null === e.title } function $f(e) { return Tt(t => { const n = e(t); return n ? be(n).pipe(Y(() => t)) : P(t) }) } const Ao = new M("ROUTES"); let Uf = (() => { class e { constructor() { this.componentLoaders = new WeakMap, this.childrenLoaders = new WeakMap, this.compiler = b(nC) } loadComponent(n) { if (this.componentLoaders.get(n)) return this.componentLoaders.get(n); if (n._loadedComponent) return P(n._loadedComponent); this.onLoadStartListener && this.onLoadStartListener(n); const r = Hn(n.loadComponent()).pipe(Y(Hw), je(i => { this.onLoadEndListener && this.onLoadEndListener(n), n._loadedComponent = i }), Li(() => { this.componentLoaders.delete(n) })), o = new XD(r, () => new At).pipe(bf()); return this.componentLoaders.set(n, o), o } loadChildren(n, r) { if (this.childrenLoaders.get(r)) return this.childrenLoaders.get(r); if (r._loadedRoutes) return P({ routes: r._loadedRoutes, injector: r._loadedInjector }); this.onLoadStartListener && this.onLoadStartListener(r); const i = function lV(e, t, n, r) { return Hn(e.loadChildren()).pipe(Y(Hw), Te(o => o instanceof u_ || Array.isArray(o) ? P(o) : be(t.compileModuleAsync(o))), Y(o => { r && r(e); let i, s, a = !1; return Array.isArray(o) ? (s = o, !0) : (i = o.create(n).injector, s = i.get(Ao, [], { optional: !0, self: !0 }).flat()), { routes: s.map(jf), injector: i } })) }(r, this.compiler, n, this.onLoadEndListener).pipe(Li(() => { this.childrenLoaders.delete(r) })), s = new XD(i, () => new At).pipe(bf()); return this.childrenLoaders.set(r, s), s } static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275prov = T({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); function Hw(e) { return function dV(e) { return e && "object" == typeof e && "default" in e }(e) ? e.default : e } let wu = (() => { class e { get hasRequestedNavigation() { return 0 !== this.navigationId } constructor() { this.currentNavigation = null, this.currentTransition = null, this.lastSuccessfulNavigation = null, this.events = new At, this.transitionAbortSubject = new At, this.configLoader = b(Uf), this.environmentInjector = b(dt), this.urlSerializer = b($i), this.rootContexts = b(Zi), this.inputBindingEnabled = null !== b(vu, { optional: !0 }), this.navigationId = 0, this.afterPreactivation = () => P(void 0), this.rootComponentType = null, this.configLoader.onLoadEndListener = o => this.events.next(new rL(o)), this.configLoader.onLoadStartListener = o => this.events.next(new nL(o)) } complete() { this.transitions?.complete() } handleNavigationRequest(n) { const r = ++this.navigationId; this.transitions?.next({ ...this.transitions.value, ...n, id: r }) } setupNavigations(n, r, o) { return this.transitions = new vt({ id: 0, currentUrlTree: r, currentRawUrl: r, currentBrowserUrl: r, extractedUrl: n.urlHandlingStrategy.extract(r), urlAfterRedirects: n.urlHandlingStrategy.extract(r), rawUrl: r, extras: {}, resolve: null, reject: null, promise: Promise.resolve(!0), source: qi, restoredState: null, currentSnapshot: o.snapshot, targetSnapshot: null, currentRouterState: o, targetRouterState: null, guards: { canActivateChecks: [], canDeactivateChecks: [] }, guardsResult: null }), this.transitions.pipe(Dn(i => 0 !== i.id), Y(i => ({ ...i, extractedUrl: n.urlHandlingStrategy.extract(i.rawUrl) })), Tt(i => { this.currentTransition = i; let s = !1, a = !1; return P(i).pipe(je(u => { this.currentNavigation = { id: u.id, initialUrl: u.rawUrl, extractedUrl: u.extractedUrl, trigger: u.source, extras: u.extras, previousNavigation: this.lastSuccessfulNavigation ? { ...this.lastSuccessfulNavigation, previousNavigation: null } : null } }), Tt(u => { const c = u.currentBrowserUrl.toString(), l = !n.navigated || u.extractedUrl.toString() !== c || c !== u.currentUrlTree.toString(); if (!l && "reload" !== (u.extras.onSameUrlNavigation ?? n.onSameUrlNavigation)) { const f = ""; return this.events.next(new wo(u.id, this.urlSerializer.serialize(u.rawUrl), f, 0)), u.resolve(null), Ht } if (n.urlHandlingStrategy.shouldProcessUrl(u.rawUrl)) return P(u).pipe(Tt(f => { const h = this.transitions?.getValue(); return this.events.next(new pu(f.id, this.urlSerializer.serialize(f.extractedUrl), f.source, f.restoredState)), h !== this.transitions?.getValue() ? Ht : Promise.resolve(f) }), function oV(e, t, n, r, o, i) { return Te(s => function eV(e, t, n, r, o, i, s = "emptyOnly") { return new tV(e, t, n, r, o, s, i).recognize() }(e, t, n, r, s.extractedUrl, o, i).pipe(Y(({ state: a, tree: u }) => ({ ...s, targetSnapshot: a, urlAfterRedirects: u })))) }(this.environmentInjector, this.configLoader, this.rootComponentType, n.config, this.urlSerializer, n.paramsInheritanceStrategy), je(f => { i.targetSnapshot = f.targetSnapshot, i.urlAfterRedirects = f.urlAfterRedirects, this.currentNavigation = { ...this.currentNavigation, finalUrl: f.urlAfterRedirects }; const h = new yw(f.id, this.urlSerializer.serialize(f.extractedUrl), this.urlSerializer.serialize(f.urlAfterRedirects), f.targetSnapshot); this.events.next(h) })); if (l && n.urlHandlingStrategy.shouldProcessUrl(u.currentRawUrl)) { const { id: f, extractedUrl: h, source: p, restoredState: g, extras: v } = u, _ = new pu(f, this.urlSerializer.serialize(h), p, g); this.events.next(_); const m = ww(0, this.rootComponentType).snapshot; return this.currentTransition = i = { ...u, targetSnapshot: m, urlAfterRedirects: h, extras: { ...v, skipLocationChange: !1, replaceUrl: !1 } }, P(i) } { const f = ""; return this.events.next(new wo(u.id, this.urlSerializer.serialize(u.extractedUrl), f, 1)), u.resolve(null), Ht } }), je(u => { const c = new Jk(u.id, this.urlSerializer.serialize(u.extractedUrl), this.urlSerializer.serialize(u.urlAfterRedirects), u.targetSnapshot); this.events.next(c) }), Y(u => (this.currentTransition = i = { ...u, guards: bL(u.targetSnapshot, u.currentSnapshot, this.rootContexts) }, i)), function RL(e, t) { return Te(n => { const { targetSnapshot: r, currentSnapshot: o, guards: { canActivateChecks: i, canDeactivateChecks: s } } = n; return 0 === s.length && 0 === i.length ? P({ ...n, guardsResult: !0 }) : function FL(e, t, n, r) { return be(e).pipe(Te(o => function HL(e, t, n, r, o) { const i = t && t.routeConfig ? t.routeConfig.canDeactivate : null; return i && 0 !== i.length ? P(i.map(a => { const u = Qi(t) ?? o, c = Mo(a, u); return Hn(function NL(e) { return e && Ki(e.canDeactivate) }(c) ? c.canDeactivate(e, t, n, r) : u.runInContext(() => c(e, t, n, r))).pipe(cr()) })).pipe(Io()) : P(!0) }(o.component, o.route, n, t, r)), cr(o => !0 !== o, !0)) }(s, r, o, e).pipe(Te(a => a && function SL(e) { return "boolean" == typeof e }(a) ? function kL(e, t, n, r) { return be(t).pipe(go(o => wf(function VL(e, t) { return null !== e && t && t(new oL(e)), P(!0) }(o.route.parent, r), function LL(e, t) { return null !== e && t && t(new sL(e)), P(!0) }(o.route, r), function BL(e, t, n) { const r = t[t.length - 1], i = t.slice(0, t.length - 1).reverse().map(s => function EL(e) { const t = e.routeConfig ? e.routeConfig.canActivateChild : null; return t && 0 !== t.length ? { node: e, guards: t } : null }(s)).filter(s => null !== s).map(s => QD(() => P(s.guards.map(u => { const c = Qi(s.node) ?? n, l = Mo(u, c); return Hn(function OL(e) { return e && Ki(e.canActivateChild) }(l) ? l.canActivateChild(r, e) : c.runInContext(() => l(r, e))).pipe(cr()) })).pipe(Io()))); return P(i).pipe(Io()) }(e, o.path, n), function jL(e, t, n) { const r = t.routeConfig ? t.routeConfig.canActivate : null; if (!r || 0 === r.length) return P(!0); const o = r.map(i => QD(() => { const s = Qi(t) ?? n, a = Mo(i, s); return Hn(function TL(e) { return e && Ki(e.canActivate) }(a) ? a.canActivate(t, e) : s.runInContext(() => a(t, e))).pipe(cr()) })); return P(o).pipe(Io()) }(e, o.route, n))), cr(o => !0 !== o, !0)) }(r, i, e, t) : P(a)), Y(a => ({ ...n, guardsResult: a }))) }) }(this.environmentInjector, u => this.events.next(u)), je(u => { if (i.guardsResult = u.guardsResult, dr(u.guardsResult)) throw Sw(0, u.guardsResult); const c = new Kk(u.id, this.urlSerializer.serialize(u.extractedUrl), this.urlSerializer.serialize(u.urlAfterRedirects), u.targetSnapshot, !!u.guardsResult); this.events.next(c) }), Dn(u => !!u.guardsResult || (this.cancelNavigationTransition(u, "", 3), !1)), $f(u => { if (u.guards.canActivateChecks.length) return P(u).pipe(je(c => { const l = new eL(c.id, this.urlSerializer.serialize(c.extractedUrl), this.urlSerializer.serialize(c.urlAfterRedirects), c.targetSnapshot); this.events.next(l) }), Tt(c => { let l = !1; return P(c).pipe(function iV(e, t) { return Te(n => { const { targetSnapshot: r, guards: { canActivateChecks: o } } = n; if (!o.length) return P(n); let i = 0; return be(o).pipe(go(s => function sV(e, t, n, r) { const o = e.routeConfig, i = e._resolve; return void 0 !== o?.title && !Bw(o) && (i[Bi] = o.title), function aV(e, t, n, r) { const o = function uV(e) { return [...Object.keys(e), ...Object.getOwnPropertySymbols(e)] }(e); if (0 === o.length) return P({}); const i = {}; return be(o).pipe(Te(s => function cV(e, t, n, r) { const o = Qi(t) ?? r, i = Mo(e, o); return Hn(i.resolve ? i.resolve(t, n) : o.runInContext(() => i(t, n))) }(e[s], t, n, r).pipe(cr(), je(a => { i[s] = a }))), Ef(1), function wk(e) { return Y(() => e) }(i), jt(s => Pw(s) ? Ht : yo(s))) }(i, e, t, r).pipe(Y(s => (e._resolvedData = s, e.data = bw(e, n).resolve, o && Bw(o) && (e.data[Bi] = o.title), null))) }(s.route, r, e, t)), je(() => i++), Ef(1), Te(s => i === o.length ? P(n) : Ht)) }) }(n.paramsInheritanceStrategy, this.environmentInjector), je({ next: () => l = !0, complete: () => { l || this.cancelNavigationTransition(c, "", 2) } })) }), je(c => { const l = new tL(c.id, this.urlSerializer.serialize(c.extractedUrl), this.urlSerializer.serialize(c.urlAfterRedirects), c.targetSnapshot); this.events.next(l) })) }), $f(u => { const c = l => { const d = []; l.routeConfig?.loadComponent && !l.routeConfig._loadedComponent && d.push(this.configLoader.loadComponent(l.routeConfig).pipe(je(f => { l.component = f }), Y(() => { }))); for (const f of l.children) d.push(...c(f)); return d }; return Df(c(u.targetSnapshot.root)).pipe(au(), _o(1)) }), $f(() => this.afterPreactivation()), Y(u => { const c = function fL(e, t, n) { const r = Yi(e, t._root, n ? n._root : void 0); return new Dw(r, t) }(n.routeReuseStrategy, u.targetSnapshot, u.currentRouterState); return this.currentTransition = i = { ...u, targetRouterState: c }, i }), je(() => { this.events.next(new Of) }), ((e, t, n, r) => Y(o => (new wL(t, o.targetRouterState, o.currentRouterState, n, r).activate(e), o)))(this.rootContexts, n.routeReuseStrategy, u => this.events.next(u), this.inputBindingEnabled), _o(1), je({ next: u => { s = !0, this.lastSuccessfulNavigation = this.currentNavigation, this.events.next(new $n(u.id, this.urlSerializer.serialize(u.extractedUrl), this.urlSerializer.serialize(u.urlAfterRedirects))), n.titleStrategy?.updateTitle(u.targetRouterState.snapshot), u.resolve(!0) }, complete: () => { s = !0 } }), function bk(e) { return we((t, n) => { it(e).subscribe(Ce(n, () => n.complete(), Vu)), !n.closed && t.subscribe(n) }) }(this.transitionAbortSubject.pipe(je(u => { throw u }))), Li(() => { s || a || this.cancelNavigationTransition(i, "", 1), this.currentNavigation?.id === i.id && (this.currentNavigation = null) }), jt(u => { if (a = !0, Tw(u)) this.events.next(new Wi(i.id, this.urlSerializer.serialize(i.extractedUrl), u.message, u.cancellationCode)), function gL(e) { return Tw(e) && dr(e.url) }(u) ? this.events.next(new Nf(u.url)) : i.resolve(!1); else { this.events.next(new gu(i.id, this.urlSerializer.serialize(i.extractedUrl), u, i.targetSnapshot ?? void 0)); try { i.resolve(n.errorHandler(u)) } catch (c) { i.reject(c) } } return Ht })) })) } cancelNavigationTransition(n, r, o) { const i = new Wi(n.id, this.urlSerializer.serialize(n.extractedUrl), r, o); this.events.next(i), n.resolve(!1) } static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275prov = T({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); function $w(e) { return e !== qi } let Uw = (() => { class e { buildTitle(n) { let r, o = n.root; for (; void 0 !== o;)r = this.getResolvedTitleForRoute(o) ?? r, o = o.children.find(i => i.outlet === H); return r } getResolvedTitleForRoute(n) { return n.data[Bi] } static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275prov = T({ token: e, factory: function () { return b(fV) }, providedIn: "root" }) } return e })(), fV = (() => { class e extends Uw { constructor(n) { super(), this.title = n } updateTitle(n) { const r = this.buildTitle(n); void 0 !== r && this.title.setTitle(r) } static #e = this.\u0275fac = function (r) { return new (r || e)(A(MD)) }; static #t = this.\u0275prov = T({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(), hV = (() => { class e { static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275prov = T({ token: e, factory: function () { return b(gV) }, providedIn: "root" }) } return e })(); class pV { shouldDetach(t) { return !1 } store(t, n) { } shouldAttach(t) { return !1 } retrieve(t) { return null } shouldReuseRoute(t, n) { return t.routeConfig === n.routeConfig } } let gV = (() => { class e extends pV { static #e = this.\u0275fac = function () { let n; return function (o) { return (n || (n = Re(e)))(o || e) } }(); static #t = this.\u0275prov = T({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); const bu = new M("", { providedIn: "root", factory: () => ({}) }); let mV = (() => { class e { static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275prov = T({ token: e, factory: function () { return b(vV) }, providedIn: "root" }) } return e })(), vV = (() => { class e { shouldProcessUrl(n) { return !0 } extract(n) { return n } merge(n, r) { return n } static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275prov = T({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); var es = function (e) { return e[e.COMPLETE = 0] = "COMPLETE", e[e.FAILED = 1] = "FAILED", e[e.REDIRECTING = 2] = "REDIRECTING", e }(es || {}); function zw(e, t) { e.events.pipe(Dn(n => n instanceof $n || n instanceof Wi || n instanceof gu || n instanceof wo), Y(n => n instanceof $n || n instanceof wo ? es.COMPLETE : n instanceof Wi && (0 === n.code || 1 === n.code) ? es.REDIRECTING : es.FAILED), Dn(n => n !== es.REDIRECTING), _o(1)).subscribe(() => { t() }) } function yV(e) { throw e } function _V(e, t, n) { return t.parse("/") } const CV = { paths: "exact", fragment: "ignored", matrixParams: "ignored", queryParams: "exact" }, DV = { paths: "subset", fragment: "ignored", matrixParams: "ignored", queryParams: "subset" }; let St = (() => { class e { get navigationId() { return this.navigationTransitions.navigationId } get browserPageId() { return "computed" !== this.canceledNavigationResolution ? this.currentPageId : this.location.getState()?.\u0275routerPageId ?? this.currentPageId } get events() { return this._events } constructor() { this.disposed = !1, this.currentPageId = 0, this.console = b(tC), this.isNgZoneEnabled = !1, this._events = new At, this.options = b(bu, { optional: !0 }) || {}, this.pendingTasks = b(Ra), this.errorHandler = this.options.errorHandler || yV, this.malformedUriErrorHandler = this.options.malformedUriErrorHandler || _V, this.navigated = !1, this.lastSuccessfulId = -1, this.urlHandlingStrategy = b(mV), this.routeReuseStrategy = b(hV), this.titleStrategy = b(Uw), this.onSameUrlNavigation = this.options.onSameUrlNavigation || "ignore", this.paramsInheritanceStrategy = this.options.paramsInheritanceStrategy || "emptyOnly", this.urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred", this.canceledNavigationResolution = this.options.canceledNavigationResolution || "replace", this.config = b(Ao, { optional: !0 })?.flat() ?? [], this.navigationTransitions = b(wu), this.urlSerializer = b($i), this.location = b(zd), this.componentInputBindingEnabled = !!b(vu, { optional: !0 }), this.eventsSubscription = new ot, this.isNgZoneEnabled = b(ae) instanceof ae && ae.isInAngularZone(), this.resetConfig(this.config), this.currentUrlTree = new Do, this.rawUrlTree = this.currentUrlTree, this.browserUrlTree = this.currentUrlTree, this.routerState = ww(0, null), this.navigationTransitions.setupNavigations(this, this.currentUrlTree, this.routerState).subscribe(n => { this.lastSuccessfulId = n.id, this.currentPageId = this.browserPageId }, n => { this.console.warn(`Unhandled Navigation Error: ${n}`) }), this.subscribeToNavigationEvents() } subscribeToNavigationEvents() { const n = this.navigationTransitions.events.subscribe(r => { try { const { currentTransition: o } = this.navigationTransitions; if (null === o) return void (Gw(r) && this._events.next(r)); if (r instanceof pu) $w(o.source) && (this.browserUrlTree = o.extractedUrl); else if (r instanceof wo) this.rawUrlTree = o.rawUrl; else if (r instanceof yw) { if ("eager" === this.urlUpdateStrategy) { if (!o.extras.skipLocationChange) { const i = this.urlHandlingStrategy.merge(o.urlAfterRedirects, o.rawUrl); this.setBrowserUrl(i, o) } this.browserUrlTree = o.urlAfterRedirects } } else if (r instanceof Of) this.currentUrlTree = o.urlAfterRedirects, this.rawUrlTree = this.urlHandlingStrategy.merge(o.urlAfterRedirects, o.rawUrl), this.routerState = o.targetRouterState, "deferred" === this.urlUpdateStrategy && (o.extras.skipLocationChange || this.setBrowserUrl(this.rawUrlTree, o), this.browserUrlTree = o.urlAfterRedirects); else if (r instanceof Wi) 0 !== r.code && 1 !== r.code && (this.navigated = !0), (3 === r.code || 2 === r.code) && this.restoreHistory(o); else if (r instanceof Nf) { const i = this.urlHandlingStrategy.merge(r.url, o.currentRawUrl), s = { skipLocationChange: o.extras.skipLocationChange, replaceUrl: "eager" === this.urlUpdateStrategy || $w(o.source) }; this.scheduleNavigation(i, qi, null, s, { resolve: o.resolve, reject: o.reject, promise: o.promise }) } r instanceof gu && this.restoreHistory(o, !0), r instanceof $n && (this.navigated = !0), Gw(r) && this._events.next(r) } catch (o) { this.navigationTransitions.transitionAbortSubject.next(o) } }); this.eventsSubscription.add(n) } resetRootComponentType(n) { this.routerState.root.component = n, this.navigationTransitions.rootComponentType = n } initialNavigation() { if (this.setUpLocationChangeListener(), !this.navigationTransitions.hasRequestedNavigation) { const n = this.location.getState(); this.navigateToSyncWithBrowser(this.location.path(!0), qi, n) } } setUpLocationChangeListener() { this.locationSubscription || (this.locationSubscription = this.location.subscribe(n => { const r = "popstate" === n.type ? "popstate" : "hashchange"; "popstate" === r && setTimeout(() => { this.navigateToSyncWithBrowser(n.url, r, n.state) }, 0) })) } navigateToSyncWithBrowser(n, r, o) { const i = { replaceUrl: !0 }, s = o?.navigationId ? o : null; if (o) { const u = { ...o }; delete u.navigationId, delete u.\u0275routerPageId, 0 !== Object.keys(u).length && (i.state = u) } const a = this.parseUrl(n); this.scheduleNavigation(a, r, s, i) } get url() { return this.serializeUrl(this.currentUrlTree) } getCurrentNavigation() { return this.navigationTransitions.currentNavigation } get lastSuccessfulNavigation() { return this.navigationTransitions.lastSuccessfulNavigation } resetConfig(n) { this.config = n.map(jf), this.navigated = !1, this.lastSuccessfulId = -1 } ngOnDestroy() { this.dispose() } dispose() { this.navigationTransitions.complete(), this.locationSubscription && (this.locationSubscription.unsubscribe(), this.locationSubscription = void 0), this.disposed = !0, this.eventsSubscription.unsubscribe() } createUrlTree(n, r = {}) { const { relativeTo: o, queryParams: i, fragment: s, queryParamsHandling: a, preserveFragment: u } = r, c = u ? this.currentUrlTree.fragment : s; let d, l = null; switch (a) { case "merge": l = { ...this.currentUrlTree.queryParams, ...i }; break; case "preserve": l = this.currentUrlTree.queryParams; break; default: l = i || null }null !== l && (l = this.removeEmptyProps(l)); try { d = dw(o ? o.snapshot : this.routerState.snapshot.root) } catch { ("string" != typeof n[0] || !n[0].startsWith("/")) && (n = []), d = this.currentUrlTree.root } return fw(d, n, l, c ?? null) } navigateByUrl(n, r = { skipLocationChange: !1 }) { const o = dr(n) ? n : this.parseUrl(n), i = this.urlHandlingStrategy.merge(o, this.rawUrlTree); return this.scheduleNavigation(i, qi, null, r) } navigate(n, r = { skipLocationChange: !1 }) { return function wV(e) { for (let t = 0; t < e.length; t++)if (null == e[t]) throw new C(4008, !1) }(n), this.navigateByUrl(this.createUrlTree(n, r), r) } serializeUrl(n) { return this.urlSerializer.serialize(n) } parseUrl(n) { let r; try { r = this.urlSerializer.parse(n) } catch (o) { r = this.malformedUriErrorHandler(o, this.urlSerializer, n) } return r } isActive(n, r) { let o; if (o = !0 === r ? { ...CV } : !1 === r ? { ...DV } : r, dr(n)) return nw(this.currentUrlTree, n, o); const i = this.parseUrl(n); return nw(this.currentUrlTree, i, o) } removeEmptyProps(n) { return Object.keys(n).reduce((r, o) => { const i = n[o]; return null != i && (r[o] = i), r }, {}) } scheduleNavigation(n, r, o, i, s) { if (this.disposed) return Promise.resolve(!1); let a, u, c; s ? (a = s.resolve, u = s.reject, c = s.promise) : c = new Promise((d, f) => { a = d, u = f }); const l = this.pendingTasks.add(); return zw(this, () => { queueMicrotask(() => this.pendingTasks.remove(l)) }), this.navigationTransitions.handleNavigationRequest({ source: r, restoredState: o, currentUrlTree: this.currentUrlTree, currentRawUrl: this.currentUrlTree, currentBrowserUrl: this.browserUrlTree, rawUrl: n, extras: i, resolve: a, reject: u, promise: c, currentSnapshot: this.routerState.snapshot, currentRouterState: this.routerState }), c.catch(d => Promise.reject(d)) } setBrowserUrl(n, r) { const o = this.urlSerializer.serialize(n); if (this.location.isCurrentPathEqualTo(o) || r.extras.replaceUrl) { const s = { ...r.extras.state, ...this.generateNgRouterState(r.id, this.browserPageId) }; this.location.replaceState(o, "", s) } else { const i = { ...r.extras.state, ...this.generateNgRouterState(r.id, this.browserPageId + 1) }; this.location.go(o, "", i) } } restoreHistory(n, r = !1) { if ("computed" === this.canceledNavigationResolution) { const i = this.currentPageId - this.browserPageId; 0 !== i ? this.location.historyGo(i) : this.currentUrlTree === this.getCurrentNavigation()?.finalUrl && 0 === i && (this.resetState(n), this.browserUrlTree = n.currentUrlTree, this.resetUrlToCurrentUrlTree()) } else "replace" === this.canceledNavigationResolution && (r && this.resetState(n), this.resetUrlToCurrentUrlTree()) } resetState(n) { this.routerState = n.currentRouterState, this.currentUrlTree = n.currentUrlTree, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, n.rawUrl) } resetUrlToCurrentUrlTree() { this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId)) } generateNgRouterState(n, r) { return "computed" === this.canceledNavigationResolution ? { navigationId: n, \u0275routerPageId: r } : { navigationId: n } } static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275prov = T({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); function Gw(e) { return !(e instanceof Of || e instanceof Nf) } class qw { } let MV = (() => { class e { constructor(n, r, o, i, s) { this.router = n, this.injector = o, this.preloadingStrategy = i, this.loader = s } setUpPreloading() { this.subscription = this.router.events.pipe(Dn(n => n instanceof $n), go(() => this.preload())).subscribe(() => { }) } preload() { return this.processRoutes(this.injector, this.router.config) } ngOnDestroy() { this.subscription && this.subscription.unsubscribe() } processRoutes(n, r) { const o = []; for (const i of r) { i.providers && !i._injector && (i._injector = fd(i.providers, n, `Route: ${i.path}`)); const s = i._injector ?? n, a = i._loadedInjector ?? s; (i.loadChildren && !i._loadedRoutes && void 0 === i.canLoad || i.loadComponent && !i._loadedComponent) && o.push(this.preloadConfig(s, i)), (i.children || i._loadedRoutes) && o.push(this.processRoutes(a, i.children ?? i._loadedRoutes)) } return be(o).pipe(mr()) } preloadConfig(n, r) { return this.preloadingStrategy.preload(r, () => { let o; o = r.loadChildren && void 0 === r.canLoad ? this.loader.loadChildren(n, r) : P(null); const i = o.pipe(Te(s => null === s ? P(void 0) : (r._loadedRoutes = s.routes, r._loadedInjector = s.injector, this.processRoutes(s.injector ?? n, s.routes)))); return r.loadComponent && !r._loadedComponent ? be([i, this.loader.loadComponent(r)]).pipe(mr()) : i }) } static #e = this.\u0275fac = function (r) { return new (r || e)(A(St), A(nC), A(dt), A(qw), A(Uf)) }; static #t = this.\u0275prov = T({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); const Gf = new M(""); let Ww = (() => { class e { constructor(n, r, o, i, s = {}) { this.urlSerializer = n, this.transitions = r, this.viewportScroller = o, this.zone = i, this.options = s, this.lastId = 0, this.lastSource = "imperative", this.restoredId = 0, this.store = {}, s.scrollPositionRestoration = s.scrollPositionRestoration || "disabled", s.anchorScrolling = s.anchorScrolling || "disabled" } init() { "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents() } createScrollEvents() { return this.transitions.events.subscribe(n => { n instanceof pu ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = n.navigationTrigger, this.restoredId = n.restoredState ? n.restoredState.navigationId : 0) : n instanceof $n ? (this.lastId = n.id, this.scheduleScrollEvent(n, this.urlSerializer.parse(n.urlAfterRedirects).fragment)) : n instanceof wo && 0 === n.code && (this.lastSource = void 0, this.restoredId = 0, this.scheduleScrollEvent(n, this.urlSerializer.parse(n.url).fragment)) }) } consumeScrollEvents() { return this.transitions.events.subscribe(n => { n instanceof _w && (n.position ? "top" === this.options.scrollPositionRestoration ? this.viewportScroller.scrollToPosition([0, 0]) : "enabled" === this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition(n.position) : n.anchor && "enabled" === this.options.anchorScrolling ? this.viewportScroller.scrollToAnchor(n.anchor) : "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition([0, 0])) }) } scheduleScrollEvent(n, r) { this.zone.runOutsideAngular(() => { setTimeout(() => { this.zone.run(() => { this.transitions.events.next(new _w(n, "popstate" === this.lastSource ? this.store[this.restoredId] : null, r)) }) }, 0) }) } ngOnDestroy() { this.routerEventsSubscription?.unsubscribe(), this.scrollEventsSubscription?.unsubscribe() } static #e = this.\u0275fac = function (r) { !function Wm() { throw new Error("invalid") }() }; static #t = this.\u0275prov = T({ token: e, factory: e.\u0275fac }) } return e })(); function bn(e, t) { return { \u0275kind: e, \u0275providers: t } } function Yw() { const e = b(ht); return t => { const n = e.get(fo); if (t !== n.components[0]) return; const r = e.get(St), o = e.get(Qw); 1 === e.get(qf) && r.initialNavigation(), e.get(Xw, null, z.Optional)?.setUpPreloading(), e.get(Gf, null, z.Optional)?.init(), r.resetRootComponentType(n.componentTypes[0]), o.closed || (o.next(), o.complete(), o.unsubscribe()) } } const Qw = new M("", { factory: () => new At }), qf = new M("", { providedIn: "root", factory: () => 1 }), Xw = new M(""); function TV(e) { return bn(0, [{ provide: Xw, useExisting: MV }, { provide: qw, useExisting: e }]) } const Jw = new M("ROUTER_FORROOT_GUARD"), NV = [zd, { provide: $i, useClass: Mf }, St, Zi, { provide: Eo, useFactory: function Zw(e) { return e.routerState.root }, deps: [St] }, Uf, []]; function PV() { return new cC("Router", St) } let Kw = (() => { class e { constructor(n) { } static forRoot(n, r) { return { ngModule: e, providers: [NV, [], { provide: Ao, multi: !0, useValue: n }, { provide: Jw, useFactory: kV, deps: [[St, new js, new Bs]] }, { provide: bu, useValue: r || {} }, r?.useHash ? { provide: ar, useClass: pR } : { provide: ar, useClass: jC }, { provide: Gf, useFactory: () => { const e = b(P1), t = b(ae), n = b(bu), r = b(wu), o = b($i); return n.scrollOffset && e.setOffset(n.scrollOffset), new Ww(o, r, e, t, n) } }, r?.preloadingStrategy ? TV(r.preloadingStrategy).\u0275providers : [], { provide: cC, multi: !0, useFactory: PV }, r?.initialNavigation ? LV(r) : [], r?.bindToComponentInputs ? bn(8, [Iw, { provide: vu, useExisting: Iw }]).\u0275providers : [], [{ provide: eb, useFactory: Yw }, { provide: Rd, multi: !0, useExisting: eb }]] } } static forChild(n) { return { ngModule: e, providers: [{ provide: Ao, multi: !0, useValue: n }] } } static #e = this.\u0275fac = function (r) { return new (r || e)(A(Jw, 8)) }; static #t = this.\u0275mod = _t({ type: e }); static #n = this.\u0275inj = at({}) } return e })(); function kV(e) { return "guarded" } function LV(e) { return ["disabled" === e.initialNavigation ? bn(3, [{ provide: Id, multi: !0, useFactory: () => { const t = b(St); return () => { t.setUpLocationChangeListener() } } }, { provide: qf, useValue: 2 }]).\u0275providers : [], "enabledBlocking" === e.initialNavigation ? bn(2, [{ provide: qf, useValue: 0 }, { provide: Id, multi: !0, deps: [ht], useFactory: t => { const n = t.get(fR, Promise.resolve()); return () => n.then(() => new Promise(r => { const o = t.get(St), i = t.get(Qw); zw(o, () => { r(!0) }), t.get(wu).afterPreactivation = () => (r(!0), i.closed ? P(void 0) : i), o.initialNavigation() })) } }]).\u0275providers : []] } const eb = new M(""); let tb = (() => { class e { constructor(n, r) { this._renderer = n, this._elementRef = r, this.onChange = o => { }, this.onTouched = () => { } } setProperty(n, r) { this._renderer.setProperty(this._elementRef.nativeElement, n, r) } registerOnTouched(n) { this.onTouched = n } registerOnChange(n) { this.onChange = n } setDisabledState(n) { this.setProperty("disabled", n) } static #e = this.\u0275fac = function (r) { return new (r || e)(D(fn), D(ft)) }; static #t = this.\u0275dir = k({ type: e }) } return e })(), fr = (() => { class e extends tb { static #e = this.\u0275fac = function () { let n; return function (o) { return (n || (n = Re(e)))(o || e) } }(); static #t = this.\u0275dir = k({ type: e, features: [ee] }) } return e })(); const nn = new M("NgValueAccessor"), HV = { provide: nn, useExisting: oe(() => Eu), multi: !0 }, UV = new M("CompositionEventMode"); let Eu = (() => { class e extends tb { constructor(n, r, o) { super(n, r), this._compositionMode = o, this._composing = !1, null == this._compositionMode && (this._compositionMode = !function $V() { const e = Ln() ? Ln().getUserAgent() : ""; return /android (\d+)/.test(e.toLowerCase()) }()) } writeValue(n) { this.setProperty("value", n ?? "") } _handleInput(n) { (!this._compositionMode || this._compositionMode && !this._composing) && this.onChange(n) } _compositionStart() { this._composing = !0 } _compositionEnd(n) { this._composing = !1, this._compositionMode && this.onChange(n) } static #e = this.\u0275fac = function (r) { return new (r || e)(D(fn), D(ft), D(UV, 8)) }; static #t = this.\u0275dir = k({ type: e, selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]], hostBindings: function (r, o) { 1 & r && Ve("input", function (s) { return o._handleInput(s.target.value) })("blur", function () { return o.onTouched() })("compositionstart", function () { return o._compositionStart() })("compositionend", function (s) { return o._compositionEnd(s.target.value) }) }, features: [de([HV]), ee] }) } return e })(); function Un(e) { return null == e || ("string" == typeof e || Array.isArray(e)) && 0 === e.length } function rb(e) { return null != e && "number" == typeof e.length } const Be = new M("NgValidators"), zn = new M("NgAsyncValidators"), zV = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/; class To { static min(t) { return function ob(e) { return t => { if (Un(t.value) || Un(e)) return null; const n = parseFloat(t.value); return !isNaN(n) && n < e ? { min: { min: e, actual: t.value } } : null } }(t) } static max(t) { return function ib(e) { return t => { if (Un(t.value) || Un(e)) return null; const n = parseFloat(t.value); return !isNaN(n) && n > e ? { max: { max: e, actual: t.value } } : null } }(t) } static required(t) { return function sb(e) { return Un(e.value) ? { required: !0 } : null }(t) } static requiredTrue(t) { return function ab(e) { return !0 === e.value ? null : { required: !0 } }(t) } static email(t) { return function ub(e) { return Un(e.value) || zV.test(e.value) ? null : { email: !0 } }(t) } static minLength(t) { return function cb(e) { return t => Un(t.value) || !rb(t.value) ? null : t.value.length < e ? { minlength: { requiredLength: e, actualLength: t.value.length } } : null }(t) } static maxLength(t) { return function lb(e) { return t => rb(t.value) && t.value.length > e ? { maxlength: { requiredLength: e, actualLength: t.value.length } } : null }(t) } static pattern(t) { return function db(e) { if (!e) return Mu; let t, n; return "string" == typeof e ? (n = "", "^" !== e.charAt(0) && (n += "^"), n += e, "$" !== e.charAt(e.length - 1) && (n += "$"), t = new RegExp(n)) : (n = e.toString(), t = e), r => { if (Un(r.value)) return null; const o = r.value; return t.test(o) ? null : { pattern: { requiredPattern: n, actualValue: o } } } }(t) } static nullValidator(t) { return null } static compose(t) { return vb(t) } static composeAsync(t) { return yb(t) } } function Mu(e) { return null } function fb(e) { return null != e } function hb(e) { return Di(e) ? be(e) : e } function pb(e) { let t = {}; return e.forEach(n => { t = null != n ? { ...t, ...n } : t }), 0 === Object.keys(t).length ? null : t } function gb(e, t) { return t.map(n => n(e)) } function mb(e) { return e.map(t => function GV(e) { return !e.validate }(t) ? t : n => t.validate(n)) } function vb(e) { if (!e) return null; const t = e.filter(fb); return 0 == t.length ? null : function (n) { return pb(gb(n, t)) } } function Wf(e) { return null != e ? vb(mb(e)) : null } function yb(e) { if (!e) return null; const t = e.filter(fb); return 0 == t.length ? null : function (n) { return function jV(...e) { const t = Fh(e), { args: n, keys: r } = qD(e), o = new me(i => { const { length: s } = n; if (!s) return void i.complete(); const a = new Array(s); let u = s, c = s; for (let l = 0; l < s; l++) { let d = !1; it(n[l]).subscribe(Ce(i, f => { d || (d = !0, c--), a[l] = f }, () => u--, void 0, () => { (!u || !d) && (c || i.next(r ? ZD(r, a) : a), i.complete()) })) } }); return t ? o.pipe(WD(t)) : o }(gb(n, t).map(hb)).pipe(Y(pb)) } } function Zf(e) { return null != e ? yb(mb(e)) : null } function _b(e, t) { return null === e ? [t] : Array.isArray(e) ? [...e, t] : [e, t] } function Cb(e) { return e._rawValidators } function Db(e) { return e._rawAsyncValidators } function Yf(e) { return e ? Array.isArray(e) ? e : [e] : [] } function Iu(e, t) { return Array.isArray(e) ? e.includes(t) : e === t } function wb(e, t) { const n = Yf(t); return Yf(e).forEach(o => { Iu(n, o) || n.push(o) }), n } function bb(e, t) { return Yf(t).filter(n => !Iu(e, n)) } class Eb { constructor() { this._rawValidators = [], this._rawAsyncValidators = [], this._onDestroyCallbacks = [] } get value() { return this.control ? this.control.value : null } get valid() { return this.control ? this.control.valid : null } get invalid() { return this.control ? this.control.invalid : null } get pending() { return this.control ? this.control.pending : null } get disabled() { return this.control ? this.control.disabled : null } get enabled() { return this.control ? this.control.enabled : null } get errors() { return this.control ? this.control.errors : null } get pristine() { return this.control ? this.control.pristine : null } get dirty() { return this.control ? this.control.dirty : null } get touched() { return this.control ? this.control.touched : null } get status() { return this.control ? this.control.status : null } get untouched() { return this.control ? this.control.untouched : null } get statusChanges() { return this.control ? this.control.statusChanges : null } get valueChanges() { return this.control ? this.control.valueChanges : null } get path() { return null } _setValidators(t) { this._rawValidators = t || [], this._composedValidatorFn = Wf(this._rawValidators) } _setAsyncValidators(t) { this._rawAsyncValidators = t || [], this._composedAsyncValidatorFn = Zf(this._rawAsyncValidators) } get validator() { return this._composedValidatorFn || null } get asyncValidator() { return this._composedAsyncValidatorFn || null } _registerOnDestroy(t) { this._onDestroyCallbacks.push(t) } _invokeOnDestroyCallbacks() { this._onDestroyCallbacks.forEach(t => t()), this._onDestroyCallbacks = [] } reset(t = void 0) { this.control && this.control.reset(t) } hasError(t, n) { return !!this.control && this.control.hasError(t, n) } getError(t, n) { return this.control ? this.control.getError(t, n) : null } } class Qe extends Eb { get formDirective() { return null } get path() { return null } } class Gn extends Eb { constructor() { super(...arguments), this._parent = null, this.name = null, this.valueAccessor = null } } class Mb { constructor(t) { this._cd = t } get isTouched() { return !!this._cd?.control?.touched } get isUntouched() { return !!this._cd?.control?.untouched } get isPristine() { return !!this._cd?.control?.pristine } get isDirty() { return !!this._cd?.control?.dirty } get isValid() { return !!this._cd?.control?.valid } get isInvalid() { return !!this._cd?.control?.invalid } get isPending() { return !!this._cd?.control?.pending } get isSubmitted() { return !!this._cd?.submitted } } let Ib = (() => { class e extends Mb { constructor(n) { super(n) } static #e = this.\u0275fac = function (r) { return new (r || e)(D(Gn, 2)) }; static #t = this.\u0275dir = k({ type: e, selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]], hostVars: 14, hostBindings: function (r, o) { 2 & r && Ma("ng-untouched", o.isUntouched)("ng-touched", o.isTouched)("ng-pristine", o.isPristine)("ng-dirty", o.isDirty)("ng-valid", o.isValid)("ng-invalid", o.isInvalid)("ng-pending", o.isPending) }, features: [ee] }) } return e })(), Sb = (() => { class e extends Mb { constructor(n) { super(n) } static #e = this.\u0275fac = function (r) { return new (r || e)(D(Qe, 10)) }; static #t = this.\u0275dir = k({ type: e, selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]], hostVars: 16, hostBindings: function (r, o) { 2 & r && Ma("ng-untouched", o.isUntouched)("ng-touched", o.isTouched)("ng-pristine", o.isPristine)("ng-dirty", o.isDirty)("ng-valid", o.isValid)("ng-invalid", o.isInvalid)("ng-pending", o.isPending)("ng-submitted", o.isSubmitted) }, features: [ee] }) } return e })(); const ts = "VALID", Au = "INVALID", Oo = "PENDING", ns = "DISABLED"; function Jf(e) { return (Tu(e) ? e.validators : e) || null } function Kf(e, t) { return (Tu(t) ? t.asyncValidators : e) || null } function Tu(e) { return null != e && !Array.isArray(e) && "object" == typeof e } function Tb(e, t, n) { const r = e.controls; if (!(t ? Object.keys(r) : r).length) throw new C(1e3, ""); if (!r[n]) throw new C(1001, "") } function Ob(e, t, n) { e._forEachChild((r, o) => { if (void 0 === n[o]) throw new C(1002, "") }) } class Ou { constructor(t, n) { this._pendingDirty = !1, this._hasOwnPendingAsyncValidator = !1, this._pendingTouched = !1, this._onCollectionChange = () => { }, this._parent = null, this.pristine = !0, this.touched = !1, this._onDisabledChange = [], this._assignValidators(t), this._assignAsyncValidators(n) } get validator() { return this._composedValidatorFn } set validator(t) { this._rawValidators = this._composedValidatorFn = t } get asyncValidator() { return this._composedAsyncValidatorFn } set asyncValidator(t) { this._rawAsyncValidators = this._composedAsyncValidatorFn = t } get parent() { return this._parent } get valid() { return this.status === ts } get invalid() { return this.status === Au } get pending() { return this.status == Oo } get disabled() { return this.status === ns } get enabled() { return this.status !== ns } get dirty() { return !this.pristine } get untouched() { return !this.touched } get updateOn() { return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change" } setValidators(t) { this._assignValidators(t) } setAsyncValidators(t) { this._assignAsyncValidators(t) } addValidators(t) { this.setValidators(wb(t, this._rawValidators)) } addAsyncValidators(t) { this.setAsyncValidators(wb(t, this._rawAsyncValidators)) } removeValidators(t) { this.setValidators(bb(t, this._rawValidators)) } removeAsyncValidators(t) { this.setAsyncValidators(bb(t, this._rawAsyncValidators)) } hasValidator(t) { return Iu(this._rawValidators, t) } hasAsyncValidator(t) { return Iu(this._rawAsyncValidators, t) } clearValidators() { this.validator = null } clearAsyncValidators() { this.asyncValidator = null } markAsTouched(t = {}) { this.touched = !0, this._parent && !t.onlySelf && this._parent.markAsTouched(t) } markAllAsTouched() { this.markAsTouched({ onlySelf: !0 }), this._forEachChild(t => t.markAllAsTouched()) } markAsUntouched(t = {}) { this.touched = !1, this._pendingTouched = !1, this._forEachChild(n => { n.markAsUntouched({ onlySelf: !0 }) }), this._parent && !t.onlySelf && this._parent._updateTouched(t) } markAsDirty(t = {}) { this.pristine = !1, this._parent && !t.onlySelf && this._parent.markAsDirty(t) } markAsPristine(t = {}) { this.pristine = !0, this._pendingDirty = !1, this._forEachChild(n => { n.markAsPristine({ onlySelf: !0 }) }), this._parent && !t.onlySelf && this._parent._updatePristine(t) } markAsPending(t = {}) { this.status = Oo, !1 !== t.emitEvent && this.statusChanges.emit(this.status), this._parent && !t.onlySelf && this._parent.markAsPending(t) } disable(t = {}) { const n = this._parentMarkedDirty(t.onlySelf); this.status = ns, this.errors = null, this._forEachChild(r => { r.disable({ ...t, onlySelf: !0 }) }), this._updateValue(), !1 !== t.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._updateAncestors({ ...t, skipPristineCheck: n }), this._onDisabledChange.forEach(r => r(!0)) } enable(t = {}) { const n = this._parentMarkedDirty(t.onlySelf); this.status = ts, this._forEachChild(r => { r.enable({ ...t, onlySelf: !0 }) }), this.updateValueAndValidity({ onlySelf: !0, emitEvent: t.emitEvent }), this._updateAncestors({ ...t, skipPristineCheck: n }), this._onDisabledChange.forEach(r => r(!1)) } _updateAncestors(t) { this._parent && !t.onlySelf && (this._parent.updateValueAndValidity(t), t.skipPristineCheck || this._parent._updatePristine(), this._parent._updateTouched()) } setParent(t) { this._parent = t } getRawValue() { return this.value } updateValueAndValidity(t = {}) { this._setInitialStatus(), this._updateValue(), this.enabled && (this._cancelExistingSubscription(), this.errors = this._runValidator(), this.status = this._calculateStatus(), (this.status === ts || this.status === Oo) && this._runAsyncValidator(t.emitEvent)), !1 !== t.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._parent && !t.onlySelf && this._parent.updateValueAndValidity(t) } _updateTreeValidity(t = { emitEvent: !0 }) { this._forEachChild(n => n._updateTreeValidity(t)), this.updateValueAndValidity({ onlySelf: !0, emitEvent: t.emitEvent }) } _setInitialStatus() { this.status = this._allControlsDisabled() ? ns : ts } _runValidator() { return this.validator ? this.validator(this) : null } _runAsyncValidator(t) { if (this.asyncValidator) { this.status = Oo, this._hasOwnPendingAsyncValidator = !0; const n = hb(this.asyncValidator(this)); this._asyncValidationSubscription = n.subscribe(r => { this._hasOwnPendingAsyncValidator = !1, this.setErrors(r, { emitEvent: t }) }) } } _cancelExistingSubscription() { this._asyncValidationSubscription && (this._asyncValidationSubscription.unsubscribe(), this._hasOwnPendingAsyncValidator = !1) } setErrors(t, n = {}) { this.errors = t, this._updateControlsErrors(!1 !== n.emitEvent) } get(t) { let n = t; return null == n || (Array.isArray(n) || (n = n.split(".")), 0 === n.length) ? null : n.reduce((r, o) => r && r._find(o), this) } getError(t, n) { const r = n ? this.get(n) : this; return r && r.errors ? r.errors[t] : null } hasError(t, n) { return !!this.getError(t, n) } get root() { let t = this; for (; t._parent;)t = t._parent; return t } _updateControlsErrors(t) { this.status = this._calculateStatus(), t && this.statusChanges.emit(this.status), this._parent && this._parent._updateControlsErrors(t) } _initObservables() { this.valueChanges = new pe, this.statusChanges = new pe } _calculateStatus() { return this._allControlsDisabled() ? ns : this.errors ? Au : this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(Oo) ? Oo : this._anyControlsHaveStatus(Au) ? Au : ts } _anyControlsHaveStatus(t) { return this._anyControls(n => n.status === t) } _anyControlsDirty() { return this._anyControls(t => t.dirty) } _anyControlsTouched() { return this._anyControls(t => t.touched) } _updatePristine(t = {}) { this.pristine = !this._anyControlsDirty(), this._parent && !t.onlySelf && this._parent._updatePristine(t) } _updateTouched(t = {}) { this.touched = this._anyControlsTouched(), this._parent && !t.onlySelf && this._parent._updateTouched(t) } _registerOnCollectionChange(t) { this._onCollectionChange = t } _setUpdateStrategy(t) { Tu(t) && null != t.updateOn && (this._updateOn = t.updateOn) } _parentMarkedDirty(t) { return !t && !(!this._parent || !this._parent.dirty) && !this._parent._anyControlsDirty() } _find(t) { return null } _assignValidators(t) { this._rawValidators = Array.isArray(t) ? t.slice() : t, this._composedValidatorFn = function YV(e) { return Array.isArray(e) ? Wf(e) : e || null }(this._rawValidators) } _assignAsyncValidators(t) { this._rawAsyncValidators = Array.isArray(t) ? t.slice() : t, this._composedAsyncValidatorFn = function QV(e) { return Array.isArray(e) ? Zf(e) : e || null }(this._rawAsyncValidators) } } class rs extends Ou { constructor(t, n, r) { super(Jf(n), Kf(r, n)), this.controls = t, this._initObservables(), this._setUpdateStrategy(n), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } registerControl(t, n) { return this.controls[t] ? this.controls[t] : (this.controls[t] = n, n.setParent(this), n._registerOnCollectionChange(this._onCollectionChange), n) } addControl(t, n, r = {}) { this.registerControl(t, n), this.updateValueAndValidity({ emitEvent: r.emitEvent }), this._onCollectionChange() } removeControl(t, n = {}) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), delete this.controls[t], this.updateValueAndValidity({ emitEvent: n.emitEvent }), this._onCollectionChange() } setControl(t, n, r = {}) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), delete this.controls[t], n && this.registerControl(t, n), this.updateValueAndValidity({ emitEvent: r.emitEvent }), this._onCollectionChange() } contains(t) { return this.controls.hasOwnProperty(t) && this.controls[t].enabled } setValue(t, n = {}) { Ob(this, 0, t), Object.keys(t).forEach(r => { Tb(this, !0, r), this.controls[r].setValue(t[r], { onlySelf: !0, emitEvent: n.emitEvent }) }), this.updateValueAndValidity(n) } patchValue(t, n = {}) { null != t && (Object.keys(t).forEach(r => { const o = this.controls[r]; o && o.patchValue(t[r], { onlySelf: !0, emitEvent: n.emitEvent }) }), this.updateValueAndValidity(n)) } reset(t = {}, n = {}) { this._forEachChild((r, o) => { r.reset(t ? t[o] : null, { onlySelf: !0, emitEvent: n.emitEvent }) }), this._updatePristine(n), this._updateTouched(n), this.updateValueAndValidity(n) } getRawValue() { return this._reduceChildren({}, (t, n, r) => (t[r] = n.getRawValue(), t)) } _syncPendingControls() { let t = this._reduceChildren(!1, (n, r) => !!r._syncPendingControls() || n); return t && this.updateValueAndValidity({ onlySelf: !0 }), t } _forEachChild(t) { Object.keys(this.controls).forEach(n => { const r = this.controls[n]; r && t(r, n) }) } _setUpControls() { this._forEachChild(t => { t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange) }) } _updateValue() { this.value = this._reduceValue() } _anyControls(t) { for (const [n, r] of Object.entries(this.controls)) if (this.contains(n) && t(r)) return !0; return !1 } _reduceValue() { return this._reduceChildren({}, (n, r, o) => ((r.enabled || this.disabled) && (n[o] = r.value), n)) } _reduceChildren(t, n) { let r = t; return this._forEachChild((o, i) => { r = n(r, o, i) }), r } _allControlsDisabled() { for (const t of Object.keys(this.controls)) if (this.controls[t].enabled) return !1; return Object.keys(this.controls).length > 0 || this.disabled } _find(t) { return this.controls.hasOwnProperty(t) ? this.controls[t] : null } } class Nb extends rs { } const hr = new M("CallSetDisabledState", { providedIn: "root", factory: () => os }), os = "always"; function Nu(e, t) { return [...t.path, e] } function is(e, t, n = os) { eh(e, t), t.valueAccessor.writeValue(e.value), (e.disabled || "always" === n) && t.valueAccessor.setDisabledState?.(e.disabled), function JV(e, t) { t.valueAccessor.registerOnChange(n => { e._pendingValue = n, e._pendingChange = !0, e._pendingDirty = !0, "change" === e.updateOn && Pb(e, t) }) }(e, t), function e2(e, t) { const n = (r, o) => { t.valueAccessor.writeValue(r), o && t.viewToModelUpdate(r) }; e.registerOnChange(n), t._registerOnDestroy(() => { e._unregisterOnChange(n) }) }(e, t), function KV(e, t) { t.valueAccessor.registerOnTouched(() => { e._pendingTouched = !0, "blur" === e.updateOn && e._pendingChange && Pb(e, t), "submit" !== e.updateOn && e.markAsTouched() }) }(e, t), function XV(e, t) { if (t.valueAccessor.setDisabledState) { const n = r => { t.valueAccessor.setDisabledState(r) }; e.registerOnDisabledChange(n), t._registerOnDestroy(() => { e._unregisterOnDisabledChange(n) }) } }(e, t) } function Pu(e, t, n = !0) { const r = () => { }; t.valueAccessor && (t.valueAccessor.registerOnChange(r), t.valueAccessor.registerOnTouched(r)), Ru(e, t), e && (t._invokeOnDestroyCallbacks(), e._registerOnCollectionChange(() => { })) } function xu(e, t) { e.forEach(n => { n.registerOnValidatorChange && n.registerOnValidatorChange(t) }) } function eh(e, t) { const n = Cb(e); null !== t.validator ? e.setValidators(_b(n, t.validator)) : "function" == typeof n && e.setValidators([n]); const r = Db(e); null !== t.asyncValidator ? e.setAsyncValidators(_b(r, t.asyncValidator)) : "function" == typeof r && e.setAsyncValidators([r]); const o = () => e.updateValueAndValidity(); xu(t._rawValidators, o), xu(t._rawAsyncValidators, o) } function Ru(e, t) { let n = !1; if (null !== e) { if (null !== t.validator) { const o = Cb(e); if (Array.isArray(o) && o.length > 0) { const i = o.filter(s => s !== t.validator); i.length !== o.length && (n = !0, e.setValidators(i)) } } if (null !== t.asyncValidator) { const o = Db(e); if (Array.isArray(o) && o.length > 0) { const i = o.filter(s => s !== t.asyncValidator); i.length !== o.length && (n = !0, e.setAsyncValidators(i)) } } } const r = () => { }; return xu(t._rawValidators, r), xu(t._rawAsyncValidators, r), n } function Pb(e, t) { e._pendingDirty && e.markAsDirty(), e.setValue(e._pendingValue, { emitModelToViewChange: !1 }), t.viewToModelUpdate(e._pendingValue), e._pendingChange = !1 } function xb(e, t) { eh(e, t) } function nh(e, t) { if (!e.hasOwnProperty("model")) return !1; const n = e.model; return !!n.isFirstChange() || !Object.is(t, n.currentValue) } function Rb(e, t) { e._syncPendingControls(), t.forEach(n => { const r = n.control; "submit" === r.updateOn && r._pendingChange && (n.viewToModelUpdate(r._pendingValue), r._pendingChange = !1) }) } function rh(e, t) { if (!t) return null; let n, r, o; return Array.isArray(t), t.forEach(i => { i.constructor === Eu ? n = i : function r2(e) { return Object.getPrototypeOf(e.constructor) === fr }(i) ? r = i : o = i }), o || r || n || null } const i2 = { provide: Qe, useExisting: oe(() => Fu) }, ss = (() => Promise.resolve())(); let Fu = (() => { class e extends Qe { constructor(n, r, o) { super(), this.callSetDisabledState = o, this.submitted = !1, this._directives = new Set, this.ngSubmit = new pe, this.form = new rs({}, Wf(n), Zf(r)) } ngAfterViewInit() { this._setUpdateStrategy() } get formDirective() { return this } get control() { return this.form } get path() { return [] } get controls() { return this.form.controls } addControl(n) { ss.then(() => { const r = this._findContainer(n.path); n.control = r.registerControl(n.name, n.control), is(n.control, n, this.callSetDisabledState), n.control.updateValueAndValidity({ emitEvent: !1 }), this._directives.add(n) }) } getControl(n) { return this.form.get(n.path) } removeControl(n) { ss.then(() => { const r = this._findContainer(n.path); r && r.removeControl(n.name), this._directives.delete(n) }) } addFormGroup(n) { ss.then(() => { const r = this._findContainer(n.path), o = new rs({}); xb(o, n), r.registerControl(n.name, o), o.updateValueAndValidity({ emitEvent: !1 }) }) } removeFormGroup(n) { ss.then(() => { const r = this._findContainer(n.path); r && r.removeControl(n.name) }) } getFormGroup(n) { return this.form.get(n.path) } updateModel(n, r) { ss.then(() => { this.form.get(n.path).setValue(r) }) } setValue(n) { this.control.setValue(n) } onSubmit(n) { return this.submitted = !0, Rb(this.form, this._directives), this.ngSubmit.emit(n), "dialog" === n?.target?.method } onReset() { this.resetForm() } resetForm(n = void 0) { this.form.reset(n), this.submitted = !1 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.form._updateOn = this.options.updateOn) } _findContainer(n) { return n.pop(), n.length ? this.form.get(n) : this.form } static #e = this.\u0275fac = function (r) { return new (r || e)(D(Be, 10), D(zn, 10), D(hr, 8)) }; static #t = this.\u0275dir = k({ type: e, selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", ""], ["ng-form"], ["", "ngForm", ""]], hostBindings: function (r, o) { 1 & r && Ve("submit", function (s) { return o.onSubmit(s) })("reset", function () { return o.onReset() }) }, inputs: { options: ["ngFormOptions", "options"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [de([i2]), ee] }) } return e })(); function Fb(e, t) { const n = e.indexOf(t); n > -1 && e.splice(n, 1) } function kb(e) { return "object" == typeof e && null !== e && 2 === Object.keys(e).length && "value" in e && "disabled" in e } const as = class extends Ou { constructor(t = null, n, r) { super(Jf(n), Kf(r, n)), this.defaultValue = null, this._onChange = [], this._pendingChange = !1, this._applyFormState(t), this._setUpdateStrategy(n), this._initObservables(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }), Tu(n) && (n.nonNullable || n.initialValueIsDefault) && (this.defaultValue = kb(t) ? t.value : t) } setValue(t, n = {}) { this.value = this._pendingValue = t, this._onChange.length && !1 !== n.emitModelToViewChange && this._onChange.forEach(r => r(this.value, !1 !== n.emitViewToModelChange)), this.updateValueAndValidity(n) } patchValue(t, n = {}) { this.setValue(t, n) } reset(t = this.defaultValue, n = {}) { this._applyFormState(t), this.markAsPristine(n), this.markAsUntouched(n), this.setValue(this.value, n), this._pendingChange = !1 } _updateValue() { } _anyControls(t) { return !1 } _allControlsDisabled() { return this.disabled } registerOnChange(t) { this._onChange.push(t) } _unregisterOnChange(t) { Fb(this._onChange, t) } registerOnDisabledChange(t) { this._onDisabledChange.push(t) } _unregisterOnDisabledChange(t) { Fb(this._onDisabledChange, t) } _forEachChild(t) { } _syncPendingControls() { return !("submit" !== this.updateOn || (this._pendingDirty && this.markAsDirty(), this._pendingTouched && this.markAsTouched(), !this._pendingChange) || (this.setValue(this._pendingValue, { onlySelf: !0, emitModelToViewChange: !1 }), 0)) } _applyFormState(t) { kb(t) ? (this.value = this._pendingValue = t.value, t.disabled ? this.disable({ onlySelf: !0, emitEvent: !1 }) : this.enable({ onlySelf: !0, emitEvent: !1 })) : this.value = this._pendingValue = t } }, u2 = { provide: Gn, useExisting: oe(() => oh) }, jb = (() => Promise.resolve())(); let oh = (() => { class e extends Gn { constructor(n, r, o, i, s, a) { super(), this._changeDetectorRef = s, this.callSetDisabledState = a, this.control = new as, this._registered = !1, this.name = "", this.update = new pe, this._parent = n, this._setValidators(r), this._setAsyncValidators(o), this.valueAccessor = rh(0, i) } ngOnChanges(n) { if (this._checkForErrors(), !this._registered || "name" in n) { if (this._registered && (this._checkName(), this.formDirective)) { const r = n.name.previousValue; this.formDirective.removeControl({ name: r, path: this._getPath(r) }) } this._setUpControl() } "isDisabled" in n && this._updateDisabled(n), nh(n, this.viewModel) && (this._updateValue(this.model), this.viewModel = this.model) } ngOnDestroy() { this.formDirective && this.formDirective.removeControl(this) } get path() { return this._getPath(this.name) } get formDirective() { return this._parent ? this._parent.formDirective : null } viewToModelUpdate(n) { this.viewModel = n, this.update.emit(n) } _setUpControl() { this._setUpdateStrategy(), this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this), this._registered = !0 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.control._updateOn = this.options.updateOn) } _isStandalone() { return !this._parent || !(!this.options || !this.options.standalone) } _setUpStandalone() { is(this.control, this, this.callSetDisabledState), this.control.updateValueAndValidity({ emitEvent: !1 }) } _checkForErrors() { this._isStandalone() || this._checkParentType(), this._checkName() } _checkParentType() { } _checkName() { this.options && this.options.name && (this.name = this.options.name), this._isStandalone() } _updateValue(n) { jb.then(() => { this.control.setValue(n, { emitViewToModelChange: !1 }), this._changeDetectorRef?.markForCheck() }) } _updateDisabled(n) { const r = n.isDisabled.currentValue, o = 0 !== r && function ho(e) { return "boolean" == typeof e ? e : null != e && "false" !== e }(r); jb.then(() => { o && !this.control.disabled ? this.control.disable() : !o && this.control.disabled && this.control.enable(), this._changeDetectorRef?.markForCheck() }) } _getPath(n) { return this._parent ? Nu(n, this._parent) : [n] } static #e = this.\u0275fac = function (r) { return new (r || e)(D(Qe, 9), D(Be, 10), D(zn, 10), D(nn, 10), D(Va, 8), D(hr, 8)) }; static #t = this.\u0275dir = k({ type: e, selectors: [["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]], inputs: { name: "name", isDisabled: ["disabled", "isDisabled"], model: ["ngModel", "model"], options: ["ngModelOptions", "options"] }, outputs: { update: "ngModelChange" }, exportAs: ["ngModel"], features: [de([u2]), ee, Dt] }) } return e })(), Bb = (() => { class e { static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275dir = k({ type: e, selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]], hostAttrs: ["novalidate", ""] }) } return e })(), $b = (() => { class e { static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275mod = _t({ type: e }); static #n = this.\u0275inj = at({}) } return e })(); const ih = new M("NgModelWithFormControlWarning"), p2 = { provide: Qe, useExisting: oe(() => ku) }; let ku = (() => { class e extends Qe { constructor(n, r, o) { super(), this.callSetDisabledState = o, this.submitted = !1, this._onCollectionChange = () => this._updateDomValue(), this.directives = [], this.form = null, this.ngSubmit = new pe, this._setValidators(n), this._setAsyncValidators(r) } ngOnChanges(n) { this._checkFormPresent(), n.hasOwnProperty("form") && (this._updateValidators(), this._updateDomValue(), this._updateRegistrations(), this._oldForm = this.form) } ngOnDestroy() { this.form && (Ru(this.form, this), this.form._onCollectionChange === this._onCollectionChange && this.form._registerOnCollectionChange(() => { })) } get formDirective() { return this } get control() { return this.form } get path() { return [] } addControl(n) { const r = this.form.get(n.path); return is(r, n, this.callSetDisabledState), r.updateValueAndValidity({ emitEvent: !1 }), this.directives.push(n), r } getControl(n) { return this.form.get(n.path) } removeControl(n) { Pu(n.control || null, n, !1), function o2(e, t) { const n = e.indexOf(t); n > -1 && e.splice(n, 1) }(this.directives, n) } addFormGroup(n) { this._setUpFormContainer(n) } removeFormGroup(n) { this._cleanUpFormContainer(n) } getFormGroup(n) { return this.form.get(n.path) } addFormArray(n) { this._setUpFormContainer(n) } removeFormArray(n) { this._cleanUpFormContainer(n) } getFormArray(n) { return this.form.get(n.path) } updateModel(n, r) { this.form.get(n.path).setValue(r) } onSubmit(n) { return this.submitted = !0, Rb(this.form, this.directives), this.ngSubmit.emit(n), "dialog" === n?.target?.method } onReset() { this.resetForm() } resetForm(n = void 0) { this.form.reset(n), this.submitted = !1 } _updateDomValue() { this.directives.forEach(n => { const r = n.control, o = this.form.get(n.path); r !== o && (Pu(r || null, n), (e => e instanceof as)(o) && (is(o, n, this.callSetDisabledState), n.control = o)) }), this.form._updateTreeValidity({ emitEvent: !1 }) } _setUpFormContainer(n) { const r = this.form.get(n.path); xb(r, n), r.updateValueAndValidity({ emitEvent: !1 }) } _cleanUpFormContainer(n) { if (this.form) { const r = this.form.get(n.path); r && function t2(e, t) { return Ru(e, t) }(r, n) && r.updateValueAndValidity({ emitEvent: !1 }) } } _updateRegistrations() { this.form._registerOnCollectionChange(this._onCollectionChange), this._oldForm && this._oldForm._registerOnCollectionChange(() => { }) } _updateValidators() { eh(this.form, this), this._oldForm && Ru(this._oldForm, this) } _checkFormPresent() { } static #e = this.\u0275fac = function (r) { return new (r || e)(D(Be, 10), D(zn, 10), D(hr, 8)) }; static #t = this.\u0275dir = k({ type: e, selectors: [["", "formGroup", ""]], hostBindings: function (r, o) { 1 & r && Ve("submit", function (s) { return o.onSubmit(s) })("reset", function () { return o.onReset() }) }, inputs: { form: ["formGroup", "form"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [de([p2]), ee, Dt] }) } return e })(); const v2 = { provide: Gn, useExisting: oe(() => uh) }; let uh = (() => { class e extends Gn { set isDisabled(n) { } static #e = this._ngModelWarningSentOnce = !1; constructor(n, r, o, i, s) { super(), this._ngModelWarningConfig = s, this._added = !1, this.name = null, this.update = new pe, this._ngModelWarningSent = !1, this._parent = n, this._setValidators(r), this._setAsyncValidators(o), this.valueAccessor = rh(0, i) } ngOnChanges(n) { this._added || this._setUpControl(), nh(n, this.viewModel) && (this.viewModel = this.model, this.formDirective.updateModel(this, this.model)) } ngOnDestroy() { this.formDirective && this.formDirective.removeControl(this) } viewToModelUpdate(n) { this.viewModel = n, this.update.emit(n) } get path() { return Nu(null == this.name ? this.name : this.name.toString(), this._parent) } get formDirective() { return this._parent ? this._parent.formDirective : null } _checkParentType() { } _setUpControl() { this._checkParentType(), this.control = this.formDirective.addControl(this), this._added = !0 } static #t = this.\u0275fac = function (r) { return new (r || e)(D(Qe, 13), D(Be, 10), D(zn, 10), D(nn, 10), D(ih, 8)) }; static #n = this.\u0275dir = k({ type: e, selectors: [["", "formControlName", ""]], inputs: { name: ["formControlName", "name"], isDisabled: ["disabled", "isDisabled"], model: ["ngModel", "model"] }, outputs: { update: "ngModelChange" }, features: [de([v2]), ee, Dt] }) } return e })(), oE = (() => { class e { static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275mod = _t({ type: e }); static #n = this.\u0275inj = at({ imports: [$b] }) } return e })(); class iE extends Ou { constructor(t, n, r) { super(Jf(n), Kf(r, n)), this.controls = t, this._initObservables(), this._setUpdateStrategy(n), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } at(t) { return this.controls[this._adjustIndex(t)] } push(t, n = {}) { this.controls.push(t), this._registerControl(t), this.updateValueAndValidity({ emitEvent: n.emitEvent }), this._onCollectionChange() } insert(t, n, r = {}) { this.controls.splice(t, 0, n), this._registerControl(n), this.updateValueAndValidity({ emitEvent: r.emitEvent }) } removeAt(t, n = {}) { let r = this._adjustIndex(t); r < 0 && (r = 0), this.controls[r] && this.controls[r]._registerOnCollectionChange(() => { }), this.controls.splice(r, 1), this.updateValueAndValidity({ emitEvent: n.emitEvent }) } setControl(t, n, r = {}) { let o = this._adjustIndex(t); o < 0 && (o = 0), this.controls[o] && this.controls[o]._registerOnCollectionChange(() => { }), this.controls.splice(o, 1), n && (this.controls.splice(o, 0, n), this._registerControl(n)), this.updateValueAndValidity({ emitEvent: r.emitEvent }), this._onCollectionChange() } get length() { return this.controls.length } setValue(t, n = {}) { Ob(this, 0, t), t.forEach((r, o) => { Tb(this, !1, o), this.at(o).setValue(r, { onlySelf: !0, emitEvent: n.emitEvent }) }), this.updateValueAndValidity(n) } patchValue(t, n = {}) { null != t && (t.forEach((r, o) => { this.at(o) && this.at(o).patchValue(r, { onlySelf: !0, emitEvent: n.emitEvent }) }), this.updateValueAndValidity(n)) } reset(t = [], n = {}) { this._forEachChild((r, o) => { r.reset(t[o], { onlySelf: !0, emitEvent: n.emitEvent }) }), this._updatePristine(n), this._updateTouched(n), this.updateValueAndValidity(n) } getRawValue() { return this.controls.map(t => t.getRawValue()) } clear(t = {}) { this.controls.length < 1 || (this._forEachChild(n => n._registerOnCollectionChange(() => { })), this.controls.splice(0), this.updateValueAndValidity({ emitEvent: t.emitEvent })) } _adjustIndex(t) { return t < 0 ? t + this.length : t } _syncPendingControls() { let t = this.controls.reduce((n, r) => !!r._syncPendingControls() || n, !1); return t && this.updateValueAndValidity({ onlySelf: !0 }), t } _forEachChild(t) { this.controls.forEach((n, r) => { t(n, r) }) } _updateValue() { this.value = this.controls.filter(t => t.enabled || this.disabled).map(t => t.value) } _anyControls(t) { return this.controls.some(n => n.enabled && t(n)) } _setUpControls() { this._forEachChild(t => this._registerControl(t)) } _allControlsDisabled() { for (const t of this.controls) if (t.enabled) return !1; return this.controls.length > 0 || this.disabled } _registerControl(t) { t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange) } _find(t) { return this.at(t) ?? null } } function sE(e) { return !!e && (void 0 !== e.asyncValidators || void 0 !== e.validators || void 0 !== e.updateOn) } let P2 = (() => { class e { constructor() { this.useNonNullable = !1 } get nonNullable() { const n = new e; return n.useNonNullable = !0, n } group(n, r = null) { const o = this._reduceControls(n); let i = {}; return sE(r) ? i = r : null !== r && (i.validators = r.validator, i.asyncValidators = r.asyncValidator), new rs(o, i) } record(n, r = null) { const o = this._reduceControls(n); return new Nb(o, r) } control(n, r, o) { let i = {}; return this.useNonNullable ? (sE(r) ? i = r : (i.validators = r, i.asyncValidators = o), new as(n, { ...i, nonNullable: !0 })) : new as(n, r, o) } array(n, r, o) { const i = n.map(s => this._createControl(s)); return new iE(i, r, o) } _reduceControls(n) { const r = {}; return Object.keys(n).forEach(o => { r[o] = this._createControl(n[o]) }), r } _createControl(n) { return n instanceof as || n instanceof Ou ? n : Array.isArray(n) ? this.control(n[0], n.length > 1 ? n[1] : null, n.length > 2 ? n[2] : null) : this.control(n) } static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275prov = T({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(), x2 = (() => { class e { static withConfig(n) { return { ngModule: e, providers: [{ provide: hr, useValue: n.callSetDisabledState ?? os }] } } static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275mod = _t({ type: e }); static #n = this.\u0275inj = at({ imports: [oE] }) } return e })(), R2 = (() => { class e { static withConfig(n) { return { ngModule: e, providers: [{ provide: ih, useValue: n.warnOnNgModelWithFormControl ?? "always" }, { provide: hr, useValue: n.callSetDisabledState ?? os }] } } static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275mod = _t({ type: e }); static #n = this.\u0275inj = at({ imports: [oE] }) } return e })(); const Lu_API_KEY = "http://localhost:9876"; let k2 = (() => { class e { constructor(n) { this.http = n } get(n, r) { return this.http.get(n = `${Lu_API_KEY}/${n}`, r).pipe(jt(this.handleError)) } post(n, r, o) { return this.http.post(n = `${Lu_API_KEY}/${n}`, r, o).pipe(jt(this.handleError)) } put(n, r, o) { return this.http.put(n = `${Lu_API_KEY}/${n}`, r, o).pipe(jt(this.handleError)) } delete(n, r) { return this.http.delete(n = `${Lu_API_KEY}/${n}`, r).pipe(jt(this.handleError)) } handleError(n) { return yo(n) } static #e = this.\u0275fac = function (r) { return new (r || e)(A(RD)) }; static #t = this.\u0275prov = T({ token: e, factory: e.\u0275fac, providedIn: "root" }) } return e })(); function L2(e, t) { if (1 & e) { const n = function Vv() { return y() }(); S(0, "div", 71)(1, "a", 72), O(2), I(), S(3, "div", 73)(4, "a", 74), O(5), I(), S(6, "button", 75), Ve("click", function () { const i = function Vp(e) { return R.lFrame.contextLView = e, e[ve] }(n).index; return function jp(e) { return R.lFrame.contextLView = null, e }(zv().copy(i)) }), O(7), I()()() } if (2 & e) { const n = t.$implicit; qe(2), so(n.link), qe(3), so(n.link), qe(1), Et("ngClass", "Copied" == n.text ? "btn_copy_copied" : "btn_copy"), qe(1), so(n.text) } } function V2(e, t) { 1 & e && (S(0, "span", 76), O(1, " Please enter your name "), I()) } function j2(e, t) { 1 & e && (S(0, "span", 76), O(1, " Please enter your email "), I()) } function B2(e, t) { 1 & e && (S(0, "span", 76), O(1, " Please enter valid email "), I()) } function H2(e, t) { 1 & e && (S(0, "span", 76), O(1, " Please enter your mobile number "), I()) } function $2(e, t) { 1 & e && (S(0, "span", 76), O(1, " Please enter valid mobile number "), I()) } function U2(e, t) { 1 & e && (S(0, "span", 76), O(1, " Please enter your message "), I()) } const z2 = [{ path: "", redirectTo: "shorten-Links", pathMatch: "full" }, { path: "shorten-Links", component: (() => { class e { constructor(n, r) { this.fb = n, this.http = r, this.copyText = "", this.link = "", this.validUrl = !1, this.errorMsg = "", this.linkList = [], this.contactValid = !1 } ngOnInit() { this.contactUsForm = this.fb.group({ userName: ["", [To.required]], email: ["", [To.required, To.email]], mobileNumber: ["", [To.required, To.pattern("^((\\+91-?)|0)?[0-9]{10}$")]], message: ["", [To.required]] }), localStorage.getItem("linkList"), this.linkList = JSON.parse(localStorage.getItem("linkList") || "[]") } copy(n) { null != this.linkList && this.linkList.length > 0 && (this.linkList.forEach((r, o) => { o == n ? (r.text = "Copied", $()) : r.text = "Copy" }), localStorage.setItem("linkList", JSON.stringify(this.linkList))) } addLink() { console.log(this.link), this.link.length > 0 ? (this.validUrl = !1, this.errorMsg = "", /^((https?|ftp|smtp):\/\/)?(www.)?[a-z0-9]+(\.[a-z]{2,}){1,3}(#?\/?[a-zA-Z0-9#]+)*\/?(\?[a-zA-Z0-9-_]+=[a-zA-Z0-9-%]+&?)?$/.test(this.link) ? (this.validUrl = !0, this.errorMsg = "", this.linkList.push({ text: "Copy", link: this.link }), localStorage.setItem("linkList", JSON.stringify(this.linkList))) : (this.validUrl = !1, this.errorMsg = "Please add a valid link")) : (this.validUrl = !0, this.errorMsg = "Please add a link") } submit() { this.contactValid = !0, this.contactUsForm.invalid ? console.log(this.contactUsForm) : this.http.post("api/contactUs", { userName: this.contactUsForm.value.userName, email: this.contactUsForm.value.email, mobileNumber: this.contactUsForm.value.mobileNumber, message: this.contactUsForm.value.message }).subscribe(r => { 1 == r.isSuccessful && console.log(r) }) } static #e = this.\u0275fac = function (r) { return new (r || e)(D(P2), D(k2)) }; static #t = this.\u0275cmp = Ds({ type: e, selectors: [["app-short-links"]], decls: 192, vars: 10, consts: [[1, "bg-white"], [1, "mx-auto", "mt-3", "container"], [1, "navbar", "navbar-expand-lg", "bg-white"], [1, "container-fluid", "nav-container"], ["type", "button", "data-bs-toggle", "collapse", "data-bs-target", "#navbarTogglerDemo01", "aria-controls", "navbarTogglerDemo01", "aria-expanded", "false", "aria-label", "Toggle navigation", 1, "navbar-toggler"], [1, "navbar-toggler-icon"], ["href", "#", 1, "navbar-brand"], ["id", "navbarTogglerDemo01", 1, "collapse", "navbar-collapse"], ["id", "effect", 1, "navbar-nav", "me-auto", "mb-2", "mb-lg-0", "dropdown_menu-9"], [1, "nav-item"], ["aria-current", "page", "href", "#", 1, "nav-link", "active"], ["href", "#", 1, "nav-link"], ["role", "search", 1, "d-flex"], ["type", "submit", "id", "login", 1, "btn", "login"], ["type", "submit", 1, "btn", "signUp"], [1, "row", "align-items-baseline", "py-5"], [1, "left_Content", "col-lg-6", "col-xl-6", "col-md-12"], [1, "btn"], [1, "right_Content", "col-lg-6", "col-xl-6", "col-md-12", "pb-3"], ["src", "assets/short_links/images/illustration-working.svg", "alt", "", 1, "img-fluid"], [1, "container-fluid", "section", "mt-5", "pb-5"], [1, "container"], [1, "link_bg_img"], [1, "input-group", "p-5", "gap-5"], ["type", "email", "id", "exampleFormControlInput1", "placeholder", "Shorten a link here...", 1, "form-control", 3, "ngModel", "ngModelChange"], ["type", "button", "id", "button-addon2", 1, "btn", 3, "click"], [1, "text-danger", "p-3"], ["class", "add_Short_link bg-white d-flex justify-content-between p-3 mb-3", 4, "ngFor", "ngForOf"], [1, "link_bg_description", "py-5"], [1, "d-flex", "justify-content-between", "position-relative", "statics"], [1, "m-2", "static_card"], [1, "card-body"], [1, "position-absolute", "icon"], ["src", "assets/short_links/images/icon-brand-recognition.svg", "alt", ""], [1, "pt-3", "text-start", "text-md-center"], [1, "py-2"], [1, "diff-card"], [1, "position-absolute", "icon", "rounded-circle"], ["src", "assets/short_links/images/icon-detailed-records.svg", "alt", ""], [1, "diff-card1"], ["src", "assets/short_links/images/icon-fully-customizable.svg", "alt", ""], [1, "container-fluid", "contact_section"], [1, "row"], [1, "col-lg-6", "d-flex", "justify-content-center", "align-items-center", "flex-column"], [1, "col-lg-6"], [1, "card"], [1, "", 3, "formGroup"], [1, "mb-3"], ["for", "exampleFormControlInput1", 1, "form-label"], ["type", "text", "id", "exampleFormControlInput1", "placeholder", "Please enter your name", "formControlName", "userName", 1, "form-control"], ["class", "text-danger", 4, "ngIf"], ["type", "email", "id", "exampleFormControlInput1", "placeholder", "Please enter your email", "formControlName", "email", 1, "form-control"], ["type", "tel", "id", "exampleFormControlInput1", "placeholder", "Please enter your mobile number", "formControlName", "mobileNumber", 1, "form-control"], ["for", "exampleFormControlTextarea1", 1, "form-label"], ["id", "exampleFormControlTextarea1", "rows", "3", "formControlName", "message", 1, "form-control"], ["type", "submit", 1, "btn", 3, "click"], [1, "container-fluid"], [1, "bg_shorten_img"], [1, "text-center", "d-flex", "flex-column", "align-items-center", "justify-content-center", "h-100"], [1, "col-lg-2", "d-flex", "justify-content-center", "col-md-12"], [1, "col-lg-10", "d-flex", "col-md-12", "footer_links"], [1, "col-lg-3", "col-md-12", "pb-3"], [1, "head"], ["href", "#"], [1, "p-0", "m-0", "pt-3"], [1, "col-lg-1", "col-md-12", "pb-3", "d-flex", "justify-content-center"], [1, "d-flex", "gap-3", "align-items-center"], ["src", "assets/short_links/images/icon-facebook.svg"], ["src", "assets/short_links/images/icon-twitter.svg"], ["src", "assets/short_links/images/icon-pinterest.svg"], ["src", "assets/short_links/images/icon-instagram.svg"], [1, "add_Short_link", "bg-white", "d-flex", "justify-content-between", "p-3", "mb-3"], ["href", ""], [1, "d-flex", "justify-content-between", "gap-3", "align-items-center"], ["href", "", 1, "short_links"], ["role", "button", 1, "btn", "btn_copy", 3, "ngClass", "click"], [1, "text-danger"]], template: function (r, o) { 1 & r && (S(0, "div", 0)(1, "main", 1)(2, "nav", 2)(3, "div", 3)(4, "button", 4), Ie(5, "span", 5), I(), S(6, "a", 6), O(7, "Shortly"), I(), S(8, "div", 7)(9, "ul", 8)(10, "li", 9)(11, "a", 10), O(12, "Features"), I()(), S(13, "li", 9)(14, "a", 11), O(15, "Pricing"), I()(), S(16, "li", 9)(17, "a", 11), O(18, "Resources"), I()()(), S(19, "form", 12)(20, "button", 13), O(21, "Login"), I(), S(22, "button", 14), O(23, "Sign Up"), I()()()()(), S(24, "header", 15)(25, "div", 16)(26, "h1"), O(27, "More than just shorter links"), I(), S(28, "p"), O(29, "Build your brand's recognition and get detailed insights on how your links are performing."), I(), S(30, "button", 17), O(31, "Get Started"), I()(), S(32, "div", 18), Ie(33, "img", 19), I()()(), S(34, "div", 20)(35, "section", 21)(36, "div", 22)(37, "div", 23)(38, "input", 24), Ve("ngModelChange", function (s) { return o.link = s }), I(), S(39, "button", 25), Ve("click", function () { return o.addLink() }), O(40, "Shorten it!"), I()(), S(41, "span", 26), O(42), I()(), Rn(43, L2, 8, 4, "div", 27), S(44, "div", 28)(45, "div")(46, "h3"), O(47, "Advanced Statistics"), I(), S(48, "p"), O(49, "Track how your links are performing across the web with our advanced statistics dashboard."), I()()(), S(50, "div", 29)(51, "div", 30)(52, "div", 31)(53, "div", 32), Ie(54, "img", 33), I(), S(55, "div", 34)(56, "h4", 35), O(57, "Brand Recognition"), I(), S(58, "p"), O(59, "Boost your brand recognition with each click. Generic links don\u2019t mean a thing. Branded links help instil confidence in your content."), I()()()(), S(60, "div", 30), Ie(61, "div", 36), S(62, "div", 31)(63, "div", 37), Ie(64, "img", 38), I(), S(65, "div", 34)(66, "h4", 35), O(67, "Detailed Records"), I(), S(68, "p"), O(69, "Gain insights into who is clicking your links. Knowing when and where people engage with your content helps inform better decisions."), I()()()(), S(70, "div", 30), Ie(71, "div", 39), S(72, "div", 31)(73, "div", 32), Ie(74, "img", 40), I(), S(75, "div", 34)(76, "h4", 35), O(77, "Fully Customizable"), I(), S(78, "p"), O(79, "Improve brand awareness and content discoverability through customizable links, supercharging audience engagement."), I()()()()()()(), S(80, "section", 41)(81, "div", 42)(82, "div", 43)(83, "h4"), O(84, "Get In Touch With Us"), I(), S(85, "p"), O(86, "We're here to assist you! If you have any questions or need assistance, please feel free to reach out to us."), I()(), S(87, "div", 44)(88, "div", 45)(89, "div", 31)(90, "h4"), O(91, "Send us a Message"), I(), S(92, "p"), O(93, "Fill out the form and we will get back to you as soon as possible"), I(), S(94, "form", 46)(95, "div", 47)(96, "label", 48), O(97, "Username"), I(), Ie(98, "input", 49), Rn(99, V2, 2, 0, "span", 50), I(), S(100, "div", 47)(101, "label", 48), O(102, "Email address"), I(), Ie(103, "input", 51), Rn(104, j2, 2, 0, "span", 50), Rn(105, B2, 2, 0, "span", 50), I(), S(106, "div", 47)(107, "label", 48), O(108, "Mobile Number"), I(), Ie(109, "input", 52), Rn(110, H2, 2, 0, "span", 50), Rn(111, $2, 2, 0, "span", 50), I(), S(112, "div", 47)(113, "label", 53), O(114, "Message"), I(), Ie(115, "textarea", 54), Rn(116, U2, 2, 0, "span", 50), I(), S(117, "div", 47)(118, "button", 55), Ve("click", function () { return o.submit() }), O(119, "Submit"), I()()()()()()()(), S(120, "section", 56)(121, "div", 57)(122, "div", 58)(123, "h1"), O(124, "Boost your links today"), I(), S(125, "button", 17), O(126, "Get Started"), I()()()(), S(127, "footer")(128, "div", 56)(129, "div", 42)(130, "div", 59)(131, "a", 6), O(132, "Shortly"), I()(), S(133, "div", 60)(134, "div", 61)(135, "ul")(136, "li", 62)(137, "a", 63), O(138, "Features"), I()(), S(139, "ul", 64)(140, "li")(141, "a", 63), O(142, "Link Shortening"), I()(), S(143, "li")(144, "a", 63), O(145, "Branded Links"), I()(), S(146, "li")(147, "a", 63), O(148, "Analytics"), I()()()()(), S(149, "div", 61)(150, "ul")(151, "li", 62)(152, "a", 63), O(153, "Resources"), I()(), S(154, "ul", 64)(155, "li")(156, "a", 63), O(157, "Blog"), I()(), S(158, "li")(159, "a", 63), O(160, "Developers"), I()(), S(161, "li")(162, "a", 63), O(163, "Support"), I()()()()(), S(164, "div", 61)(165, "ul")(166, "li", 62)(167, "a", 63), O(168, "Company"), I()(), S(169, "ul", 64)(170, "li")(171, "a", 63), O(172, "About"), I()(), S(173, "li")(174, "a", 63), O(175, "Our Team"), I()(), S(176, "li")(177, "a", 63), O(178, "Careers"), I()(), S(179, "li")(180, "a", 63), O(181, "Contact"), I()()()()(), S(182, "div", 65)(183, "ul", 66)(184, "li"), Ie(185, "img", 67), I(), S(186, "li"), Ie(187, "img", 68), I(), S(188, "li"), Ie(189, "img", 69), I(), S(190, "li"), Ie(191, "img", 70), I()()()()()()()()), 2 & r && (qe(38), Et("ngModel", o.link), qe(4), so(o.errorMsg), qe(1), Et("ngForOf", o.linkList), qe(51), Et("formGroup", o.contactUsForm), qe(5), Et("ngIf", o.contactValid && o.contactUsForm.get("userName").hasError("required")), qe(5), Et("ngIf", o.contactValid && o.contactUsForm.get("email").hasError("required")), qe(1), Et("ngIf", o.contactValid && o.contactUsForm.get("email").hasError("email")), qe(5), Et("ngIf", o.contactValid && o.contactUsForm.get("mobileNumber").hasError("required")), qe(1), Et("ngIf", o.contactValid && o.contactUsForm.get("mobileNumber").hasError("pattern")), qe(5), Et("ngIf", o.contactValid && o.contactUsForm.get("message").hasError("required"))) }, dependencies: [XC, KC, tD, Bb, Eu, Ib, Sb, ku, uh, oh, Fu], styles: ['.bg-white[_ngcontent-%COMP%]{font-family:Poppins,sans-serif}.bg-white[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]{--tw-bg-opacity: 1;background-color:rgb(239 241 247/var(--tw-bg-opacity));width:100%}.bg-white[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .link_bg_img[_ngcontent-%COMP%]{background:url(bg-shorten-desktop.56f991468ef78f61.svg) no-repeat;background-size:cover;background-color:var(--very-dark-blue-color);border-radius:10px;position:relative;top:-72px;height:8.5rem}.bg-white[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .link_bg_img[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{border-radius:.375rem!important;height:3rem}.bg-white[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .link_bg_img[_ngcontent-%COMP%]   [_ngcontent-%COMP%]::placeholder{font-weight:500;font-size:16px;line-height:21px;color:var(--gray-color)}.bg-white[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .link_bg_img[_ngcontent-%COMP%]   .form-control[_ngcontent-%COMP%]:focus{box-shadow:none;border:none}.bg-white[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .link_bg_img[_ngcontent-%COMP%]   .form-control[_ngcontent-%COMP%]:focus-visible{outline:0}.bg-white[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .link_bg_img[_ngcontent-%COMP%]   .btn[_ngcontent-%COMP%]{background:var(--Cyan);border-radius:10px;font-weight:500;font-size:14px;height:3rem;line-height:21px;color:var(--neutral-color);padding:.5rem 1rem;border:none}.bg-white[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .link_bg_img[_ngcontent-%COMP%]   .btn[_ngcontent-%COMP%]:hover{opacity:.4}.bg-white[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .add_Short_link[_ngcontent-%COMP%]   .short_links[_ngcontent-%COMP%]{font-weight:500;font-size:16px;line-height:24px;color:var(--Cyan)}.bg-white[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .add_Short_link[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{text-decoration:none;font-weight:700;line-height:36px;color:var(--very-dark-blue-color)}.bg-white[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .add_Short_link[_ngcontent-%COMP%]   .btn_copy[_ngcontent-%COMP%]{background:var(--Cyan);border-radius:.375rem;font-weight:500;font-size:14px;line-height:21px;color:var(--neutral-color);padding:.5rem 1rem;border:none}.bg-white[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .add_Short_link[_ngcontent-%COMP%]   .btn_copy_copied[_ngcontent-%COMP%]{background:var(--very-dark-blue-color)}.bg-white[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .link_bg_description[_ngcontent-%COMP%]{text-align:center;font-size:2.25rem;line-height:2.5rem;font-weight:700;color:var(--very-dark-blue-color)}.bg-white[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .link_bg_description[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{font-weight:500;font-size:16px;line-height:24px;color:var(--gray-color)}.bg-white[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .statics[_ngcontent-%COMP%]{z-index:0}.bg-white[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .statics[_ngcontent-%COMP%]   .static_card[_ngcontent-%COMP%]{border:none}.bg-white[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .statics[_ngcontent-%COMP%]   .static_card[_ngcontent-%COMP%]   .diff-card[_ngcontent-%COMP%]{width:100%;height:2.5rem;display:inline-block}.bg-white[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .statics[_ngcontent-%COMP%]   .static_card[_ngcontent-%COMP%]   .diff-card1[_ngcontent-%COMP%]{width:100%;height:5.5rem;display:inline-block}.bg-white[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .statics[_ngcontent-%COMP%]   .static_card[_ngcontent-%COMP%]   .card-body[_ngcontent-%COMP%]{position:relative;padding:10px;background-color:#fff;box-shadow:#00000059 0 5px 15px;border-radius:10px}.bg-white[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .statics[_ngcontent-%COMP%]   .static_card[_ngcontent-%COMP%]   .card-body[_ngcontent-%COMP%]   .icon[_ngcontent-%COMP%]{padding:7px;border-radius:50px;background:var(--very-dark-blue-color);top:-35px;left:20px}.bg-white[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .statics[_ngcontent-%COMP%]   .static_card[_ngcontent-%COMP%]   .card-body[_ngcontent-%COMP%]   .icon[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{width:40px}.bg-white[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .statics[_ngcontent-%COMP%]   .static_card[_ngcontent-%COMP%]   .card-body[_ngcontent-%COMP%]   h4[_ngcontent-%COMP%]{font-size:1.25rem;line-height:2.5rem;font-weight:700}.bg-white[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .statics[_ngcontent-%COMP%]   .static_card[_ngcontent-%COMP%]   .card-body[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{font-weight:500;font-size:16px;line-height:24px;color:var(--gray-color)}.bg-white[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .statics[_ngcontent-%COMP%]:after{content:"";position:absolute;border:1px solid var(--Cyan);width:33rem;height:5px;background:var(--Cyan);bottom:50%;left:32%;z-index:-1}.bg-white[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]{padding:0}.bg-white[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .bg_shorten_img[_ngcontent-%COMP%]{background:url(bg-boost-desktop.1981fbd475278b3a.svg) no-repeat;background-size:cover;background-color:var(--very-dark-blue-color);height:250px}.bg-white[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .bg_shorten_img[_ngcontent-%COMP%]   h1[_ngcontent-%COMP%]{font-weight:700;font-size:36px;line-height:54px;color:var(--neutral-color);padding-top:30px;text-align:center}.bg-white[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .bg_shorten_img[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{background:var(--Cyan);border-radius:50px;font-weight:500;font-size:14px;line-height:21px;color:var(--neutral-color);padding:.5rem 1rem;border:none;text-align:center}.bg-white[_ngcontent-%COMP%]   .contact_section[_ngcontent-%COMP%]{background-color:#fff;padding:2rem}.bg-white[_ngcontent-%COMP%]   .contact_section[_ngcontent-%COMP%]   h4[_ngcontent-%COMP%]{font-weight:700;font-size:30px;line-height:54px}.bg-white[_ngcontent-%COMP%]   .contact_section[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{font-weight:500;font-size:16px;line-height:24px}.bg-white[_ngcontent-%COMP%]   .contact_section[_ngcontent-%COMP%]   .card[_ngcontent-%COMP%]{box-shadow:#00000059 0 5px 15px}.bg-white[_ngcontent-%COMP%]   .contact_section[_ngcontent-%COMP%]   .card[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{background:var(--Cyan);border-radius:50px;font-weight:500;font-size:14px;line-height:21px;color:var(--neutral-color);padding:.5rem 1rem;border:none;text-align:center}.bg-white[_ngcontent-%COMP%]   .navbar[_ngcontent-%COMP%]   .navbar-brand[_ngcontent-%COMP%]{font-weight:700;font-size:24px;line-height:36px;color:var(--very-dark-blue-color)}.bg-white[_ngcontent-%COMP%]   .navbar[_ngcontent-%COMP%]   .navbar-nav[_ngcontent-%COMP%]   .nav-link[_ngcontent-%COMP%]{font-weight:500;font-size:14px;line-height:21px;color:var(--gray-color)}.bg-white[_ngcontent-%COMP%]   .navbar[_ngcontent-%COMP%]   .navbar-nav[_ngcontent-%COMP%]   .nav-link[_ngcontent-%COMP%]:hover{color:var(--very-dark-blue-color)}.bg-white[_ngcontent-%COMP%]   .navbar[_ngcontent-%COMP%]   .signUp[_ngcontent-%COMP%]{background:var(--Cyan);border-radius:50px;font-weight:500;font-size:14px;line-height:21px;color:var(--neutral-color);padding:.5rem 1rem;border:none}.bg-white[_ngcontent-%COMP%]   .navbar[_ngcontent-%COMP%]   .login[_ngcontent-%COMP%]{border-radius:50px;font-weight:500;font-size:14px;line-height:21px;color:var(--gray-color);border:none}.bg-white[_ngcontent-%COMP%]   .navbar[_ngcontent-%COMP%]   .signUp[_ngcontent-%COMP%]:hover{opacity:.4}.bg-white[_ngcontent-%COMP%]   header[_ngcontent-%COMP%]   .left_Content[_ngcontent-%COMP%]   h1[_ngcontent-%COMP%]{font-weight:700;font-size:3rem;color:var(--very-dark-blue-color)}.bg-white[_ngcontent-%COMP%]   header[_ngcontent-%COMP%]   .left_Content[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{font-weight:500;font-size:20px;color:var(--gray-color)}.bg-white[_ngcontent-%COMP%]   header[_ngcontent-%COMP%]   .left_Content[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{background:var(--Cyan);border-radius:50px;font-weight:500;font-size:14px;color:var(--neutral-color);padding:.5rem 1rem;border:none}.bg-white[_ngcontent-%COMP%]   header[_ngcontent-%COMP%]   .right_Content[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{width:100%}.bg-white[_ngcontent-%COMP%]   footer[_ngcontent-%COMP%]{background:var(--very-dark-violet-color);color:var(--neutral-color);padding:3rem 0}.bg-white[_ngcontent-%COMP%]   footer[_ngcontent-%COMP%]   .navbar-brand[_ngcontent-%COMP%]{font-weight:700;font-size:24px;line-height:36px}.bg-white[_ngcontent-%COMP%]   footer[_ngcontent-%COMP%]   ul[_ngcontent-%COMP%]{list-style-type:none;padding:0;margin:0}.bg-white[_ngcontent-%COMP%]   footer[_ngcontent-%COMP%]   ul[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]{font-weight:500;font-size:14px;line-height:30px}.bg-white[_ngcontent-%COMP%]   footer[_ngcontent-%COMP%]   ul[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{text-decoration:none;color:var(--gray-color)}.bg-white[_ngcontent-%COMP%]   footer[_ngcontent-%COMP%]   ul[_ngcontent-%COMP%]   .head[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{color:var(--neutral-color)}.bg-white[_ngcontent-%COMP%]   footer[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:hover{color:var(--Cyan)!important}.bg-white[_ngcontent-%COMP%]   footer[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]:hover{background-color:var(--Cyan)!important}.bg-white[_ngcontent-%COMP%]   .btn[_ngcontent-%COMP%]:hover{opacity:.4}@media (max-width: 991px){.bg-white[_ngcontent-%COMP%]   .navbar[_ngcontent-%COMP%]   .nav-container[_ngcontent-%COMP%]{flex-direction:row-reverse!important}.bg-white[_ngcontent-%COMP%]   header[_ngcontent-%COMP%]{flex-direction:column-reverse}.bg-white[_ngcontent-%COMP%]   header[_ngcontent-%COMP%]   .left_Content[_ngcontent-%COMP%]{text-align:center}.bg-white[_ngcontent-%COMP%]   header[_ngcontent-%COMP%]   .left_Content[_ngcontent-%COMP%]   .btn[_ngcontent-%COMP%]{height:3rem;width:12rem}.bg-white[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .link_bg_img[_ngcontent-%COMP%]   .input-group[_ngcontent-%COMP%]{flex-direction:column;gap:.5rem!important;padding:1rem!important}.bg-white[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .link_bg_img[_ngcontent-%COMP%]   .input-group[_ngcontent-%COMP%]   .form-control[_ngcontent-%COMP%]{width:100%!important}.bg-white[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .statics[_ngcontent-%COMP%]{flex-direction:column}.bg-white[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .statics[_ngcontent-%COMP%]   .static_card[_ngcontent-%COMP%]{padding-bottom:3rem}.bg-white[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .statics[_ngcontent-%COMP%]   .static_card[_ngcontent-%COMP%]   .diff-card[_ngcontent-%COMP%]{height:0!important;display:none!important}.bg-white[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .statics[_ngcontent-%COMP%]   .static_card[_ngcontent-%COMP%]   .diff-card1[_ngcontent-%COMP%]{display:none!important}.bg-white[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .statics[_ngcontent-%COMP%]   .static_card[_ngcontent-%COMP%]   .card-body[_ngcontent-%COMP%]   .icon[_ngcontent-%COMP%]{left:45%!important}.bg-white[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .statics[_ngcontent-%COMP%]:after{border-left:1px solid var(--Cyan)!important;width:4px!important;height:47%!important;left:50%!important;transform:translate(50%);top:24%!important}.bg-white[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .add_Short_link[_ngcontent-%COMP%]{flex-direction:column!important;align-items:center!important}.bg-white[_ngcontent-%COMP%]   section[_ngcontent-%COMP%]   .add_Short_link[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]{flex-direction:column!important}.bg-white[_ngcontent-%COMP%]   footer[_ngcontent-%COMP%]   .footer_links[_ngcontent-%COMP%]{flex-direction:column}.bg-white[_ngcontent-%COMP%]   footer[_ngcontent-%COMP%]   .footer_links[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]{text-align:center}}'] }) } return e })() }]; let G2 = (() => { class e { static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275mod = _t({ type: e }); static #n = this.\u0275inj = at({ imports: [Kw.forRoot(z2, { useHash: !0 }), Kw] }) } return e })(), q2 = (() => { class e { constructor() { this.title = "frontend_mentor_projects" } static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275cmp = Ds({ type: e, selectors: [["app-root"]], decls: 1, vars: 0, template: function (r, o) { 1 & r && Ie(0, "router-outlet") }, dependencies: [Lf] }) } return e })(), W2 = (() => { class e { static #e = this.\u0275fac = function (r) { return new (r || e) }; static #t = this.\u0275mod = _t({ type: e, bootstrap: [q2] }); static #n = this.\u0275inj = at({ imports: [MF, G2, R2, tk, x2] }) } return e })(); bF().bootstrapModule(W2).catch(e => console.error(e)) } }, ne => { ne(ne.s = 416) }]);